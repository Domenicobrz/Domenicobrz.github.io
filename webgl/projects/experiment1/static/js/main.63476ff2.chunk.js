(this["webpackJsonpreact-three-1"]=this["webpackJsonpreact-three-1"]||[]).push([[0],{38:function(e,n,t){"use strict";t.r(n);var i=t(7),r=t.n(i),o=t(22),a=t.n(o),s=t(23),l=t(26),u=t(10),c=t.n(u),v=t(12),d=t(0),m=t(24),f=t(11),x=t(25),h=t(14),p=t(1),y=t(2),g=function(){function e(n,t){Object(p.a)(this,e),this.material=new d.nb({uniforms:{uTexture:{type:"t",value:null}},vertexShader:"\n                varying vec2 vUv;\n\n                void main() {\n                    vUv = uv;\n                    gl_Position = vec4(position.xy, 0.0, 1.0);    \n                }\n            ",fragmentShader:"\n                uniform sampler2D uTexture;\n\n                varying vec2 vUv;\n\n                void main() {\n                    ".concat(t||"gl_FragColor = texture2D(uTexture, vUv);","  \n                }\n            "),depthTest:!1,depthWrite:!1}),this.mesh=new d.N(new d.ab(2,2),this.material),this.camera=new d.Z(45,1,1,1e3),this.renderer=n,this.scene=new d.lb,this.scene.add(this.mesh)}return Object(y.a)(e,[{key:"blit",value:function(e,n){this.renderer.setRenderTarget(n),this.material.uniforms.uTexture.value=e,this.renderer.render(this.scene,this.camera),this.renderer.setRenderTarget(null)}}]),e}(),w=function(){function e(n,t,i){Object(p.a)(this,e),this.material=new d.nb({uniforms:{uTexture:{type:"t",value:null}},vertexShader:"\n                varying float vDepth;\n\n                void main() {\n                    vDepth = - (modelViewMatrix * vec4(position, 1.0)).z;  \n                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);    \n                }\n            ",fragmentShader:"\n                varying float vDepth;\n\n                void main() {\n                    gl_FragColor = vec4(vDepth, vDepth, vDepth, 1.0);\n                }\n            ",side:d.m}),this.renderer=n,this.scene=t,this.camera=i}return Object(y.a)(e,[{key:"blitDepth",value:function(e){this.renderer.setRenderTarget(e),this.scene.overrideMaterial=this.material,this.renderer.render(this.scene,this.camera),this.scene.overrideMaterial=null,this.renderer.setRenderTarget(null)}}]),e}(),b=function(){function e(n,t,i){Object(p.a)(this,e),this.material=new d.nb({uniforms:{uTexture:{type:"t",value:null},uCameraPos:{value:new d.Cb(0,0,0)}},vertexShader:"\n                varying vec3 vPosition;\n\n                void main() {\n                    vPosition = (modelMatrix * vec4(position, 1.0)).xyz;  \n                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);    \n                }\n            ",fragmentShader:"\n                varying vec3 vPosition;\n\n                uniform vec3 uCameraPos;\n\n                void main() {\n                    float depth = length(vPosition - uCameraPos);\n                    gl_FragColor = vec4(vPosition, depth);\n                }\n            ",side:d.m}),this.renderer=n,this.scene=t,this.camera=i}return Object(y.a)(e,[{key:"blitPosition",value:function(e){this.renderer.setRenderTarget(e),this.material.uniforms.uCameraPos.value=this.camera.position.clone(),this.scene.overrideMaterial=this.material,this.renderer.render(this.scene,this.camera),this.scene.overrideMaterial=null,this.renderer.setRenderTarget(null)}}]),e}(),z=function(){function e(n){Object(p.a)(this,e),this.material=new d.nb({uniforms:{uPosition:{type:"t",value:null},uPlanePosition:{type:"t",value:null},uColor:{type:"t",value:null}},vertexShader:"\n                varying vec2 vUv;\n\n                void main() {\n                    vUv = uv;\n                    gl_Position = vec4(position.xy, 0.0, 1.0);    \n                }\n            ",fragmentShader:"\n                uniform sampler2D uPosition;\n                uniform sampler2D uPlanePosition;\n                uniform sampler2D uColor;\n\n                varying vec2 vUv;\n\n                void main() {   \n                    vec3 position = texture2D(uPosition, vUv).xyz;\n                    vec3 planePosition = texture2D(uPlanePosition, vUv).xyz;\n                    vec3 color = texture2D(uColor, vUv).xyz;\n\n                    // this is necessary to only blit the reflections of the plane \n                    if(planePosition != position) color = vec3(0.0);\n\n                    gl_FragColor = vec4(color, 1.0);\n                }\n            ",depthTest:!1,depthWrite:!1}),this.mesh=new d.N(new d.ab(2,2),this.material),this.camera=new d.Z(45,1,1,1e3),this.renderer=n,this.scene=new d.lb,this.scene.add(this.mesh)}return Object(y.a)(e,[{key:"blitReflectedColor",value:function(e,n,t,i){this.renderer.setRenderTarget(i),this.material.uniforms.uPosition.value=t,this.material.uniforms.uPlanePosition.value=n,this.material.uniforms.uColor.value=e,this.renderer.render(this.scene,this.camera),this.renderer.setRenderTarget(null)}}]),e}(),S=function(){function e(n){Object(p.a)(this,e),this.material=new d.nb({uniforms:{uPosition:{type:"t",value:null},uPlanePosition:{type:"t",value:null},uReflectionPosition:{type:"t",value:null}},vertexShader:"\n                varying vec2 vUv;\n\n                void main() {\n                    vUv = uv;\n                    gl_Position = vec4(position.xy, 0.0, 1.0);    \n                }\n            ",fragmentShader:"\n                uniform sampler2D uPosition;\n                uniform sampler2D uPlanePosition;\n                uniform sampler2D uReflectionPosition;\n\n                varying vec2 vUv;\n\n                void main() {   \n                    vec3 position = texture2D(uPosition, vUv).xyz;\n                    vec3 planePosition = texture2D(uPlanePosition, vUv).xyz;\n                    vec3 reflectedPosition = texture2D(uReflectionPosition, vUv).xyz;\n\n                    float distance = length(reflectedPosition - planePosition);\n                    if(reflectedPosition == vec3(0.0)) distance = 0.0;\n                    \n                    // this is necessary to only blit the reflections of the plane \n                    if(planePosition != position) distance = 0.0;\n\n                    gl_FragColor = vec4(vec3(distance), 1.0);\n                }\n            ",depthTest:!1,depthWrite:!1}),this.mesh=new d.N(new d.ab(2,2),this.material),this.camera=new d.Z(45,1,1,1e3),this.renderer=n,this.scene=new d.lb,this.scene.add(this.mesh)}return Object(y.a)(e,[{key:"blitReflectionDistance",value:function(e,n,t,i){this.renderer.setRenderTarget(i),this.material.uniforms.uPosition.value=t,this.material.uniforms.uPlanePosition.value=n,this.material.uniforms.uReflectionPosition.value=e,this.renderer.render(this.scene,this.camera),this.renderer.setRenderTarget(null)}}]),e}(),T=function(){function e(n,t,i){Object(p.a)(this,e);var r=.45;this.fb0=new d.Fb(t*r,i*r,{type:d.r}),this.fb1=new d.Fb(t*r,i*r,{type:d.r}),this.material=new d.nb({uniforms:{uInputTexture:{type:"t",value:null},uColorTexture:{type:"t",value:null},uOriginalTexture:{type:"t",value:null},uHorizontal:{value:!1},uStep:{value:1},uPixelStep:{value:new d.Bb(1/(t*r),1/(i*r))}},vertexShader:"\n                varying vec2 vUv;\n\n                void main() {\n                    vUv = uv;\n                    gl_Position = vec4(position.xy, 0.0, 1.0);    \n                }\n            ",fragmentShader:"\n                uniform sampler2D uInputTexture;\n                uniform sampler2D uOriginalTexture;\n                uniform sampler2D uColorTexture;\n\n                uniform vec2 uPixelStep;\n                uniform bool uHorizontal;\n                uniform float uStep;\n\n                varying vec2 vUv;\n\n                float weight[5] = float[] (0.227027, 0.1945946, 0.1216216, 0.054054, 0.016216);\n\n                void main() {   \n                    \n\n                    // prendi il valore mediano e poi basi il blur radius su quello\n                    float average = 0.0;\n                    for(int i = -4; i <= +4; i++) {\n                        vec2 offs = vec2(0.0); \n\n                        if(uHorizontal)  offs = vec2(uPixelStep.x * float(i) * (1.0 + uStep * 1.0), 0.0);\n                        if(!uHorizontal) offs = vec2(0.0, uPixelStep.x * float(i) * (1.0 + uStep * 1.0));\n\n                        // if(uHorizontal)  offs = vec2(uPixelStep.x * float(i), 0.0);\n                        // if(!uHorizontal) offs = vec2(0.0, uPixelStep.x * float(i));\n\n                        // USING ORIGINAL TEXTURE\n                        // USING ORIGINAL TEXTURE\n                        // USING ORIGINAL TEXTURE\n                        // USING ORIGINAL TEXTURE\n                        // USING ORIGINAL TEXTURE\n                        float value = texture2D(uOriginalTexture, vUv + offs).x;\n\n                        average += value;\n                    }\n                    average /= 9.0;\n\n\n                    // float blurRadius = 0.25 + average * 15.0;\n                    float blurRadius = 0.125 + average * 7.5;\n\n\n                    // float accum = 0.0;\n                    // for(int i = -4; i <= +4; i++) {\n                    //     vec2 offs = vec2(0.0); \n\n                    //     if(uHorizontal)  offs = vec2(uPixelStep.x * float(i) * blurRadius, 0.0);\n                    //     if(!uHorizontal) offs = vec2(0.0, uPixelStep.x * float(i) * blurRadius);\n\n                    //     float value = texture2D(uInputTexture, vUv + offs).x;\n                        \n                    //     float weightedValue = 0.0;\n                    //     if(i < 0) weightedValue = value * weight[abs(i)];\n                    //     if(i > 0) weightedValue = value * weight[i];\n                    //     if(i == 0) weightedValue = value * weight[0];\n\n                    //     accum += weightedValue;\n                    // }\n                    \n                    // gl_FragColor = vec4(vec3(accum), 1.0);\n\n\n                    vec3 accum = vec3(0.0);\n                    for(int i = -4; i <= +4; i++) {\n                        vec2 offs = vec2(0.0); \n\n                        if(uHorizontal)  offs = vec2(uPixelStep.x * float(i) * blurRadius, 0.0);\n                        if(!uHorizontal) offs = vec2(0.0, uPixelStep.x * float(i) * blurRadius);\n\n                        vec3 value = texture2D(uInputTexture, vUv + offs).xyz;\n                        \n                        vec3 weightedValue = vec3(0.0);\n                        if(i < 0) weightedValue = value * weight[abs(i)];\n                        if(i > 0) weightedValue = value * weight[i];\n                        if(i == 0) weightedValue = value * weight[0];\n\n                        accum += weightedValue;\n                    }\n                    \n                    gl_FragColor = vec4(accum, 1.0);\n                }\n            ",depthTest:!1,depthWrite:!1}),this.mesh=new d.N(new d.ab(2,2),this.material),this.camera=new d.Z(45,1,1,1e3),this.renderer=n,this.scene=new d.lb,this.scene.add(this.mesh),this.blitProgram=new g(n)}return Object(y.a)(e,[{key:"blur",value:function(e,n,t){this.material.uniforms.uOriginalTexture.value=e,this.material.uniforms.uColorTexture.value=n;for(var i=0;i<7;i++)this.material.uniforms.uStep.value=1+i,this.renderer.setRenderTarget(this.fb0),this.material.uniforms.uHorizontal.value=!0,this.material.uniforms.uInputTexture.value=this.fb1.texture,0===i&&(this.material.uniforms.uInputTexture.value=n),this.renderer.render(this.scene,this.camera),this.renderer.setRenderTarget(this.fb1),this.material.uniforms.uHorizontal.value=!1,this.material.uniforms.uInputTexture.value=this.fb0.texture,this.renderer.render(this.scene,this.camera);this.blitProgram.blit(this.fb1.texture,t)}}]),e}(),C=function(){function e(n,t){var i=this;Object(p.a)(this,e);var r=800;this.hoverN=200,this.particles=[];for(var o=0;o<r;o++)this.particles.push(this.createParticle());this.particlesGeo=new d.g;var a=new Float32Array(9*r);this.particlesGeo.setAttribute("position",new d.f(a,3)),this.particlesMaterial=new d.nb({vertexShader:"\n      varying vec3 vWorldPos;\n\n      void main() {\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);    \n        vWorldPos = (modelMatrix * vec4(position, 1.0)).xyz;\n      }\n      ",fragmentShader:"\n      varying vec3 vWorldPos;\n     \n      void main() {   \n\n        // vec3 sphereCenter = vec3(0.71, -0.13, -0.05);\n        // vec3 dir = normalize(vWorldPos - sphereCenter);\n\n        // float d = clamp(dot(dir, vec3(1.0, -0.75, -0.8)), 0.0, 1.0);\n        // d = pow(d, 6.0);\n        // d = clamp(d, 0.0, 0.75);\n\n        gl_FragColor = vec4(1.0, 0.5, 0.5, 0.8);\n        // gl_FragColor = vec4(vec3(1.0, 0.5, 0.5) * (1.0 - d), 0.8);\n      }\n      ",side:d.m,transparent:!0,blendEquation:d.a,blending:d.b}),this.mesh=new d.N(this.particlesGeo,this.particlesMaterial),this.clock=new d.i,this.clock.start();var s=new d.jb;this.raycastPoint=new d.Cb(0,0,0),this.raycastDelta=new d.Cb(0,0,0),this.windLevel=0,window.addEventListener("mousemove",(function(e){var o=new d.Bb(e.clientX/window.innerWidth*2-1,-e.clientY/window.innerHeight*2+1);s.setFromCamera(o,n);var a=s.intersectObjects(t.children);if(a[0]){var l=a[0].point;if(0==i.raycastPoint.x&&0==i.raycastPoint.y&&0==i.raycastPoint.z)i.raycastPoint=l;else{i.raycastDelta=i.raycastPoint.clone().sub(l),i.raycastPoint=l;for(var u=0;u<2;u++){var c=Math.floor(Math.random()*i.hoverN)+(r-i.hoverN);c>=r&&(c=799),c<=0&&(c=0);var v=new d.sb(.025+.1*Math.random(),Math.random()*Math.PI,2*Math.random()*Math.PI);i.particles[c]=i.createParticle(),i.particles[c].position=i.raycastPoint.clone().add((new d.Cb).setFromSpherical(v).add(new d.Cb(0,.05,0))),i.particles[c].velocity=i.raycastDelta.clone().multiplyScalar(.5*-(1*Math.random()+.5))}}}}))}return Object(y.a)(e,[{key:"createParticle",value:function(){var e=new d.sb(.35+Math.pow(1*Math.random(),1),Math.random()*Math.PI,2*Math.random()*Math.PI);return{position:(new d.Cb).setFromSpherical(e).add(new d.Cb(.71,-.13,-.05)),velocity:new d.Cb(0,0,0),rotx:0,roty:0,rotz:0,rotxS:.02*Math.random(),rotyS:.02*Math.random(),rotzS:.02*Math.random(),t:0,radius:.013+.035*Math.random(),accumulatedWindTranslation:0,age:20*Math.random(),swirlRadius:.001*Math.random(),swirlSpeed:.7*Math.random()+.3,gravitySpeed:.01*Math.random()+.002*Math.random()}}},{key:"setWindLevel",value:function(e){this.windLevel=e}},{key:"update",value:function(){for(var e=this.clock.getDelta(),n=this.particles.length,t=0;t<n;t++){if((this.particles[t].position.y<-.5||this.particles[t].age>20)&&t<=n-this.hoverN){new d.sb(.35+Math.pow(1*Math.random(),1),Math.random()*Math.PI,2*Math.random()*Math.PI);this.particles[t]=this.createParticle()}var i=this.particles[t],r=i.position;if(i.rotx+=i.rotxS,i.roty+=i.rotyS,i.rotz+=i.rotzS,i.age+=e,i.t+=e,i.position.add(new d.Cb(Math.sin(i.t*i.swirlSpeed)*i.swirlRadius,-i.gravitySpeed*e,Math.cos(i.t*i.swirlSpeed)*i.swirlRadius)),this.windLevel>0){var o=.15*this.windLevel;i.position.add(new d.Cb(o,0,0))}i.position.add(i.velocity),i.velocity.multiplyScalar(.985);var a=9*t,s=new d.Cb(-.1,0,0).multiplyScalar(i.radius),l=new d.Cb(.1,0,0).multiplyScalar(i.radius),u=new d.Cb(.1,.15,0).multiplyScalar(i.radius);s.applyEuler(new d.n(i.rotx,i.roty,i.rotz)),l.applyEuler(new d.n(i.rotx,i.roty,i.rotz)),u.applyEuler(new d.n(i.rotx,i.roty,i.rotz)),this.particlesGeo.attributes.position.array[a+0]=s.x+r.x,this.particlesGeo.attributes.position.array[a+1]=s.y+r.y,this.particlesGeo.attributes.position.array[a+2]=s.z+r.z,this.particlesGeo.attributes.position.array[a+3]=l.x+r.x,this.particlesGeo.attributes.position.array[a+4]=l.y+r.y,this.particlesGeo.attributes.position.array[a+5]=l.z+r.z,this.particlesGeo.attributes.position.array[a+6]=u.x+r.x,this.particlesGeo.attributes.position.array[a+7]=u.y+r.y,this.particlesGeo.attributes.position.array[a+8]=u.z+r.z}this.particlesGeo.attributes.position.needsUpdate=!0}}]),e}(),P=function(){function e(n,t,i,r,o,a,s){Object(p.a)(this,e),this.rt0=new d.Fb(Math.floor(.25*t),Math.floor(.25*i),{type:d.r}),this.rt1=new d.Fb(Math.floor(.25*t),Math.floor(.25*i),{type:d.r}),this.torusesScene=r,this.torusesSceneCamera=o,this.blitProgram=s,this.torusesMaterial=new d.nb({vertexShader:"\n      varying vec3 vWorldPos;\n\n      void main() {\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);    \n        vWorldPos = (modelMatrix * vec4(position, 1.0)).xyz;\n      }\n      ",fragmentShader:"\n      varying vec3 vWorldPos;\n   \n      void main() {   \n        if(vWorldPos.y < -0.46) discard;\n\n        gl_FragColor = vec4(1.0);\n      }\n      "}),this.blurMaterial=new d.nb({uniforms:{uTexture:{type:"t",value:null},uHorizontal:{value:!1},uStep:{value:1},uPixelStep:{value:new d.Bb(1/t,1/i)}},vertexShader:"\n      varying vec2 vUv;\n\n      void main() {\n          vUv = uv;\n          gl_Position = vec4(position.xy, 0.0, 1.0);    \n      }\n      ",fragmentShader:"\n      uniform sampler2D uTexture;\n\n      uniform vec2 uPixelStep;\n      uniform bool uHorizontal;\n      uniform float uStep;\n\n      varying vec2 vUv;\n\n      float weight[5] = float[] (0.227027, 0.1945946, 0.1216216, 0.054054, 0.016216);\n\n      void main() {   \n          float blurRadius = 2.0 + uStep * 9.5;\n\n          vec3 accum = vec3(0.0);\n          for(int i = -4; i <= +4; i++) {\n              vec2 offs = vec2(0.0); \n\n              if(uHorizontal)  offs = vec2(uPixelStep.x * float(i) * blurRadius, 0.0);\n              if(!uHorizontal) offs = vec2(0.0, uPixelStep.x * float(i) * blurRadius);\n\n              vec3 value = texture2D(uTexture, vUv + offs).xyz;\n              \n              vec3 weightedValue = vec3(0.0);\n              if(i < 0) weightedValue = value * weight[abs(i)];\n              if(i > 0) weightedValue = value * weight[i];\n              if(i == 0) weightedValue = value * weight[0];\n\n              accum += weightedValue * 0.7;\n\n              vec3 value2 = texture2D(uTexture, vUv + offs * 0.2).xyz;\n              vec3 weightedValue2 = vec3(0.0);\n              if(i < 0) weightedValue2 = value2 * weight[abs(i)];\n              if(i > 0) weightedValue2 = value2 * weight[i];\n              if(i == 0) weightedValue2 = value2 * weight[0];\n              accum += weightedValue2 * 0.3;\n\n\n          }\n          \n          gl_FragColor = vec4(accum, 1.0);\n      }\n            ",depthTest:!1,depthWrite:!1}),this.fogMaterial=new d.nb({uniforms:{uColorTexture:{type:"t",value:null},uPositionTexture:{type:"t",value:a.texture},uTorusesBloom:{type:"t",value:null},uCameraPos:{value:new d.Cb(0,0,0)},uTime:{value:0},uWind:{value:0},uFogStartOffset:{value:0}},vertexShader:"\n      varying vec2 vUv;\n\n      void main() {\n          vUv = uv;\n          gl_Position = vec4(position.xy, 0.0, 1.0);    \n      }\n      ",fragmentShader:"\n      varying vec2 vUv;\n      \n      uniform sampler2D uColorTexture;\n      uniform sampler2D uTorusesBloom;\n      uniform sampler2D uPositionTexture;\n      // uniform sampler2D uFogMask;\n      \n      uniform vec3 uCameraPos;\n      uniform float uTime;\n      uniform float uWind;\n      uniform float uFogStartOffset;\n\n    /* discontinuous pseudorandom uniformly distributed in [-0.5, +0.5]^3 */\nvec3 random3(vec3 c) {\n\tfloat j = 4096.0*sin(dot(c,vec3(17.0, 59.4, 15.0)));\n\tvec3 r;\n\tr.z = fract(512.0*j);\n\tj *= .125;\n\tr.x = fract(512.0*j);\n\tj *= .125;\n\tr.y = fract(512.0*j);\n\treturn r-0.5;\n}\n\nconst float F3 =  0.3333333;\nconst float G3 =  0.1666667;\n\n/* 3d simplex noise */\nfloat simplex3d(vec3 p) {\n\t vec3 s = floor(p + dot(p, vec3(F3)));\n\t vec3 x = p - s + dot(s, vec3(G3));\n\t vec3 e = step(vec3(0.0), x - x.yzx);\n\t vec3 i1 = e*(1.0 - e.zxy);\n\t vec3 i2 = 1.0 - e.zxy*(1.0 - e);\n\t vec3 x1 = x - i1 + G3;\n\t vec3 x2 = x - i2 + 2.0*G3;\n\t vec3 x3 = x - 1.0 + 3.0*G3;\n\t vec4 w, d;\n\t w.x = dot(x, x);\n\t w.y = dot(x1, x1);\n\t w.z = dot(x2, x2);\n\t w.w = dot(x3, x3);\n\t w = max(0.6 - w, 0.0);\n\t d.x = dot(random3(s), x);\n\t d.y = dot(random3(s + i1), x1);\n\t d.z = dot(random3(s + i2), x2);\n\t d.w = dot(random3(s + 1.0), x3);\n\t w *= w;\n\t w *= w;\n\t d *= w;\n\t return dot(d, vec4(52.0));\n}\nconst mat3 rot1 = mat3(-0.37, 0.36, 0.85,-0.14,-0.93, 0.34,0.92, 0.01,0.4);\nconst mat3 rot2 = mat3(-0.55,-0.39, 0.74, 0.33,-0.91,-0.24,0.77, 0.12,0.63);\nconst mat3 rot3 = mat3(-0.71, 0.52,-0.47,-0.08,-0.72,-0.68,-0.7,-0.45,0.56);\nfloat simplex3d_fractal(vec3 m) {\n    return   0.5333333*simplex3d(m*rot1)\n\t\t\t+0.2666667*simplex3d(2.0*m*rot2)\n\t\t\t+0.1333333*simplex3d(4.0*m*rot3)\n\t\t\t+0.0666667*simplex3d(8.0*m);\n}\n\nvec3 hueShift( vec3 color, float hueAdjust ){\n  const vec3  kRGBToYPrime = vec3 (0.299, 0.587, 0.114);\n  const vec3  kRGBToI      = vec3 (0.596, -0.275, -0.321);\n  const vec3  kRGBToQ      = vec3 (0.212, -0.523, 0.311);\n  const vec3  kYIQToR     = vec3 (1.0, 0.956, 0.621);\n  const vec3  kYIQToG     = vec3 (1.0, -0.272, -0.647);\n  const vec3  kYIQToB     = vec3 (1.0, -1.107, 1.704);\n  float   YPrime  = dot (color, kRGBToYPrime);\n  float   I       = dot (color, kRGBToI);\n  float   Q       = dot (color, kRGBToQ);\n  float   hue     = atan (Q, I);\n  float   chroma  = sqrt (I * I + Q * Q);\n  hue += hueAdjust;\n  Q = chroma * sin (hue);\n  I = chroma * cos (hue);\n  vec3    yIQ   = vec3 (YPrime, I, Q);\n  return vec3( dot (yIQ, kYIQToR), dot (yIQ, kYIQToG), dot (yIQ, kYIQToB) );\n}\n\n      void main() {   \n        vec3 color = texture2D(uColorTexture, vUv).xyz;\n        vec3 torusesColor = texture2D(uTorusesBloom, vUv).xyz;\n        vec3 position = texture2D(uPositionTexture, vUv).xyz;\n        // float fogMask = 1.0 - texture2D(uFogMask, vUv).x;\n\n        if(position == vec3(0.0)) position = vec3(100.0);\n     \n        // float distFromCenter = length(position);\n        // if(distFromCenter > 3.5) {\n        //   float t = (distFromCenter - 3.5) / 2.0;\n        //   position += normalize(position - uCameraPos) * 20.0 * t;\n        // }\n\n        vec3 dir = normalize(uCameraPos - position);\n        float distance = length(uCameraPos - position);\n        float particles = 0.0;\n        int steps = 10;\n        float fogStart = 3.5 + uFogStartOffset;\n        vec3 rd = dir;\n        vec3 ro = uCameraPos + rd * fogStart;\n        if(distance > fogStart) {\n          float stepDistance = (distance - fogStart) / float(steps);\n          for(int i = 0; i < steps; i++) {\n            float dist = stepDistance * float(i);\n            vec3 p = ro + rd * (fogStart + dist);\n\n            float nv = (simplex3d_fractal(p * 0.16 + vec3(uTime * 0.1 + uWind, 0.0, 0.0)) + 0.25 );\n            nv = clamp(nv, 0.0, 1.0);\n            nv += dist * 0.01;\n\n            particles += nv * stepDistance * 18.0;\n          }\n        }\n\n        float fogFactor = 1.0 - exp(-particles * 0.1);\n        color = mix(color, vec3(1.0, 0.6, 0.4) * 0.25, fogFactor);\n        // color = mix(color, vec3(1.0, 0.7, 0.5) * 0.25, fogFactor);\n\n        torusesColor *= vec3(1.0, 0.3, 0.15) * 8.0;\n        torusesColor = ACESFilmicToneMapping(torusesColor);\n\n        float Talpha = torusesColor.x;\n        // Talpha *= fogMask;\n\n        // vec3 finalColor = mix(color, torusesColor, Talpha) * 0.5 + (color + torusesColor) * 0.5;\n        // vec3 finalColor = hueShift(color, -0.05) + torusesColor * 0.75;\n        vec3 finalColor = color + torusesColor * 0.5;\n\n        gl_FragColor = vec4(finalColor, 1.0);\n      }\n      ",depthTest:!1,depthWrite:!1}),this.blackMaterial=new d.O({color:0}),this.mesh=new d.N(new d.ab(2,2),this.blurMaterial),this.camera=new d.Z(45,1,1,1e3),this.renderer=n,this.scene=new d.lb,this.scene.add(this.mesh),this.clock=new d.i,this.clock.start()}return Object(y.a)(e,[{key:"setWindLevel",value:function(e,n){this.fogMaterial.uniforms.uWind.value+=e,this.fogMaterial.uniforms.uFogStartOffset.value=-1*n}},{key:"compute",value:function(e,n){this.renderer.setRenderTarget(this.rt1),this.torusesScene.overrideMaterial=this.torusesMaterial,this.renderer.render(this.torusesScene,this.torusesSceneCamera),this.torusesScene.overrideMaterial=null,this.mesh.material=this.blurMaterial;for(var t=0;t<7;t++)this.blurMaterial.uniforms.uStep.value=t,t>5&&(this.blurMaterial.uniforms.uStep.value=1),this.renderer.setRenderTarget(this.rt0),this.blurMaterial.uniforms.uHorizontal.value=!0,this.blurMaterial.uniforms.uTexture.value=this.rt1.texture,this.renderer.render(this.scene,this.camera),this.renderer.setRenderTarget(this.rt1),this.blurMaterial.uniforms.uHorizontal.value=!1,this.blurMaterial.uniforms.uTexture.value=this.rt0.texture,this.renderer.render(this.scene,this.camera);this.fogMaterial.uniforms.uColorTexture.value=e,this.fogMaterial.uniforms.uTorusesBloom.value=this.rt1.texture,this.fogMaterial.uniforms.uCameraPos.value=this.torusesSceneCamera.position.clone(),this.fogMaterial.uniforms.uTime.value=this.clock.getElapsedTime(),this.mesh.material=this.fogMaterial,this.renderer.setRenderTarget(n),this.renderer.render(this.scene,this.camera),this.renderer.setRenderTarget(null)}}]),e}(),D=function(){function e(){Object(p.a)(this,e),this.geo=new d.g,this.clock=new d.i,this.clock.start();var n=new d.O({color:new d.j("#FF5624").multiplyScalar(2.5),side:d.m,toneMapped:!1});this.geo.setAttribute("position",new d.f(new Float32Array([]),3)),this.mesh=new d.N(this.geo,n)}return Object(y.a)(e,[{key:"createCrystal",value:function(e,n){var t=arguments.length>2&&void 0!==arguments[2]?arguments[2]:new d.Cb(0,0,0),i=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1,r=arguments.length>4?arguments[4]:void 0,o=1.7*n;e-=2*o;var a=new d.Cb(0,-o-.5*e,0),s=new d.Cb(-n,.5*-e,-n),l=new d.Cb(-n,.5*-e,+n),u=new d.Cb(+n,.5*-e,+n),c=new d.Cb(+n,.5*-e,-n),v=s.clone().add(new d.Cb(0,e,0)),m=l.clone().add(new d.Cb(0,e,0)),f=u.clone().add(new d.Cb(0,e,0)),x=c.clone().add(new d.Cb(0,e,0)),h=new d.Cb(0,+o+.5*e,0),p=[a,s,l,u,c,v,m,f,x,h];p.forEach((function(e){return e.multiplyScalar(i).add(t)})),r.push(a.x,a.y,a.z,s.x,s.y,s.z,l.x,l.y,l.z,a.x,a.y,a.z,l.x,l.y,l.z,u.x,u.y,u.z,a.x,a.y,a.z,u.x,u.y,u.z,c.x,c.y,c.z,a.x,a.y,a.z,c.x,c.y,c.z,s.x,s.y,s.z,s.x,s.y,s.z,l.x,l.y,l.z,v.x,v.y,v.z,l.x,l.y,l.z,v.x,v.y,v.z,m.x,m.y,m.z,l.x,l.y,l.z,u.x,u.y,u.z,m.x,m.y,m.z,u.x,u.y,u.z,m.x,m.y,m.z,f.x,f.y,f.z,u.x,u.y,u.z,c.x,c.y,c.z,f.x,f.y,f.z,c.x,c.y,c.z,f.x,f.y,f.z,x.x,x.y,x.z,s.x,s.y,s.z,v.x,v.y,v.z,x.x,x.y,x.z,s.x,s.y,s.z,c.x,c.y,c.z,x.x,x.y,x.z,h.x,h.y,h.z,v.x,v.y,v.z,m.x,m.y,m.z,h.x,h.y,h.z,m.x,m.y,m.z,f.x,f.y,f.z,h.x,h.y,h.z,f.x,f.y,f.z,x.x,x.y,x.z,h.x,h.y,h.z,x.x,x.y,x.z,v.x,v.y,v.z)}},{key:"createPartialCrystal",value:function(e,n){var t=arguments.length>2&&void 0!==arguments[2]?arguments[2]:new d.Cb(0,0,0),i=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1,r=arguments.length>4&&void 0!==arguments[4]?arguments[4]:1,o=arguments.length>5?arguments[5]:void 0,a=r*e,s=1.7*n;e-=2*s;var l=new d.Cb(0,-s-.5*e,0),u=new d.Cb(-n,.5*-e,-n),c=new d.Cb(-n,.5*-e,+n),v=new d.Cb(+n,.5*-e,+n),m=new d.Cb(+n,.5*-e,-n),f=u.clone().add(new d.Cb(0,e,0)),x=c.clone().add(new d.Cb(0,e,0)),h=v.clone().add(new d.Cb(0,e,0)),p=m.clone().add(new d.Cb(0,e,0)),y=new d.Cb(0,+s+.5*e,0),g=[l,u,c,v,m,f,x,h,p,y];if(!(a<=0))if(a<=s){var w=a/s;u.add(new d.Cb(0,.5*e+s)).multiplyScalar(w).add(new d.Cb(0,.5*-e-s,0)),c.add(new d.Cb(0,.5*e+s)).multiplyScalar(w).add(new d.Cb(0,.5*-e-s,0)),v.add(new d.Cb(0,.5*e+s)).multiplyScalar(w).add(new d.Cb(0,.5*-e-s,0)),m.add(new d.Cb(0,.5*e+s)).multiplyScalar(w).add(new d.Cb(0,.5*-e-s,0)),g.forEach((function(e){return e.multiplyScalar(i).add(t)})),o.push(l.x,l.y,l.z,u.x,u.y,u.z,c.x,c.y,c.z,l.x,l.y,l.z,c.x,c.y,c.z,v.x,v.y,v.z,l.x,l.y,l.z,v.x,v.y,v.z,m.x,m.y,m.z,l.x,l.y,l.z,m.x,m.y,m.z,u.x,u.y,u.z)}else if(a>s&&a<s+e){var b=(a-s)/e,z=e*(1-b);f.add(new d.Cb(0,-z,0)),x.add(new d.Cb(0,-z,0)),h.add(new d.Cb(0,-z,0)),p.add(new d.Cb(0,-z,0)),g.forEach((function(e){return e.multiplyScalar(i).add(t)})),o.push(l.x,l.y,l.z,u.x,u.y,u.z,c.x,c.y,c.z,l.x,l.y,l.z,c.x,c.y,c.z,v.x,v.y,v.z,l.x,l.y,l.z,v.x,v.y,v.z,m.x,m.y,m.z,l.x,l.y,l.z,m.x,m.y,m.z,u.x,u.y,u.z,u.x,u.y,u.z,c.x,c.y,c.z,f.x,f.y,f.z,c.x,c.y,c.z,f.x,f.y,f.z,x.x,x.y,x.z,c.x,c.y,c.z,v.x,v.y,v.z,x.x,x.y,x.z,v.x,v.y,v.z,x.x,x.y,x.z,h.x,h.y,h.z,v.x,v.y,v.z,m.x,m.y,m.z,h.x,h.y,h.z,m.x,m.y,m.z,h.x,h.y,h.z,p.x,p.y,p.z,u.x,u.y,u.z,f.x,f.y,f.z,p.x,p.y,p.z,u.x,u.y,u.z,m.x,m.y,m.z,p.x,p.y,p.z)}else if(a>=s+e&&a<2*s+e){var S=1-(a-(s+e))/s,T=f.clone().add(new d.Cb(0,.5*-e+s)).multiply(new d.Cb(S,1-S,S)).add(new d.Cb(0,.5*e,0)),C=x.clone().add(new d.Cb(0,.5*-e+s)).multiply(new d.Cb(S,1-S,S)).add(new d.Cb(0,.5*e,0)),P=h.clone().add(new d.Cb(0,.5*-e+s)).multiply(new d.Cb(S,1-S,S)).add(new d.Cb(0,.5*e,0)),D=p.clone().add(new d.Cb(0,.5*-e+s)).multiply(new d.Cb(S,1-S,S)).add(new d.Cb(0,.5*e,0));g.push(T,C,P,D),g.forEach((function(e){return e.multiplyScalar(i).add(t)})),o.push(l.x,l.y,l.z,u.x,u.y,u.z,c.x,c.y,c.z,l.x,l.y,l.z,c.x,c.y,c.z,v.x,v.y,v.z,l.x,l.y,l.z,v.x,v.y,v.z,m.x,m.y,m.z,l.x,l.y,l.z,m.x,m.y,m.z,u.x,u.y,u.z,u.x,u.y,u.z,c.x,c.y,c.z,f.x,f.y,f.z,c.x,c.y,c.z,f.x,f.y,f.z,x.x,x.y,x.z,c.x,c.y,c.z,v.x,v.y,v.z,x.x,x.y,x.z,v.x,v.y,v.z,x.x,x.y,x.z,h.x,h.y,h.z,v.x,v.y,v.z,m.x,m.y,m.z,h.x,h.y,h.z,m.x,m.y,m.z,h.x,h.y,h.z,p.x,p.y,p.z,u.x,u.y,u.z,f.x,f.y,f.z,p.x,p.y,p.z,u.x,u.y,u.z,m.x,m.y,m.z,p.x,p.y,p.z,f.x,f.y,f.z,x.x,x.y,x.z,T.x,T.y,T.z,x.x,x.y,x.z,T.x,T.y,T.z,C.x,C.y,C.z,x.x,x.y,x.z,h.x,h.y,h.z,C.x,C.y,C.z,h.x,h.y,h.z,C.x,C.y,C.z,P.x,P.y,P.z,h.x,h.y,h.z,p.x,p.y,p.z,P.x,P.y,P.z,p.x,p.y,p.z,P.x,P.y,P.z,D.x,D.y,D.z,f.x,f.y,f.z,T.x,T.y,T.z,D.x,D.y,D.z,f.x,f.y,f.z,p.x,p.y,p.z,D.x,D.y,D.z)}else a>=2*s+e&&(g.forEach((function(e){return e.multiplyScalar(i).add(t)})),o.push(l.x,l.y,l.z,u.x,u.y,u.z,c.x,c.y,c.z,l.x,l.y,l.z,c.x,c.y,c.z,v.x,v.y,v.z,l.x,l.y,l.z,v.x,v.y,v.z,m.x,m.y,m.z,l.x,l.y,l.z,m.x,m.y,m.z,u.x,u.y,u.z,u.x,u.y,u.z,c.x,c.y,c.z,f.x,f.y,f.z,c.x,c.y,c.z,f.x,f.y,f.z,x.x,x.y,x.z,c.x,c.y,c.z,v.x,v.y,v.z,x.x,x.y,x.z,v.x,v.y,v.z,x.x,x.y,x.z,h.x,h.y,h.z,v.x,v.y,v.z,m.x,m.y,m.z,h.x,h.y,h.z,m.x,m.y,m.z,h.x,h.y,h.z,p.x,p.y,p.z,u.x,u.y,u.z,f.x,f.y,f.z,p.x,p.y,p.z,u.x,u.y,u.z,m.x,m.y,m.z,p.x,p.y,p.z,y.x,y.y,y.z,f.x,f.y,f.z,x.x,x.y,x.z,y.x,y.y,y.z,x.x,x.y,x.z,h.x,h.y,h.z,y.x,y.y,y.z,h.x,h.y,h.z,p.x,p.y,p.z,y.x,y.y,y.z,p.x,p.y,p.z,f.x,f.y,f.z))}},{key:"update",value:function(e){this.clock.getDelta();for(var n=this.clock.getElapsedTime(),t=new d.Cb(.71,-.13,-.05),i=[],r=0;r<18;r++){var o=.1*n,a=.35*Math.sin(r/18*Math.PI*2-1.15+o),s=.35*Math.cos(r/18*Math.PI*2-1.15+o),l=t.clone().add(new d.Cb(a,0,s)),u=2*r,c=1.5*n,v=Object(h.b)(Object(h.a)(e,0,1),0,1);l.add(new d.Cb(0,.05*Math.sin(r+n)*Math.cos(n),0)),this.createPartialCrystal(.15*(1+.3*Math.sin(u+1.25*Math.PI+c)),.0075,l,v,1,i)}this.geo.setAttribute("position",new d.f(new Float32Array(i),3))}}]),e}(),R={SIM_RESOLUTION:256,DYE_RESOLUTION:1024,CAPTURE_RESOLUTION:512,DENSITY_DISSIPATION:.6,VELOCITY_DISSIPATION:.2,PRESSURE:1,PRESSURE_ITERATIONS:20,CURL:25,SPLAT_RADIUS:.25,SPLAT_FORCE:6e3,SHADING:!1,COLORFUL:!0,COLOR_UPDATE_SPEED:10,PAUSED:!1,BACK_COLOR:{r:0,g:0,b:0},TRANSPARENT:!1};function M(){this.id=-1,this.texcoordX=0,this.texcoordY=0,this.prevTexcoordX=0,this.prevTexcoordY=0,this.deltaX=0,this.deltaY=0,this.down=!1,this.moved=!1,this.color=[300,200,200]}var F,O,U,A,I=[];I.push(new M);var _,L,E,B,j,V,k,N,G,Y,W,H,X,Q,Z={dye:null,velocity:null};function q(e,n,t){t&&(R=t),F=n,A=e,O=new d.lb,U=new d.Z(45,F.width/F.height,.1,10),function(){var e=J(R.SIM_RESOLUTION),n=J(R.DYE_RESOLUTION);if(null!=_)throw new Error("not implemented");_=$(n.width,n.height,d.E);if(null!=L)throw new Error("not implemented");L=$(e.width,e.height,d.E);E=K(e.width,e.height,d.S),B=K(e.width,e.height,d.S),j=$(e.width,e.height,d.S),Z.dye=_,Z.velocity=L}(),function(){new d.nb({uniforms:{uTexture:{type:"t",value:L.read.texture}},vertexShader:de,fragmentShader:me}),V=new d.nb({uniforms:{uTarget:{type:"t",value:L.read.texture},aspectRatio:{value:F.width/F.height},point:{value:new d.Bb(0,0)},color:{value:new d.Cb(0,0,0)},radius:{value:ie(R.SPLAT_RADIUS/100)}},vertexShader:de,fragmentShader:he}),k=new d.nb({uniforms:{texelSize:{value:new d.Bb(L.texelSizeX,L.texelSizeY)},uVelocity:{type:"t",value:L.read.texture}},vertexShader:de,fragmentShader:ge}),N=new d.nb({uniforms:{texelSize:{value:new d.Bb(L.texelSizeX,L.texelSizeY)},uVelocity:{type:"t",value:L.read.texture},uCurl:{type:"t",value:B.texture},curl:{value:R.CURL},dt:{value:0}},vertexShader:de,fragmentShader:we}),G=new d.nb({uniforms:{texelSize:{value:new d.Bb(L.texelSizeX,L.texelSizeY)},uVelocity:{type:"t",value:L.read.texture}},vertexShader:de,fragmentShader:ye}),Y=new d.nb({uniforms:{uTexture:{type:"t",value:j.read.texture},value:{value:R.PRESSURE}},vertexShader:de,fragmentShader:fe}),W=new d.nb({uniforms:{texelSize:{value:new d.Bb(L.texelSizeX,L.texelSizeY)},uDivergence:{type:"t",value:E.texture},uPressure:{type:"t",value:j.read.texture}},vertexShader:de,fragmentShader:be}),H=new d.nb({uniforms:{texelSize:{value:new d.Bb(L.texelSizeX,L.texelSizeY)},uPressure:{type:"t",value:j.read.texture},uVelocity:{type:"t",value:L.read.texture}},vertexShader:de,fragmentShader:ze}),X=new d.nb({uniforms:{texelSize:{value:new d.Bb(L.texelSizeX,L.texelSizeY)},uVelocity:{type:"t",value:L.read.texture},uSource:{type:"t",value:L.read.texture},dt:{value:0},dissipation:{value:R.VELOCITY_DISSIPATION}},vertexShader:de,fragmentShader:pe}),new d.nb({uniforms:{texelSize:{value:new d.Bb(L.texelSizeX,L.texelSizeY)},uVelocity:{type:"t",value:L.read.texture},uTexture:{type:"t",value:_.read.texture},uPressure:{type:"t",value:j.read.texture},uCurl:{type:"t",value:B.texture}},vertexShader:de,fragmentShader:xe});var e=new d.ab(2,2);Q=new d.N(e,k),O.add(Q)}()}function J(e){var n=F.width/F.height;n<1&&(n=1/n);var t=Math.round(e),i=Math.round(e*n);return F.width>F.height?{width:i,height:t}:{width:t,height:i}}function K(e,n,t){var i=new d.Fb(e,n,{type:d.r,minFilter:t,magFilter:t,format:d.hb,depthBuffer:!1,stencilBuffer:!1,anisotropy:1}),r=1/e,o=1/n;return{texture:i.texture,fbo:i,width:e,height:n,texelSizeX:r,texelSizeY:o}}function $(e,n,t){var i=K(e,n,t),r=K(e,n,t);return{width:e,height:n,texelSizeX:i.texelSizeX,texelSizeY:i.texelSizeY,get read(){return i},set read(e){i=e},get write(){return r},set write(e){r=e},swap:function(){var e=i;i=r,r=e}}}function ee(){var e=function(){var e=Date.now(),n=(e-ne)/1e3;return n=Math.min(n,.016666),ne=e,n}();!function(e){if(!R.COLORFUL)return;ce=(ce+=e*R.COLOR_UPDATE_SPEED*.03)%360,ue=function(e,n,t){var i=t-n;return 0==i?n:(e-n)%i+n}(ue+=e*R.COLOR_UPDATE_SPEED,0,1),I.forEach((function(e){e.color=ve(ce)}))}(e),I.forEach((function(e){e.moved&&(e.moved=!1,function(e){var n=e.deltaX*R.SPLAT_FORCE,t=e.deltaY*R.SPLAT_FORCE;te(e.texcoordX,e.texcoordY,n,t,e.color,e)}(e))})),function(e){Q.material=k,k.uniforms.uVelocity.value=L.read.texture,A.setRenderTarget(B.fbo),A.render(O,U),Q.material=N,N.uniforms.uVelocity.value=L.read.texture,N.uniforms.uCurl.value=B.texture,N.uniforms.curl.value=R.CURL,N.uniforms.dt.value=e,A.setRenderTarget(L.write.fbo),A.render(O,U),L.swap(),Q.material=G,G.uniforms.uVelocity.value=L.read.texture,A.setRenderTarget(E.fbo),A.render(O,U),Q.material=Y,Y.uniforms.uTexture.value=j.read.texture,Y.uniforms.value.value=R.PRESSURE,A.setRenderTarget(j.write.fbo),A.render(O,U),Q.material=W,W.uniforms.uDivergence.value=E.texture;for(var n=0;n<R.PRESSURE_ITERATIONS;n++)W.uniforms.uPressure.value=j.read.texture,A.setRenderTarget(j.write.fbo),A.render(O,U),j.swap();Q.material=H,H.uniforms.uPressure.value=j.read.texture,H.uniforms.uVelocity.value=L.read.texture,A.setRenderTarget(L.write.fbo),A.render(O,U),L.swap(),Q.material=X,X.uniforms.uVelocity.value=L.read.texture,X.uniforms.uSource.value=L.read.texture,X.uniforms.dt.value=e,X.uniforms.dissipation.value=R.VELOCITY_DISSIPATION,A.setRenderTarget(L.write.fbo),A.render(O,U),L.swap(),Q.material=X,X.uniforms.uVelocity.value=L.read.texture,X.uniforms.uSource.value=_.read.texture,X.uniforms.dt.value=e,X.uniforms.dissipation.value=R.DENSITY_DISSIPATION,A.setRenderTarget(_.write.fbo),A.render(O,U),_.swap(),A.setRenderTarget(null)}(e)}var ne=Date.now();function te(e,n,t,i,r,o,a){a||(a=1),Q.material=V,V.uniforms.uTarget.value=L.read.texture,V.uniforms.aspectRatio.value=F.width/F.height,V.uniforms.point.value=new d.Bb(e,n),V.uniforms.color.value=new d.Cb(t,i,0),V.uniforms.radius.value=ie(R.SPLAT_RADIUS/100),A.setRenderTarget(L.write.fbo),A.render(O,U),L.swap(),o.downMiddle||(V.uniforms.uTarget.value=_.read.texture,V.uniforms.color.value=new d.Cb(1,1,1).multiplyScalar(.2),A.setRenderTarget(_.write.fbo),A.render(O,U),_.swap())}function ie(e){var n=F.width/F.height;return n>1&&(e*=n),e}var re=new d.jb;function oe(e,n){window.addEventListener("mousedown",(function(e){var n=ae(e.clientX),t=ae(e.clientY),i=I.find((function(e){return-1==e.id}));null==i&&(i=new M),se(i,-1,n,t,3==e.which,2==e.which)})),window.addEventListener("touchstart",(function(e){var n=ae(e.touches[0].clientX),t=ae(e.touches[0].clientY),i=I.find((function(e){return-1==e.id}));null==i&&(i=new M),se(i,-1,n,t,3==e.which,2==e.which)})),window.addEventListener("mousemove",(function(t){var i=I[0],r=new d.Bb(t.clientX/window.innerWidth*2-1,-t.clientY/window.innerHeight*2+1);re.setFromCamera(r,e);var o=re.intersectObjects(n.children);if(o[0]){var a=o[0].point.clone().sub(new d.Cb(.71,-.13,-.05)).multiplyScalar(.75);a.x>1&&(a.x=1),a.x<-1&&(a.x=-1),a.y>1&&(a.y=1),a.y<-1&&(a.y=-1);var s=a.clone().multiplyScalar(.5).addScalar(.5);le(i,s.x,s.z)}})),window.addEventListener("touchmove",(function(e){le(I[0],ae(e.touches[0].clientX),ae(e.touches[0].clientY))})),window.addEventListener("mouseup",(function(){I[0].down=!1}))}function ae(e){var n=window.devicePixelRatio||1;return Math.floor(e*n)}function se(e,n,t,i,r,o){e.id=n,e.down=!0,e.downRight=r,e.downMiddle=o,e.moved=!1,e.texcoordX=t/F.width,e.texcoordY=1-i/F.height,e.prevTexcoordX=e.texcoordX,e.prevTexcoordY=e.texcoordY,e.deltaX=0,e.deltaY=0,e.color=ve(ce)}function le(e,n,t){e.prevTexcoordX=e.texcoordX,e.prevTexcoordY=e.texcoordY,e.texcoordX=n,e.texcoordY=t,e.deltaX=function(e){var n=F.width/F.height;n<1&&(e*=n);return e}(e.texcoordX-e.prevTexcoordX),e.deltaY=function(e){var n=F.width/F.height;n>1&&(e/=n);return e}(e.texcoordY-e.prevTexcoordY),e.moved=Math.abs(e.deltaX)>0||Math.abs(e.deltaY)>0}var ue=0,ce=0;function ve(e){var n=function(e,n,t){var i,r,o,a,s,l,u,c;switch(a=Math.floor(6*e),l=t*(1-n),u=t*(1-(s=6*e-a)*n),c=t*(1-(1-s)*n),a%6){case 0:i=t,r=c,o=l;break;case 1:i=u,r=t,o=l;break;case 2:i=l,r=t,o=c;break;case 3:i=l,r=u,o=t;break;case 4:i=c,r=l,o=t;break;case 5:i=t,r=l,o=u}return{r:i,g:r,b:o}}(e||Math.random(),1,1);return n.r*=.15,n.g*=.15,n.b*=.15,n}var de="\n    varying vec2 vUv;\n    varying vec2 vL;\n    varying vec2 vR;\n    varying vec2 vT;\n    varying vec2 vB;\n    uniform vec2 texelSize;\n    \n    void main () {\n        vUv = position.xy * 0.5 + 0.5;\n        vL = vUv - vec2(texelSize.x, 0.0);\n        vR = vUv + vec2(texelSize.x, 0.0);\n        vT = vUv + vec2(0.0, texelSize.y);\n        vB = vUv - vec2(0.0, texelSize.y);\n        gl_Position = vec4(position.xy, 0.0, 1.0);\n    }\n    ",me="\n    varying highp vec2 vUv;\n    uniform sampler2D uTexture;\n    \n    void main () {\n        gl_FragColor = texture2D(uTexture, vUv);\n    }\n    ",fe="\n    varying highp vec2 vUv;\n    uniform sampler2D uTexture;\n    uniform float value;\n    \n    void main () {\n        gl_FragColor = value * texture2D(uTexture, vUv);\n    }\n    ",xe="\n    varying vec2 vUv;\n    varying vec2 vL;\n    varying vec2 vR;\n    varying vec2 vT;\n    varying vec2 vB;\n    uniform sampler2D uTexture;\n    uniform sampler2D uBloom;\n    uniform sampler2D uSunrays;\n    uniform sampler2D uDithering;\n    uniform sampler2D uVelocity;\n    uniform sampler2D uPressure;\n    uniform sampler2D uCurl;\n    uniform vec2 ditherScale;\n    uniform vec2 texelSize;\n    \n    vec3 linearToGamma (vec3 color) {\n        color = max(color, vec3(0));\n        return max(1.055 * pow(color, vec3(0.416666667)) - 0.055, vec3(0));\n    }\n    \n    vec3 acesFilm(const vec3 x) {\n        const float a = 2.51;\n        const float b = 0.03;\n        const float c = 2.43;\n        const float d = 0.59;\n        const float e = 0.14;\n        return clamp((x * (a * x + b)) / (x * (c * x + d ) + e), 0.0, 1.0);\n    }\n    \n    \n    void main () {\n        vec3 c = texture2D(uTexture, vUv).rgb;\n    \n    \n        float a = max(c.r, max(c.g, c.b));\n        gl_FragColor = vec4(c, a);\n        // return;  // uncomment to see the base version of the shader\n    \n    \n        vec3 vdata = ((texture2D(uVelocity, vUv).rgb)   * 0.5 + 0.5)  * 0.007;\n        vec3 pdata = vec3(0.0, 0.0, texture2D(uPressure, vUv).r * 0.01);\n        float cdata = texture2D(uCurl, vUv).r * 0.01;\n        vec3 finalVelocityColor = vec3(0.6) + vdata * (1.0 + cdata);\n        gl_FragColor = vec4(finalVelocityColor, 1.0);\n        // return;  // uncomment to see the velocity version of the shader\n    \n    \n        // // mixed version of the shader\n        // gl_FragColor = vec4(c, a) * gl_FragColor * 2.0 + gl_FragColor * 0.25;\n        \n    \n        float x = 0.6 + vdata.x;\n        float y = 0.6 + vdata.y;\n        float z = 0.6 + vdata.z;\n        if(x < 0.0) x = 0.0;\n        if(y < 0.0) y = 0.0;\n        if(z < 0.0) z = 0.0;\n        vec3 vcol = vec3(x,y,z);\n        vec3 dcol = vec4(c, a).rgb;\n        vec3 fcol = dcol + vcol * 0.25;\n        if(fcol.r < 0.0) fcol.r = 0.0;\n        if(fcol.g < 0.0) fcol.g = 0.0;\n        if(fcol.b < 0.0) fcol.b = 0.0;\n    \n        gl_FragColor.rgb = acesFilm(fcol);\n    }\n    ",he="\n    varying vec2 vUv;\n    uniform sampler2D uTarget;\n    uniform float aspectRatio;\n    uniform vec3 color;\n    uniform vec2 point;\n    uniform float radius;\n    \n    void main () {\n        vec2 p = vUv - point.xy;\n        p.x *= aspectRatio;\n        vec3 splat = exp(-dot(p, p) / radius) * color;\n        vec3 base = texture2D(uTarget, vUv).xyz;\n        gl_FragColor = vec4(base + splat, 1.0);\n    }\n    ",pe="\n    varying vec2 vUv;\n    uniform sampler2D uVelocity;\n    uniform sampler2D uSource;\n    uniform vec2 texelSize;\n    uniform vec2 dyeTexelSize;\n    uniform float dt;\n    uniform float dissipation;\n    \n    void main () {\n        vec2 coord = vUv - dt * texture2D(uVelocity, vUv).xy * texelSize;\n        vec4 result = texture2D(uSource, coord);\n    \n        float decay = 1.0 + dissipation * dt;\n        gl_FragColor = result / decay;\n    }",ye="\n    varying highp vec2 vUv;\n    varying highp vec2 vL;\n    varying highp vec2 vR;\n    varying highp vec2 vT;\n    varying highp vec2 vB;\n    uniform sampler2D uVelocity;\n    \n    void main () {\n        float L = texture2D(uVelocity, vL).x;\n        float R = texture2D(uVelocity, vR).x;\n        float T = texture2D(uVelocity, vT).y;\n        float B = texture2D(uVelocity, vB).y;\n    \n        vec2 C = texture2D(uVelocity, vUv).xy;\n        if (vL.x < 0.0) { L = -C.x; }\n        if (vR.x > 1.0) { R = -C.x; }\n        if (vT.y > 1.0) { T = -C.y; }\n        if (vB.y < 0.0) { B = -C.y; }\n    \n        float div = 0.5 * (R - L + T - B);\n        gl_FragColor = vec4(div, 0.0, 0.0, 1.0);\n    }\n    ",ge="\n    varying highp vec2 vUv;\n    varying highp vec2 vL;\n    varying highp vec2 vR;\n    varying highp vec2 vT;\n    varying highp vec2 vB;\n    uniform sampler2D uVelocity;\n    \n    void main () {\n        float L = texture2D(uVelocity, vL).y;\n        float R = texture2D(uVelocity, vR).y;\n        float T = texture2D(uVelocity, vT).x;\n        float B = texture2D(uVelocity, vB).x;\n        float vorticity = R - L - T + B;\n        gl_FragColor = vec4(0.5 * vorticity, 0.0, 0.0, 1.0);\n    }\n    ",we="\n    varying vec2 vUv;\n    varying vec2 vL;\n    varying vec2 vR;\n    varying vec2 vT;\n    varying vec2 vB;\n    uniform sampler2D uVelocity;\n    uniform sampler2D uCurl;\n    uniform float curl;\n    uniform float dt;\n    \n    void main () {\n        float L = texture2D(uCurl, vL).x;\n        float R = texture2D(uCurl, vR).x;\n        float T = texture2D(uCurl, vT).x;\n        float B = texture2D(uCurl, vB).x;\n        float C = texture2D(uCurl, vUv).x;\n    \n        vec2 force = 0.5 * vec2(abs(T) - abs(B), abs(R) - abs(L));\n        force /= length(force) + 0.0001;\n        force *= curl * C;\n        force.y *= -1.0;\n    \n        vec2 vel = texture2D(uVelocity, vUv).xy;\n        gl_FragColor = vec4(vel + force * dt, 0.0, 1.0);\n    }\n    ",be="\n    varying highp vec2 vUv;\n    varying highp vec2 vL;\n    varying highp vec2 vR;\n    varying highp vec2 vT;\n    varying highp vec2 vB;\n    uniform sampler2D uPressure;\n    uniform sampler2D uDivergence;\n    \n    void main () {\n        float L = texture2D(uPressure, vL).x;\n        float R = texture2D(uPressure, vR).x;\n        float T = texture2D(uPressure, vT).x;\n        float B = texture2D(uPressure, vB).x;\n        float C = texture2D(uPressure, vUv).x;\n        float divergence = texture2D(uDivergence, vUv).x;\n        float pressure = (L + R + B + T - divergence) * 0.25;\n        gl_FragColor = vec4(pressure, 0.0, 0.0, 1.0);\n    }\n    ",ze="\n    varying highp vec2 vUv;\n    varying highp vec2 vL;\n    varying highp vec2 vR;\n    varying highp vec2 vT;\n    varying highp vec2 vB;\n    uniform sampler2D uPressure;\n    uniform sampler2D uVelocity;\n    \n    void main () {\n        float L = texture2D(uPressure, vL).x;\n        float R = texture2D(uPressure, vR).x;\n        float T = texture2D(uPressure, vT).x;\n        float B = texture2D(uPressure, vB).x;\n        vec2 velocity = texture2D(uVelocity, vUv).xy;\n        velocity.xy -= vec2(R - L, T - B);\n        gl_FragColor = vec4(velocity, 0.0, 1.0);\n    }\n    ";t(15);function Se(e){return e[e.length-1]}function Te(e){return e.replace(/#include <(.*)>/gm,(function(e,n){return Te(d.mb[n])}))}var Ce={};function Pe(e){return!Ce[e]&&(Ce[e]=!0,!0)}function De(e,n,t){var i=new d.jb,r=new d.lb,o=new d.rb(.32,6,6),a=new d.N(o,new d.O({color:16777215,side:d.m}));a.position.set(.71,-.13,-.05),a.updateMatrixWorld(),r.add(a);var s,l=!1;window.addEventListener("mousedown",(function(e){s=new d.Bb(e.clientX/window.innerWidth*2-1,-e.clientY/window.innerHeight*2+1),v.classList.add("active"),m.classList.add("active")})),window.addEventListener("mouseup",(function(e){var n=new d.Bb(e.clientX/window.innerWidth*2-1,-e.clientY/window.innerHeight*2+1);s.clone().sub(n).length()<.01&&t(l),v.classList.remove("active"),m.classList.remove("active")}));var u=new d.Bb(.5*window.innerWidth,.75*window.innerHeight),c=new d.Bb(.5*window.innerWidth,.75*window.innerHeight);window.addEventListener("mousemove",(function(e){var t=new d.Bb(e.clientX/window.innerWidth*2-1,-e.clientY/window.innerHeight*2+1);i.setFromCamera(t,n),c.setX(e.clientX),c.setY(e.clientY),i.intersectObjects(r.children)[0]?(Pe("hide-mouse-icon")&&setTimeout((function(){f.classList.add("hide"),setTimeout((function(){f.style.display="none"}),500)}),250),l=!0,m.classList.contains("hover")||m.classList.add("hover")):(l=!1,m.classList.contains("hover")&&m.classList.remove("hover"))}));var v=document.querySelector(".central-cursor"),m=document.querySelector(".outer-cursor"),f=document.querySelector(".mouse-icon"),x=v.getBoundingClientRect(),h=m.getBoundingClientRect(),p=f.getBoundingClientRect();return{update:function(e){u.multiplyScalar(.8).add(c.clone().multiplyScalar(1-.8)),v.style.left="".concat(c.x-.5*x.width,"px"),v.style.top="".concat(c.y-.5*x.height,"px"),m.style.left="".concat(u.x-.5*h.width,"px"),m.style.top="".concat(u.y-.5*h.height,"px");var t=new d.Cb(.87,0,-.15).project(n);t.multiplyScalar(.5).addScalar(.5).multiply(new d.Cb(window.innerWidth,window.innerHeight,0)),f.style.left="".concat(t.x-.5*p.width,"px"),f.style.top="".concat(window.innerHeight-(t.y-.5*p.height),"px")}}}var Re="\nfloat sat( float t ) {\n\treturn clamp( t, 0.0, 1.0 );\n}\n\nvec2 sat( vec2 t ) {\n\treturn clamp( t, 0.0, 1.0 );\n}",Me="\n//remaps inteval [a;b] to [0;1]\nfloat remap ( float t, float a, float b ) {\n\treturn sat( (t - a) / (b - a) );\n}",Fe="\n//note: / t=[0; 0.5; 1], y=[0; 1; 0]\nfloat linterp( float t ) {\n\treturn sat( 1.0 - abs( 2.0*t - 1.0 ) );\n}\n",Oe="\n// given t = [0, 1] \n// if t < 0.5    lo = 0 & hi = 1  else  lo = 1 && hi = 0\n// 'w' will take the form:  [0, 1, 0] and 'neg_w' = [1, 0, 1]\nvec3 spectrum_offset( float t ) {\n\tvec3 ret;\n    // remember that t is the edge, not 0.5... so it's a bit confusing since normally you'd expect\n    // for this call to be written as: step(0.5 /* edge */, t /* x */) as per the specs on:\n    // https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/step.xhtml\n    float lo = step(t, 0.5);\n\tfloat hi = 1.0-lo;\n    \n    // float w = linterp( remap( t, 0.166, 0.833 ) );\n    float w = linterp( t );\n\tfloat neg_w = 1.0 - w;\n    \n    // t = 0:       vec3(0,1,1)     * vec3(1.0, 0.0, 1.0);  --\x3e  return vec3(0.0, 0.0, 1.0);\n    // t = 0.1:     vec3(0,1,1)     * vec3(0.8, 0.2, 0.8);  --\x3e  return vec3(0.0, 0.2, 0.8);\n    // t = 0.2:     vec3(0,1,1)     * vec3(0.6, 0.4, 0.6);  --\x3e  return vec3(0.0, 0.4, 0.6);\n    // t = 0.3:     vec3(0,1,1)     * vec3(0.4, 0.6, 0.4);  --\x3e  return vec3(0.0, 0.6, 0.4);\n    // t = 0.4:     vec3(0,1,1)     * vec3(0.2, 0.8, 0.2);  --\x3e  return vec3(0.0, 0.8, 0.2);\n    // t = 0.5:     vec3(0,1,1)     * vec3(0.0, 1.0, 0.0);  --\x3e  return vec3(0.0, 1.0, 0.0);\n    // t = 0.6:     vec3(1,1,0)     * vec3(0.2, 0.8, 0.2);  --\x3e  return vec3(0.2, 0.8, 0.0);\n    // t = 0.7:     vec3(1,1,0)     * vec3(0.4, 0.6, 0.4);  --\x3e  return vec3(0.4, 0.6, 0.0);\n    // t = 0.8:     vec3(1,1,0)     * vec3(0.6, 0.4, 0.6);  --\x3e  return vec3(0.6, 0.4, 0.0);\n    // t = 0.9:     vec3(1,1,0)     * vec3(0.8, 0.2, 0.8);  --\x3e  return vec3(0.8, 0.2, 0.0);\n    // t = 1.0:     vec3(1,1,0)     * vec3(1.0, 0.0, 1.0);  --\x3e  return vec3(1.0, 0.0, 0.0);\n\tret =           vec3(lo,1.0,hi) * vec3(neg_w, w, neg_w);\n\t// return pow( ret, vec3(1.0/2.2) );\n\treturn ret;\n}\n",Ue="\n// note: [0;1]\nfloat rand( vec2 n ) {\n    return fract(sin(dot(n.xy, vec2(12.9898, 78.233)))* 43758.5453);\n}\n  \n// note: [-1;1]\nfloat srand( vec2 n ) {\n    return rand(n) * 2.0 - 1.0;\n}\n",Ae=function(){function e(n,t){Object(p.a)(this,e),this.material=new d.nb({uniforms:{uTexture:{type:"t",value:null},uPosition:{type:"t",value:t.texture},uWindLevel:{value:0},uTime:{value:0},uSphereActiveTimer:{value:0},uAspect:{value:window.innerWidth/window.innerHeight},uBottomDistortion:{value:.5},uDispersion:{value:0}},vertexShader:"\n                varying vec2 vUv;\n\n                void main() {\n                    vUv = uv;\n                    gl_Position = vec4(position.xy, 0.0, 1.0);    \n                }\n            ",fragmentShader:"\n                uniform sampler2D uTexture;\n                uniform sampler2D uPosition;\n                uniform float uWindLevel;\n                uniform float uTime;\n                uniform float uSphereActiveTimer;\n                uniform float uAspect;\n                uniform bool  uBottomDistortion;\n                uniform float uDispersion;\n\n                varying vec2 vUv;\n\n                ".concat(Ue,"\n                ").concat(Re,"\n                ").concat(Me,"\n                ").concat(Fe,"\n                ").concat(Oe,"\n\n\n                /* discontinuous pseudorandom uniformly distributed in [-0.5, +0.5]^3 */\n                vec3 random3(vec3 c) {\n                    float j = 4096.0*sin(dot(c,vec3(17.0, 59.4, 15.0)));\n                    vec3 r;\n                    r.z = fract(512.0*j);\n                    j *= .125;\n                    r.x = fract(512.0*j);\n                    j *= .125;\n                    r.y = fract(512.0*j);\n                    return r-0.5;\n                }\n                \n                const float F3 =  0.3333333;\n                const float G3 =  0.1666667;\n                \n                /* 3d simplex noise */\n                float simplex3d(vec3 p) {\n                     vec3 s = floor(p + dot(p, vec3(F3)));\n                     vec3 x = p - s + dot(s, vec3(G3));\n                     vec3 e = step(vec3(0.0), x - x.yzx);\n                     vec3 i1 = e*(1.0 - e.zxy);\n                     vec3 i2 = 1.0 - e.zxy*(1.0 - e);\n                     vec3 x1 = x - i1 + G3;\n                     vec3 x2 = x - i2 + 2.0*G3;\n                     vec3 x3 = x - 1.0 + 3.0*G3;\n                     vec4 w, d;\n                     w.x = dot(x, x);\n                     w.y = dot(x1, x1);\n                     w.z = dot(x2, x2);\n                     w.w = dot(x3, x3);\n                     w = max(0.6 - w, 0.0);\n                     d.x = dot(random3(s), x);\n                     d.y = dot(random3(s + i1), x1);\n                     d.z = dot(random3(s + i2), x2);\n                     d.w = dot(random3(s + 1.0), x3);\n                     w *= w;\n                     w *= w;\n                     d *= w;\n                     return dot(d, vec4(52.0));\n                }\n                const mat3 rot1 = mat3(-0.37, 0.36, 0.85,-0.14,-0.93, 0.34,0.92, 0.01,0.4);\n                const mat3 rot2 = mat3(-0.55,-0.39, 0.74, 0.33,-0.91,-0.24,0.77, 0.12,0.63);\n                const mat3 rot3 = mat3(-0.71, 0.52,-0.47,-0.08,-0.72,-0.68,-0.7,-0.45,0.56);\n                float simplex3d_fractal(vec3 m) {\n                    return   0.5333333*simplex3d(m*rot1)\n                            +0.2666667*simplex3d(2.0*m*rot2)\n                            +0.1333333*simplex3d(4.0*m*rot3)\n                            +0.0666667*simplex3d(8.0*m);\n                }\n\n                // vec4 block:  .xy bottomcoords - .zw topcoords\n                float isInBlock(vec2 uv, vec4 block) {\n                    vec2 a = sign(uv - block.xy);\n                    vec2 b = sign(block.zw - uv);\n                    return min(sign(a.x + a.y + b.x + b.y - 3.), 0.);\n                }\n\n                vec2 moveDiff(vec2 uv, vec4 swapA, vec4 swapB) {\n                    vec2 diff = swapB.xy - swapA.xy;\n                    return diff * isInBlock(uv, swapA);\n                }\n\n                vec2 randSwap(\n                    vec2 uv, \n                    vec2 gridSize, /* in uv space */\n                    vec2 subGridSize, /* e.g. vec2(3, 3) for a 3x3 grid */ \n                    float time,\n                    inout float dispersion\n                ) {\n                    vec2 gridBottom = uv - mod(uv, gridSize);\n                    vec2 gridCenter = gridBottom + gridSize * 0.5;\n\n                    if(uBottomDistortion) {\n                        uv.y += srand(gridBottom) * 0.025;\n                    }\n\n                    float subGridCellsCount = subGridSize.x * subGridSize.y;\n\n                    float gridRand1 = rand(gridCenter + vec2(time));\n                    float gridRand2 = rand(gridBottom + vec2(time));\n\n                    dispersion += srand(gridBottom + vec2(time)) * (gridSize.x + gridSize.y);\n\n                    float randSubGridIdx1 = floor( gridRand1 * subGridCellsCount  );\n                    float randSubGridIdx2 = floor( gridRand2 * subGridCellsCount  );\n\n                    vec2 subCellSize = gridSize / subGridSize;\n                    \n                    vec2 scell1Bottom = gridBottom + vec2(\n                        mod(randSubGridIdx1, subGridSize.x) * subCellSize.x,\n                        floor(randSubGridIdx1 / subGridSize.x) * subCellSize.y\n                    );\n                    vec2 scell2Bottom = gridBottom + vec2(\n                        mod(randSubGridIdx2, subGridSize.x) * subCellSize.x,\n                        floor(randSubGridIdx2 / subGridSize.x) * subCellSize.y\n                    );\n                    \n                    vec4 swapA = vec4(scell1Bottom, scell1Bottom + subCellSize);\n                    vec4 swapB = vec4(scell2Bottom, scell2Bottom + subCellSize);\n\n                    vec2 newUv = uv;\n                    // if we're in swapA, move to swapB\n                    newUv += moveDiff(uv, swapA, swapB);\n                    // if we're in swapB, move to swapA\n                    newUv += moveDiff(uv, swapB, swapA);\n                    return newUv;\n                }\n\n                void main() {\n                    float rgbOffs = 0.0;\n                    vec2 windOffs = vec2(0.0);\n\n                    vec3 position = texture2D(uPosition, vUv).xyz;\n\n                    if(uWindLevel > 0.0) {\n                        float noisex = simplex3d(vec3(uTime * 1.5, 0.0, 0.0));\n                        float noisey = simplex3d(vec3(uTime * 1.5 + 57.897, 0.0, 0.0));\n\n                        windOffs = vec2(noisex, noisey) * uWindLevel * 0.0035;\n\n                        rgbOffs += uWindLevel * 0.006 * length(vUv - vec2(0.5));\n                    } \n\n                    // vec3 c1 = texture2D(uTexture, vUv + windOffs + vec2(-rgbOffs, 0.0)).xyz;\n                    // vec3 c2 = texture2D(uTexture, vUv + windOffs + vec2(0.0, 0.0)).xyz;\n                    // vec3 c3 = texture2D(uTexture, vUv + windOffs + vec2(+rgbOffs, 0.0)).xyz;\n\n                    // vec3 finalColor = vec3(c1.x, c2.y, c3.z);\n                    // gl_FragColor = vec4(finalColor, 1.0); \n\n\n                    vec2 nuvs = vUv + windOffs;\n\n                    float sphereActiveTime = uSphereActiveTimer;\n                    float strength = 0.0;\n                    float targetDist = length(vec3(position.x, 0.0, position.z) - vec3(0.71, 0.0, -0.05));\n\n                    sphereActiveTime -= 0.3;\n                    if(targetDist > 0.5 && targetDist < 0.65 && position.y < -0.4575) {\n                        strength += 0.15 * clamp(sphereActiveTime, 0.0, 1.0);\n                    }\n\n                    sphereActiveTime -= 0.5;\n                    if(targetDist > 0.75 && targetDist < 0.8 && position.y < -0.40) {\n                        strength += 0.15 * clamp(sphereActiveTime, 0.0, 1.0);\n                    }\n                    \n                    float modT = mod(uTime, 5.0);\n                    sphereActiveTime -= 0.2;\n                    if(targetDist > modT && targetDist < (0.6 + modT)) {\n                        float mid = 0.3 + modT;\n                        float t = 1.0 - abs(targetDist - mid) / 0.3;\n\n                        if(targetDist < 0.9) t = 0.0;\n                        if(targetDist > 4.0) t *= 1.0 - (targetDist - 4.0);\n\n                        strength += t * 0.15 * clamp(sphereActiveTime, 0.0, 1.0);\n                    }\n\n                    {\n                        float modT = mod(uTime * 2.0 + 1.0, 10.0);\n                        if(targetDist > modT && targetDist < (0.3 + modT)) {\n                            float mid = 0.15 + modT;\n                            float t = 1.0 - abs(targetDist - mid) / 0.15;\n    \n                            if(targetDist < 0.9) t = 0.0;\n                            if(targetDist > 4.0) t *= 1.0 - (targetDist - 4.0);\n    \n                            strength += t * 0.15 * clamp(sphereActiveTime, 0.0, 1.0);\n                        }\n                    }\n                    \n\n\n\n                    float time = uTime;\n                    float dispersion = 0.0;\n                    float nullop = 0.0; // we'll use this value instead of dispersion just because the compiler complaints if I don't do it\n\n                    vec2 uv = randSwap(nuvs, vec2(0.40 + nuvs.x * 0.0000025, 0.20),  vec2(3.0, 3.0), time - mod(time, 0.15), dispersion);\n                    uv      = randSwap(uv,  vec2(0.02 + uv.x  * 0.0000025, 0.015), vec2(3.0, 2.0), time - mod(time, 0.05), nullop);\n                    uv      = randSwap(uv,  vec2(0.06 + uv.x  * 0.0000025, 0.12),  vec2(2.0, 3.0), time - mod(time, 0.02), nullop);\n                    uv      = randSwap(uv,  vec2(0.35 + uv.x  * 0.0000025, 0.35),  vec2(2.0, 2.0), time - mod(time, 0.07), dispersion);\n\n                    vec2 dist = nuvs - uv;\n                    uv += dist * (1.0 - strength);\n                    dispersion = sat(dispersion) * strength * 15.0;\n\n\n                    float direction = rand(vec2(dispersion)) > 0.5 ? -1.0 : 1.0;\n                    const int steps = 10;\n                    vec3 sum = vec3(0.0);\n                    vec3 cumw = vec3(0.0);\n\n                    // rand pixel offset to ease dispersion a bit\n                    uv.x += srand(uv) * 0.01 * dispersion;\n\n                    for(int i = 0; i < steps; i++) {\n                        float t = float(i) / float(steps);\n                        vec2 dispUv = uv + vec2(dispersion * 0.1 * direction * t, 0.0);\n                        vec3 spectr = spectrum_offset(t);\n                        cumw += spectr;\n                        sum += texture2D(uTexture, dispUv).rgb * spectr;\n                    }\n\n                    gl_FragColor = vec4(sum / cumw, 1.0);\n                }\n            "),depthTest:!1,depthWrite:!1}),this.mesh=new d.N(new d.ab(2,2),this.material),this.camera=new d.Z(45,1,1,1e3),this.renderer=n,this.scene=new d.lb,this.scene.add(this.mesh)}return Object(y.a)(e,[{key:"compute",value:function(e,n,t){var i=e.windLevel,r=e.time,o=e.sphereActiveTimer;this.renderer.setRenderTarget(t),this.material.uniforms.uTexture.value=n,this.material.uniforms.uWindLevel.value=i,this.material.uniforms.uTime.value=r,this.material.uniforms.uSphereActiveTimer.value=o,this.renderer.render(this.scene,this.camera),this.renderer.setRenderTarget(null)}}]),e}(),Ie=function(e){return new d.nb({side:d.m,uniforms:{map:{type:"t",value:e},uTime:{value:0},uSphereActiveTimer:{value:0}},vertexShader:"\n      varying vec3 vFragPos;\n      varying vec2 vUv;\n\n      void main() {\n\n\n        // ******* this code block is necessary for compatibility with\n        // reflectable-material ********\n        vec4 mvPosition = vec4(position, 1.0);\n        mvPosition = modelViewMatrix * mvPosition;\n        // ******* this code block is necessary for compatibility with\n        // reflectable-material ********\n\n\n        gl_Position = projectionMatrix * mvPosition;\n        vFragPos = (modelMatrix * vec4(position, 1.0)).xyz;\n\n        vUv = uv;\n      }\n    ",fragmentShader:"\n      varying vec3 vFragPos;\n      varying vec2 vUv;\n   \n      uniform sampler2D map;\n      uniform float uTime;\n      uniform float uSphereActiveTimer;\n\n      vec2 GetGradient(vec2 intPos, float t) {\n        // Uncomment for calculated rand\n        float rand = fract(sin(dot(intPos, vec2(12.9898, 78.233))) * 43758.5453);;\n        \n        // Texture-based rand (a bit faster on my GPU)\n        // float rand = texture(iChannel0, intPos / 64.0).r;\n        \n        // Rotate gradient: random starting rotation, random rotation rate\n        float angle = 6.283185 * rand + 4.0 * t * rand;\n        return vec2(cos(angle), sin(angle));\n      }\n    \n      float Pseudo3dNoise(vec3 pos) {\n        vec2 i = floor(pos.xy);\n        vec2 f = pos.xy - i;\n        vec2 blend = f * f * (3.0 - 2.0 * f);\n        float noiseVal = \n            mix(\n                mix(\n                    dot(GetGradient(i + vec2(0, 0), pos.z), f - vec2(0, 0)),\n                    dot(GetGradient(i + vec2(1, 0), pos.z), f - vec2(1, 0)),\n                    blend.x),\n                mix(\n                    dot(GetGradient(i + vec2(0, 1), pos.z), f - vec2(0, 1)),\n                    dot(GetGradient(i + vec2(1, 1), pos.z), f - vec2(1, 1)),\n                    blend.x),\n            blend.y\n        );\n        return noiseVal / 0.7; // normalize to about [-1..1]\n      }\n    \n\n      void main() {\n        // this is only necessary for compatibility with reflectable-material\n        // you can assume that this line doesn't exist at all\n        gl_FragColor = linearToOutputTexel( gl_FragColor );\n\n        float noiseVisibility = clamp(uSphereActiveTimer - 0.5, 0.0, 1.0);\n\n        vec3 color = texture2D(map, vUv).xyz;\n\n        vec2 nuv = vec2(vFragPos.x, vFragPos.z);\n\n        float offset = uTime * 0.01;\n        \n        float noise = (vFragPos.x + 99.0) * 10.0 + \n          (Pseudo3dNoise(vec3(nuv, offset * 6.0) * 0.5) * 0.5 + 0.5) * 30.0 + \n          (Pseudo3dNoise(vec3(nuv, offset * 0.5) * 4.0) * 0.5 + 0.5) * 6.0 +\n          (Pseudo3dNoise(vec3(nuv, offset * 0.5) * 20.0) * 0.5 + 0.5) * 1.1 +  \n          (Pseudo3dNoise(vec3(nuv, offset * 0.5) * 40.0) * 0.5 + 0.5) * 0.5 \n        ;\n        float modnoise = mod(noise, 3.0);\n        float opwindow = 0.09;\n        float linewidth = 0.3;\n\n        if(modnoise > linewidth) {\n          noise = 0.0;\n        } else if (modnoise > linewidth - opwindow) {\n          noise = 1.0 - (modnoise - (linewidth-opwindow)) / opwindow;\n        } else if (modnoise < opwindow) {\n          noise = modnoise / opwindow;\n        } else {\n          noise = 1.0;\n        }\n        noise *= 1.65 * noiseVisibility;\n\n\n        // time-based noise animation\n        float timeMult = 1.0;\n        float animT = mod(uTime * timeMult, 30.0);\n\n        if(animT > 3.5 && animT < 5.0) {\n          float t = (animT - 3.5) / 1.5;\n\n          float targetDist = (t - 0.15) * 9.0;\n          float dist = length(vec3(vFragPos.x, 0.0, vFragPos.z) - vec3(0.71, 0.0, -0.05));\n          \n          dist += Pseudo3dNoise(vec3(nuv, uTime * 0.2) * 4.7) * 0.35;\n          dist = abs(dist - targetDist);\n\n          dist = 1.0 - clamp(dist, 0.0, 0.9) / 0.9;\n        \n          noise *= dist;\n          noise *= 2.0;\n          color *= 1.0 + noise;\n\n        } else if(animT > 5.5 && animT < 6.5) {\n          float t = ((animT - 5.5) / 1.0) * 3.0 - 1.5;\n          t += Pseudo3dNoise(vec3(nuv, uTime * 0.2) * 4.7) * 1.0;\n          t = clamp(t, 0.0, 1.0);\n          noise *= t;\n          color *= 1.0 + noise;\n        } else if(animT > 6.5 && animT < 11.0) {\n\n          color *= 1.0 + noise;\n\n        } else if(animT > 11.0 && animT < 12.0) {\n          float t = -((animT - 11.0) / 1.0) * 3.0 + 1.5;\n          t += Pseudo3dNoise(vec3(nuv, uTime * 0.2) * 4.7) * 1.0;\n          t = clamp(t, 0.0, 1.0);\n          noise *= t;\n          color *= 1.0 + noise;\n        \n        } else if(animT < 16.0) {\n          // pause          \n        } else if(animT > 16.0 && animT < 24.0) {\n          float t = ((animT - 16.0) / 2.0) * 3.0 - 1.5;\n          t += Pseudo3dNoise(vec3(nuv, uTime * 0.2) * 2.0) * 0.8;\n          t += Pseudo3dNoise(vec3(nuv, uTime * 0.2) * 0.65) * 0.2;\n          t = clamp(t, 0.0, 1.0) * noiseVisibility;\n\n          color = mix(color, color * noise * 0.5 + color * 0.07, t);\n        } else if (animT > 24.0 && animT < 26.0) {\n          float t = -((animT - 24.0) / 2.0) * 3.0 + 1.5;\n          t += Pseudo3dNoise(vec3(nuv, uTime * 0.2) * 2.0) * 0.8;\n          t += Pseudo3dNoise(vec3(nuv, uTime * 0.2) * 0.65) * 0.2;\n          t = clamp(t, 0.0, 1.0) * noiseVisibility;\n\n          color = mix(color, color * noise * 0.5 + color * 0.07, t);\n        }\n\n        gl_FragColor = vec4(color, 1.0);\n      }\n    "})};function _e(e){return e.userData.uReflect={value:!1},e.userData.uReflectPositionPass={value:!1},e.reflectable=!0,e.onBeforeCompile=function(n){var t=["uniform bool uReflect;\n","uniform bool uReflectPositionPass;\n","varying vec3 vReflectedPos;\n"].join("\n");n.uniforms.uReflect=e.userData.uReflect,n.uniforms.uReflectPositionPass=e.userData.uReflectPositionPass,n.vertexShader=Te(n.vertexShader),n.vertexShader=n.vertexShader.replace("mvPosition = modelViewMatrix * mvPosition;","\n        mvPosition = modelMatrix * mvPosition;\n        if(uReflect) {\n          mvPosition.y = -(mvPosition.y ".concat("+ 0.92",");\n        }\n        vReflectedPos = mvPosition.xyz;\n        mvPosition = viewMatrix * mvPosition;\n      ")),n.vertexShader=""+t+n.vertexShader,n.fragmentShader=Te(n.fragmentShader),n.fragmentShader=n.fragmentShader.replace("gl_FragColor = linearToOutputTexel( gl_FragColor );","\n      gl_FragColor = linearToOutputTexel( gl_FragColor );\n      if(uReflect && vReflectedPos.y > ".concat("- 0.46",") {\n        discard;\n      }\n\n      if(uReflectPositionPass) {\n        gl_FragColor = vec4(vReflectedPos, 1.0);\n        return;\n      }\n      ")),n.fragmentShader=""+t+n.fragmentShader},e}function Le(){return new d.nb({vertexShader:"\n      varying vec3 vFragPos;\n      varying vec3 vNormal;\n      varying mat4 vProjViewMatrix;\n      varying mat4 vViewMatrix;\n\n      void main() {\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0); \n      \n        vFragPos = (modelMatrix * vec4(position, 1.0)).xyz;\n        vNormal = mat3(transpose(inverse(modelMatrix))) * normal;\n        vProjViewMatrix = projectionMatrix * viewMatrix;\n        vViewMatrix = viewMatrix;\n      }\n    ",fragmentShader:"\n    varying vec3 vFragPos;\n    varying vec3 vNormal;\n    varying mat4 vProjViewMatrix;\n    varying mat4 vViewMatrix;\n\n    uniform sampler2D uMountainsDepth;\n    uniform sampler2D uWaterDepth;\n    uniform sampler2D uColor;\n    uniform sampler2D uBlurredReflectionDistance;\n    uniform sampler2D uFluidTexture;\n\n    uniform vec2 uScreenSize;\n    uniform vec2 uPixelSize;\n    uniform vec3 uCameraPos;\n\n    void main() {\n      vec3 norm = normalize(vNormal);\n\n      vec2 uv = gl_FragCoord.xy / uScreenSize.xy;\n      \n      \n      // fluid sim - these calculations need to match inside fluidsim.js as well\n      // get plane position\n      vec3 sphereCenter = vec3(0.71, -0.13, -0.05);\n      vec2 distVec = (vFragPos - sphereCenter).xz * 0.75;\n      vec2 fluidUv = clamp(distVec, -1.0, 1.0) * 0.5 + 0.5;\n      \n      vec3 fluidOffset = vec3(0.0);\n      vec3 fluidColor  = vec3(0.2, 0.1, 0.06);\n      float fluidAlpha = 0.0;\n      vec3 f0 = texture2D(uFluidTexture, fluidUv).xyz;\n      vec3 fdx = texture2D(uFluidTexture, fluidUv + vec2(uPixelSize.x, 0.0)).xyz;\n      vec3 fdy = texture2D(uFluidTexture, fluidUv + vec2(0.0, uPixelSize.y)).xyz;\n      fluidOffset.x = f0.x - fdx.x;\n      fluidOffset.y = f0.y - fdy.x;\n      fluidAlpha = clamp(f0.x, 0.0, 1.0);\n\n      if(distVec.x < -1.0 || distVec.x > 1.0 || distVec.y < -1.0 || distVec.y > 1.0) {\n        fluidOffset = vec3(0.0);\n        fluidColor  = vec3(0.0);\n        fluidAlpha  = 0.0;\n      }\n      \n      uv += fluidOffset.xy * 0.055;\n      \n      float mountainsDepth = texture2D(uMountainsDepth, uv).x;\n      float waterDepth = texture2D(uWaterDepth, uv).x;\n\n      float diff = max(-(waterDepth - mountainsDepth), 0.0) * 13.0;\n      diff = min(diff, 2.5);\n      vec3 color = vec3(0.09, 0.027, 0.0);\n      float alpha = 1.0 - exp(-diff);\n\n      vec3 reflectionColor = texture2D(uColor, uv).xyz;\n      reflectionColor *= 1.0;\n      reflectionColor *= vec3(1.0, 0.8, 0.4);\n\n\n      vec3 colorPlusReflections = color + reflectionColor;\n      // vec3 colorWithFluid = mix(colorPlusReflections, fluidColor, fluidAlpha);\n      // vec3 colorWithFluid = pow(colorPlusReflections, vec3(1.0 + fluidAlpha * 3.0));\n      \n      // vec3 colorWithFluid = colorPlusReflections * (1.0 + fluidAlpha * 2.0);\n      // colorWithFluid = mix(colorWithFluid, fluidColor, fluidAlpha * 0.9);\n\n      vec3 colorWithFluid = colorPlusReflections * (1.0 + fluidAlpha * 2.0);\n      if(fluidAlpha > 0.75) {\n        colorWithFluid = mix(colorWithFluid, fluidColor, (fluidAlpha - 0.75) * 3.5);\n      }\n\n      // vec3 colorWithFluid = colorPlusReflections + (colorPlusReflections - vec3(0.15)) * (fluidAlpha * 2.0);\n      // if(fluidAlpha > 0.75) {\n      //   colorWithFluid = mix(colorWithFluid, fluidColor, (fluidAlpha - 0.75) * 2.75);\n      // }\n\n\n\n      gl_FragColor = vec4(colorWithFluid, alpha);\n\n      // gl_FragColor = texture2D(uPosition, uv, 5.0);\n      // gl_FragColor = vec4(norm, 1.0);\n      // gl_FragColor = vec4(vFragPos, 1.0);\n      // gl_FragColor = vec4(waterDepth < mountainsDepth ? 1.0 : 0.0, 0.0, 0.0, 1.0);\n      // gl_FragColor = vec4(vec3(mountainsDepth) * 0.1  , 1.0);\n      // gl_FragColor = vec4(vec3(diff), 1.0);\n    }\n    ",uniforms:{uMountainsDepth:{type:"t",value:null},uWaterDepth:{type:"t",value:null},uColor:{type:"t",value:null},uScreenSize:{value:new d.Bb(window.innerWidth,window.innerHeight)},uPixelSize:{value:new d.Bb(1/window.innerWidth,1/window.innerHeight)},uCameraPos:{value:new d.Cb(0,0,0)},uBlurredReflectionDistance:{type:"t",value:null},uFluidTexture:{type:"t",value:null}},side:d.m,transparent:!0})}var Ee,Be,je,Ve,ke,Ne=window.innerWidth,Ge=window.innerHeight,Ye=new d.lb,We=new d.Z(40,Ne/Ge,.1,1e3),He=new d.Eb(Ne,Ge,{});He.texture.encoding=d.Hb;var Xe=new d.nb({vertexShader:"\n    varying vec2 vUv;\n\n    void main() {\n      gl_Position = vec4(position.xy, 0.0, 1.0); \n      vUv = uv;\n    }\n  ",fragmentShader:"\n  varying vec2 vUv;\n  \n  uniform sampler2D uSceneTex;\n  uniform sampler2D uFluidVelocityTex;\n  uniform sampler2D uFluidDyeTex;\n\n  ".concat(Re,"\n  ").concat(Me,"\n  ").concat(Fe,"\n  ").concat(Oe,"\n  ").concat(Ue,"\n  \n  void main() {\n\n    vec4 fluidVel = -texture2D(uFluidVelocityTex, vUv);\n    vec4 fluidDye = texture2D(uFluidDyeTex, vUv);\n\n\n    float velStrength = 0.00002;\n    velStrength = 0.0;\n    float dyeStrength = 0.01;\n\n    \n    vec2 uvOffset1 = fluidVel.xy * velStrength;\n    vec2 uvOffset2 = fluidDye.xy * dyeStrength;\n    vec2 uvOffset = uvOffset1 + uvOffset2;\n\n    vec4 accum = vec4(0.0);\n    vec3 soAccum = vec3(0.0);\n\n    int steps = 20;\n    float fsteps = float(steps);\n    float invSteps = 1.0 / float(steps);\n\n    for(int i = 0; i < steps; i++) {\n      vec2 transformedUv = vUv + uvOffset * ((float(i) * invSteps) * fsteps * 0.85 + fsteps * 0.15);\n      uvOffset *= (1.0 + srand(transformedUv + float(i) * 0.1987) * 0.05);\n      vec4 color = texture2D(uSceneTex, transformedUv);\n\n      vec3 so = spectrum_offset(float(i) * invSteps);\n      soAccum += so;\n\n      accum += color * vec4(so, 1.0);\n    }\n\n    accum.rgb /= soAccum;\n    accum.a = 1.0;\n\n\n    gl_FragColor = accum;\n    // gl_FragColor = fluidVel;\n\n\n    // vec4 fluidVel2 = texture2D(uFluidVelocityTex, vUv);\n    // gl_FragColor = fluidVel2;\n  }\n  "),uniforms:{uSceneTex:{type:"t",value:null},uFluidVelocityTex:{type:"t",value:null},uFluidDyeTex:{type:"t",value:null}},depthTest:!1,depthWrite:!1}),Qe=new d.N(new d.ab(2,2),Xe);new d.Z(45,1,1,1e3);(new d.lb).add(Qe);var Ze,qe,Je,Ke,$e=new d.lb,en=[],nn=new d.lb,tn=new d.Fb(Ne,Ge,{type:d.r}),rn=new d.lb,on=new d.Fb(Ne,Ge,{type:d.r}),an=new d.lb,sn=new d.Fb(Ne,Ge,{});sn.texture.encoding=d.Hb;var ln=new d.Fb(Ne,Ge,{depthBuffer:!1,stencilBuffer:!1}),un=new d.Fb(Ne,Ge,{minFilter:d.F,magFilter:d.E});un.texture.encoding=d.Hb,un.texture.generateMipmaps=!0;var cn,vn,dn,mn,fn,xn,hn=new d.Fb(Ne,Ge,{type:d.r,minFilter:d.S,magFilter:d.S}),pn=new d.Fb(Ne,Ge,{type:d.r,minFilter:d.S,magFilter:d.S}),yn=new d.Fb(Ne,Ge,{type:d.r,minFilter:d.S,magFilter:d.S}),gn=new d.Fb(Ne,Ge,{type:d.r,minFilter:d.S,magFilter:d.S}),wn=new d.Fb(Ne,Ge,{type:d.r,minFilter:d.S,magFilter:d.S});console.log("TODO: resize rts on window resize"),console.log("TODO: resize water material on window resize"),console.log("TODO: resize gbuffers");var bn,zn=new C(We,rn),Sn=new d.Cb(4.389916588536426,3.0581657791499914,-2.81715742168022),Tn=new d.Cb(3.5972306534901795,1.2510861359705123,-2.010063762495709),Cn=0;function Pn(){return(Pn=Object(v.a)(c.a.mark((function e(n){var t,i,r,o,a,s,l,u,v,h,p,y,C,R,M,F,O,U,A,I,_,L,E,B,j,V;return c.a.wrap((function(e){for(;;)switch(e.prev=e.next){case 0:return(Ee=new d.Gb({canvas:n,antialias:!0})).setSize(Ne,Ge),Ee.toneMapping=d.k,Ee.outputEncoding=d.Hb,d.mb.tonemapping_pars_fragment=d.mb.tonemapping_pars_fragment.replace("vec3 CustomToneMapping( vec3 color ) { return color; }","\n    vec3 CustomToneMapping( vec3 color ) {\n      const mat3 ACESInputMat = mat3(\n        vec3( 0.59719, 0.07600, 0.02840 ), vec3( 0.35458, 0.90834, 0.13383 ), vec3( 0.04823, 0.01566, 0.83777 )\n        );\n        const mat3 ACESOutputMat = mat3(\n        vec3(  1.60475, -0.10208, -0.00327 ), vec3( -0.53108, 1.10813, -0.07276 ), vec3( -0.07367, -0.00605, 1.07602 )\n        );\n        color *= toneMappingExposure / 0.6;\n        color = ACESInputMat * color;\n        color = RRTAndODTFit( color );\n        color = ACESOutputMat * color;\n        return saturate( color );\n    }"),(Be=new m.a(We,n)).target.set(.38096045206150597,-.6850691022701711,.2873385380788971),Be.enableDamping=!0,Be.dampingFactor=.05,Be.rotateSpeed=.5,Be.enableZoom=!1,Be.enablePan=!1,Be.enableRotate=!1,Be.maxPolarAngle=.4*Math.PI,We.position.copy(Sn),bn=document.querySelector(".curtain"),t=bn.querySelector("p"),i=!1,document.querySelector(".free-camera-btn").addEventListener("click",(function(){(i=!i)?(Be.enableZoom=!0,Be.enablePan=!0,Be.enableRotate=!0,Be.maxPolarAngle=Math.PI,document.querySelector(".free-camera-btn p").innerHTML="Free camera<br>ON"):(Be.enableZoom=!1,Be.enablePan=!1,Be.enableRotate=!0,Be.maxPolarAngle=.4*Math.PI,document.querySelector(".free-camera-btn p").innerHTML="Free camera<br>OFF")})),je=new g(Ee),Je=new w(Ee,null,We),cn=new b(Ee,null,We),vn=new S(Ee),dn=new T(Ee,window.innerWidth,window.innerHeight),mn=new z(Ee),xn=new Ae(Ee,gn),t.textContent="downloading assets 01 / 12",e.next=29,(new f.a).loadAsync("./assets/models/mountains.glb");case 29:return r=e.sent.scene,o=r.children[0].children[0].children[0].children,t.textContent="downloading assets 02 / 12",e.next=34,(new f.a).loadAsync("./assets/models/isle.glb");case 34:return a=(a=e.sent.scene).children[0],t.textContent="downloading assets 03 / 12",e.next=39,(new f.a).loadAsync("./assets/models/toruses.glb");case 39:return s=e.sent.scene,t.textContent="downloading assets 04 / 12",e.next=43,(new f.a).loadAsync("./assets/models/plane.glb");case 43:return Ze=e.sent.scene.children[0],t.textContent="downloading assets 05 / 12",e.next=47,(new d.xb).loadAsync("./assets/textures/baketest6-1000s.jpg");case 47:return(l=e.sent).flipY=!1,l.encoding=d.Hb,t.textContent="downloading assets 06 / 12",e.next=53,(new d.xb).loadAsync("./assets/textures/islebake3-1000s.png");case 53:return(u=e.sent).encoding=d.Hb,u.flipY=!1,a.material=_e(new d.O({color:"white",side:d.m,map:u,toneMapped:!1})),a.name="isle-group",Ye.add(a.clone()),nn.add(a.clone()),t.textContent="downloading assets 07 / 12",e.next=63,(new f.a).loadAsync("./assets/models/rock1.glb");case 63:return v=e.sent.scene.children[0],e.next=66,(new d.xb).loadAsync("./assets/textures/rock1.png");case 66:return(h=e.sent).flipY=!1,h.encoding=d.Hb,v.material=_e(new d.O({color:"white",side:d.m,map:h,toneMapped:!1})),en.push(v.clone()),Ye.add(Se(en)),t.textContent="downloading assets 08 / 12",e.next=75,(new f.a).loadAsync("./assets/models/rock2.glb");case 75:return p=e.sent.scene.children[0],e.next=78,(new d.xb).loadAsync("./assets/textures/rock2.png");case 78:return(y=e.sent).flipY=!1,y.encoding=d.Hb,p.material=_e(new d.O({color:"white",side:d.m,map:y,toneMapped:!1})),en.push(p.clone()),Ye.add(Se(en)),t.textContent="downloading assets 09 / 12",e.next=87,(new f.a).loadAsync("./assets/models/rock3.glb");case 87:return C=e.sent.scene.children[0],e.next=90,(new d.xb).loadAsync("./assets/textures/rock3.png");case 90:return(R=e.sent).flipY=!1,R.encoding=d.Hb,C.material=_e(new d.O({color:"white",side:d.m,map:R,toneMapped:!1})),en.push(C.clone()),Ye.add(Se(en)),t.textContent="downloading assets 10 / 12",e.next=99,(new f.a).loadAsync("./assets/models/rock4.glb");case 99:return M=e.sent.scene.children[0],e.next=102,(new d.xb).loadAsync("./assets/textures/rock4.png");case 102:return(F=e.sent).flipY=!1,F.encoding=d.Hb,M.material=_e(new d.O({color:"white",side:d.m,map:F,toneMapped:!1})),Ye.add(M.clone()),t.textContent="downloading assets 11 / 12",e.next=110,(new f.a).loadAsync("./assets/models/astronaut.glb");case 110:return O=e.sent.scene.children[0],e.next=113,(new d.xb).loadAsync("./assets/textures/astronaut.png");case 113:for((U=e.sent).flipY=!1,U.encoding=d.Hb,O.material=_e(new d.O({color:"white",side:d.m,map:U,toneMapped:!1})),Ye.add(O.clone()),A=0;A<o.length;A++)(I=o[A]).traverse((function(e){e instanceof d.N&&(e.material=_e(new d.O({color:"white",side:d.m,map:l,toneMapped:!1})),e.name="mountain-group",e.scale.set(9.426517486572266,9.426517486572266,9.426517486572266),e.translateX(.004342761361665892),e.translateY(-.9083115342244241),e.translateZ(.9083186979933089),e.rotateX(-1.5707958795918522),e.rotateY(-.00478110738920276),e.rotateZ(9598708991624814e-20),e.updateMatrix(),e.geometry.applyMatrix(e.matrix),e.position.set(0,0,0),e.rotation.set(0,0,0),e.scale.set(1,1,1),e.updateMatrix())})),Ye.add(I.clone()),nn.add(I.clone());return _=[],s.children.forEach((function(e,n){e.traverse((function(e){e instanceof d.N&&(e.material=_e(new d.Q({emissive:new d.j("#FF5624"),emissiveIntensity:0===n?20:10,side:d.m,toneMapped:!1})),e.updateMatrix(),e.geometry.applyMatrix(e.matrix),e.position.set(0,0,0),e.rotation.set(0,0,0),e.scale.set(1,1,1),e.updateMatrix(),_.push(e.geometry.clone()))})),Ye.add(e.clone())})),L=Object(x.a)(_),E=new d.N(L,new d.O({color:16777215})),an.add(E),fn=new P(Ee,window.innerWidth,window.innerHeight,an,We,gn,je),Ze.material=Le(),Ze.material.uniforms.uScreenSize.value=new d.Bb(Ne,Ge),Ze.scale.set(100,1,100),console.log(Ze),rn.add(Ze.clone()),ke=new D,Ye.add(ke.mesh),B=new d.Y(Ee),Ye.position.set(-.699878,.134614,.036077),j=B.fromScene(Ye),Ye.position.set(0,0,0),Ye.traverse((function(e){"mountain-group"==e.name&&(e.material=_e(Ie(l))),"isle-group"==e.name&&(e.material=_e(Ie(u)))})),s.children.forEach((function(e,n){e.traverse((function(e){e instanceof d.N&&(e.material.emissiveIntensity=0===n?4:2)}))})),t.textContent="downloading assets 12 / 12",e.next=142,(new f.a).loadAsync("./assets/models/sphere.glb");case 142:return qe=e.sent.scene.children[0],e.next=145,(new d.xb).loadAsync("./assets/textures/sphere.png");case 145:(V=e.sent).flipY=!1,qe.material=_e(new d.Q({metalness:0,envMap:j.texture,envMapIntensity:1,side:d.m,map:V})),Ye.add(qe),t.classList.add("hidden"),q(Ee,n,{SIM_RESOLUTION:256,DYE_RESOLUTION:512,CAPTURE_RESOLUTION:256,DENSITY_DISSIPATION:.7,VELOCITY_DISSIPATION:1.8,PRESSURE:1,PRESSURE_ITERATIONS:20,CURL:14,SPLAT_RADIUS:.15,SPLAT_FORCE:6e3,SHADING:!1,COLORFUL:!0,COLOR_UPDATE_SPEED:10,PAUSED:!1,BACK_COLOR:{r:0,g:0,b:0},TRANSPARENT:!1}),Ve=new d.i,oe(We,rn),Ke=De(0,We,(function(e){e&&(Mn.sphereActive=!Mn.sphereActive,Mn.sphereClickTimer=0)})),Ee.setAnimationLoop(Fn);case 155:case"end":return e.stop()}}),e)})))).apply(this,arguments)}function Dn(e){e.traverse((function(e){e instanceof d.N&&e.material.reflectable&&(e.material.userData.uReflect.value=!e.material.userData.uReflect.value)}))}function Rn(e,n){e.traverse((function(e){e instanceof d.N&&e.material.reflectable&&(e.material.userData.uReflectPositionPass.value=n)}))}var Mn={sphereActive:!1,sphereActiveTimer:0,sphereClickTimer:999};function Fn(e){e*=.001;var n=Ve.getDelta(),t=Ve.getElapsedTime();(Cn+=.35*n)<1?(We.position.copy(Sn.clone().lerp(Tn,Object(h.b)(Cn,0,1))),bn.style.opacity=Math.max(Object(h.b)(1-1.3*Cn,0,1),0)):Pe("camera anim finish")&&(We.position.copy(Tn),bn.remove(),Be.enableRotate=!0),Be.update(),Ke.update(n),Mn.sphereActive&&Mn.sphereActiveTimer<2&&(Mn.sphereActiveTimer+=n),!Mn.sphereActive&&Mn.sphereActiveTimer>0&&(Mn.sphereActiveTimer-=n,Mn.sphereActiveTimer<0&&(Mn.sphereActiveTimer=0)),Mn.sphereClickTimer+=n,Ye.traverse((function(e){"mountain-group"==e.name&&(e.material.uniforms.uTime.value=t,e.material.uniforms.uSphereActiveTimer.value=Mn.sphereActiveTimer),"isle-group"==e.name&&(e.material.uniforms.uTime.value=t,e.material.uniforms.uSphereActiveTimer.value=Mn.sphereActiveTimer)}));var i=.5*t%15,r=0;if(i>4&&i<6){var o=(i-4)/2;r=o,fn.setWindLevel(o*n,o),zn.setWindLevel(o*n)}else if(i>=6&&i<=7)r=1,fn.setWindLevel(1*n,1),zn.setWindLevel(1*n);else if(i>7&&i<9){var a=1-(i-7)/2;r=a,fn.setWindLevel(a*n,a),zn.setWindLevel(a*n)}ke.update(Mn.sphereActiveTimer),en.forEach((function(n,t){n.transSpeed||(n.transSpeed=2*Math.random()+.5),n.transAmt||(n.transAmt=4e-4*Math.random()+2e-4),n.rot||(n.rot=new d.Cb(.003,.003,0)),n.position.copy((new d.Cb).copy(n.position).add(new d.Cb(0,Math.sin(e*n.transSpeed)*n.transAmt,0))),n.rotation.x+=Math.sin(e)*n.rot.x,n.rotation.y+=Math.sin(e)*n.rot.y})),qe.material.envMapIntensity=1,qe.material.roughness=.185,qe.material.metalness=0,Mn.sphereClickTimer<1&&(qe.material.envMapIntensity=.3+.7*Mn.sphereClickTimer,qe.material.roughness=.25*(1-Mn.sphereClickTimer)+.185),zn.update(),Ye.add(zn.mesh),Ee.setRenderTarget(He),Ee.render(Ye,We),Ye.remove(zn.mesh),cn.scene=Ye,Ye.add(Ze),Ye.add(zn.mesh),cn.blitPosition(gn),Ye.remove(zn.mesh),Ye.remove(Ze),$e.add(Ze),cn.scene=$e,cn.blitPosition(wn),$e.remove(Ze),qe.material.envMapIntensity=.35,Dn(Ye),Ee.setRenderTarget(sn),Ee.render(Ye,We),Ee.setRenderTarget(null),Dn(Ye),mn.blitReflectedColor(sn.texture,wn.texture,gn.texture,un),Dn(Ye),Rn(Ye,!0),Ee.setRenderTarget(hn),Ee.render(Ye,We),Ee.setRenderTarget(null),Rn(Ye,!1),Dn(Ye),vn.blitReflectionDistance(hn.texture,wn.texture,gn.texture,pn),dn.blur(pn.texture,un.texture,yn),ee(),Je.scene=nn,Je.blitDepth(tn),Je.scene=rn,Je.blitDepth(on),Ze.material.uniforms.uMountainsDepth.value=tn.texture,Ze.material.uniforms.uWaterDepth.value=on.texture,Ze.material.uniforms.uColor.value=yn.texture,Ze.material.uniforms.uCameraPos.value=We.position.clone(),Ze.material.uniforms.uBlurredReflectionDistance.value=yn.texture,Ze.material.uniforms.uFluidTexture.value=Z.dye.write.texture,Ee.autoClear=!1,Ee.setRenderTarget(He),Ee.render(rn,We),Ee.autoClear=!0,fn.compute(He.texture,ln),xn.compute({windLevel:r,time:t,sphereActiveTimer:Mn.sphereActiveTimer},ln.texture,null),Pe("clock start")&&Ve.start()}var On,Un=t(20),An=t(9),In=Object(l.a)(On||(On=Object(s.a)(['\n  html, body, #root, .App {\n    width:  100%;\n    height: 100%;\n    overflow: hidden;\n    margin: 0;\n\n    cursor: none;\n  }\n\n\n  .central-cursor {\n    width: 8px;\n    height: 8px;\n    border-radius: 100%;\n    border: 2px solid white;\n\n    position: absolute;\n    top: 0; left: 0;\n\n    box-sizing: border-box;\n\n    pointer-events: none;\n\n    transition: transform .1s, background .1s;\n\n    &.active {\n      /* opacity: 0; */\n      transform: scale(0.65);\n      background: white;\n    }\n  }\n\n  .outer-cursor {\n    width:  36px;\n    height: 36px;\n    border-radius: 100%;\n    border: 2px solid white;\n\n    position: absolute;\n    top: 0; left: 0;\n\n    box-sizing: border-box;\n\n    opacity: 0.5;\n\n    pointer-events: none;\n\n    transition: transform .2s, opacity .2s;\n\n    &::before {\n      width: 36px;\n      height: 36px;\n      border-radius: 100%;\n      border: 1.25px solid white;\n      content: " ";\n      opacity: 0;\n      position: absolute;\n      top: calc(50% - 18px);\n      left: calc(50% - 18px);\n      box-sizing: border-box;\n\n      transition: transform .2s, opacity .2s;\n    }\n\n    &.hover {\n      transform: scale(1.4);\n      opacity: 0.75;\n\n      &::before {\n        transform: scale(1.45);\n        opacity: 0.35;\n      }\n    }\n\n    /* &.active {\n      &::before {\n        transform: scale(1.55);\n        opacity: 0;\n      }\n    } */\n\n    pointer-events: none;\n  }\n\n  .mouse-icon {\n    position: absolute;\n    pointer-events: none;\n    width: 1.5em;\n    height: 1.5em;\n\n    opacity: 0.5;\n\n    transition: opacity .2s;\n    animation: mouseanim 4s ease 0s infinite;\n\n    &.hide {\n      opacity: 0;\n    }\n  }\n\n  .curtain {\n    position: absolute;\n    top: 0; left: 0;\n    width: 100%; height: 100%;\n    /* background: white; */\n    background: rgb(64, 38, 25);\n    pointer-events: none;\n\n\n    p {\n      position: absolute;\n      bottom: 150px;\n      left: 50%;\n      transform: translate(-50%, 0);\n\n      font-family: monospace, Helvetica, sans-serif;\n      color: #ddd;\n      text-transform: uppercase;\n      letter-spacing: 0.65px;\n      font-size: 11px;\n      border-bottom: 1px solid white;\n\n      transition: opacity .35s;\n\n      &.hidden {\n        opacity: 0;\n      }\n\n      opacity: 0.5;\n    }\n  }\n\n  .camera-icon {\n    width: 25px; \n    height: 20px;\n  }\n\n  .free-camera-btn {\n    position: absolute;\n    bottom: 20px;\n    left: 20px;\n    /* left: 50%; */\n    /* transform: translate(-50%, 0); */\n    padding: 5px;\n    border: 1px solid rgba(255,255,255, 0.5);\n    box-sizing: border-box;\n    border-radius: 5px;\n\n    display: flex;\n    justify-content: center;\n    align-items: center;\n  \n    p {\n      color: white;\n      font-family: Helvetica, sans-serif;\n      /* text-transform: uppercase; */\n      font-size: 9px;\n      letter-spacing: 0.5px;\n      margin: 0 0 0 7px;\n      text-align: center;\n    }\n\n    opacity: 0.4;\n\n    &:hover {\n      opacity: 1;\n    }\n  }\n\n  @keyframes mouseanim {\n    0% {\n      transform: translate(0, 0px);\n    }\n    80% {\n      transform: translate(0, 0px);\n    } \n    85% {\n      transform: translate(0, 5px);\n    } \n    90% {\n      transform: translate(0, 0px);\n    }\n    95% {\n      transform: translate(0, 5px);\n    }\n    100% {\n      transform: translate(0, 0px);\n    }\n  }\n'])));var _n=function(){var e=Object(i.useRef)();return Object(i.useEffect)((function(){!function(e){Pn.apply(this,arguments)}(e.current)}),[]),Object(An.jsxs)("div",{className:"App",children:[Object(An.jsx)(In,{}),Object(An.jsx)("canvas",{ref:e}),Object(An.jsx)("div",{className:"central-cursor"}),Object(An.jsx)("div",{className:"outer-cursor"}),Object(An.jsx)(Un.b,{color:"white",className:"mouse-icon"}),Object(An.jsxs)("div",{className:"free-camera-btn",children:[Object(An.jsx)(Un.a,{color:"white",className:"camera-icon"})," ",Object(An.jsxs)("p",{children:["Free camera",Object(An.jsx)("br",{}),"OFF"]})]}),Object(An.jsx)("div",{className:"curtain",children:Object(An.jsx)("p",{})})]})};a.a.render(Object(An.jsx)(r.a.StrictMode,{children:Object(An.jsx)(_n,{})}),document.getElementById("root"))}},[[38,1,2]]]);
//# sourceMappingURL=main.63476ff2.chunk.js.map