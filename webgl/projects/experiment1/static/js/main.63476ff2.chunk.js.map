{"version":3,"sources":["graphics-components/blit.js","graphics-components/blitDepth.js","graphics-components/blitPosition.js","graphics-components/blitReflectedColorRT.js","graphics-components/blitReflectionDistance.js","graphics-components/blurReflectionDistance.js","graphics-components/centralParticles.js","graphics-components/computeFog.js","graphics-components/crystals.js","graphics-components/fluidsim.js","utils.js","graphics-components/mainRaycast.js","graphics-components/shaderFragments.js","graphics-components/postProcess.js","materials/mountains.js","materials/reflectable.js","materials/water.js","graphics.js","App.js","index.js"],"names":["Blit","renderer","customFragment","this","material","THREE","uniforms","uTexture","type","value","vertexShader","fragmentShader","depthTest","depthWrite","mesh","camera","scene","add","textureFrom","renderTargetDest","setRenderTarget","render","BlitDepth","side","DoubleSide","overrideMaterial","BlitPosition","uCameraPos","Vector3","position","clone","BlitReflectedColor","uPosition","uPlanePosition","uColor","colorTexture","planePositionTexture","positionTexture","BlitReflectionDistance","uReflectionPosition","reflectionPositionTexture","BlurReflectionDistance","width","height","pr","fb0","WebGLRenderTarget","FloatType","fb1","uInputTexture","uColorTexture","uOriginalTexture","uHorizontal","uStep","uPixelStep","Vector2","blitProgram","reflectionDistanceTexture","i","texture","blit","CentralParticles","waterScene","n","hoverN","particles","push","createParticle","particlesGeo","BufferGeometry","vertices","Float32Array","setAttribute","BufferAttribute","particlesMaterial","ShaderMaterial","transparent","blendEquation","AddEquation","blending","AdditiveBlending","Mesh","clock","Clock","start","raycaster","Raycaster","raycastPoint","raycastDelta","windLevel","window","addEventListener","e","mouse","clientX","innerWidth","clientY","innerHeight","setFromCamera","intersects","intersectObjects","children","intersectionPoint","point","x","y","z","sub","pi","Math","floor","random","sphericalDir","Spherical","PI","setFromSpherical","velocity","multiplyScalar","pow","rotx","roty","rotz","rotxS","rotyS","rotzS","t","radius","accumulatedWindTranslation","age","swirlRadius","swirlSpeed","gravitySpeed","delta","getDelta","length","particle","pos","sin","cos","windTranslation","vIdx","v0","v1","v2","applyEuler","Euler","attributes","array","needsUpdate","ComputeFog","torusesScene","torusesSceneCamera","positionRT","rt0","rt1","torusesMaterial","blurMaterial","fogMaterial","uPositionTexture","uTorusesBloom","uTime","uWind","uFogStartOffset","blackMaterial","MeshBasicMaterial","color","windValue","fogStartOffset","getElapsedTime","Crystals","geo","Color","toneMapped","transl","scale","baselength","base","v3","v4","v5","v6","v7","v8","top","structVerts","forEach","v","lengthBasedT","nt","offset","v9","multiply","v10","v11","v12","sphereActiveTimer","time","center","timeAngleOff","sinSpeed","scaleOffset","smoothstep","clamp","createPartialCrystal","config","SIM_RESOLUTION","DYE_RESOLUTION","CAPTURE_RESOLUTION","DENSITY_DISSIPATION","VELOCITY_DISSIPATION","PRESSURE","PRESSURE_ITERATIONS","CURL","SPLAT_RADIUS","SPLAT_FORCE","SHADING","COLORFUL","COLOR_UPDATE_SPEED","PAUSED","BACK_COLOR","r","g","b","TRANSPARENT","pointerPrototype","id","texcoordX","texcoordY","prevTexcoordX","prevTexcoordY","deltaX","deltaY","down","moved","canvas","pointers","dye","divergence","curl","pressure","splatProgram","curlProgram","vorticityProgram","divergenceProgram","clearProgram","pressureProgram","gradienSubtractProgram","advectionProgram","quadPlaneMesh","framebuffers","initFluidSim","rendererRef","canvasRef","overrideConfig","simRes","getResolution","dyeRes","Error","createDoubleFBO","createFBO","initFramebuffers","read","baseVertexShader","copyShader","uTarget","aspectRatio","correctRadius","splatShader","texelSize","texelSizeX","texelSizeY","uVelocity","curlShader","uCurl","dt","vorticityShader","divergenceShader","clearShader","uDivergence","uPressure","pressureShader","gradientSubtractShader","uSource","dissipation","advectionShader","displayShaderSource","quadPlane","initMaterials","resolution","min","round","max","w","h","filtering","rt","minFilter","magFilter","format","depthBuffer","stencilBuffer","anisotropy","fbo","fbo1","fbo2","write","swap","temp","updateFluidSim","now","Date","lastUpdateTime","calcDeltaTime","ciclingHue","colorUpdateTimer","range","wrap","p","generateColor","updateColors","pointer","dx","dy","splat","splatPointer","step","colorMultiplier","downMiddle","initMouseCommands","posX","scaleByPixelRatio","posY","find","updatePointerDownData","which","touches","distVec","fluidUv","addScalar","updatePointerMoveData","input","pixelRatio","devicePixelRatio","rightKey","middleKey","downRight","correctDeltaX","correctDeltaY","abs","hue","c","s","f","q","HSVtoRGB","last","parseIncludes","string","replace","match","include","ShaderChunk","onceMemory","once","tag","initCentralRaycast","onClick","placeholderScene","Scene","centralSphereGeo","SphereBufferGeometry","centralSphere","set","updateMatrixWorld","clickPt","hover","centralCursorEl","classList","outerCursorEl","upClickPt","remove","outerCursorPos","newCursorPos","setX","setY","setTimeout","mouseIconEl","style","display","contains","document","querySelector","ccr","getBoundingClientRect","ocr","mcr","update","deltatime","left","ndcMousePos","project","saturate","remap","linterp","spectrum_offset","rand","PostProcess","uWindLevel","uSphereActiveTimer","uAspect","uBottomDistortion","uDispersion","mountainsMaterial","map","ReflectableMaterial","userData","uReflect","uReflectPositionPass","reflectable","onBeforeCompile","shader","prependUniforms","join","WaterMaterial","uMountainsDepth","uWaterDepth","uScreenSize","uPixelSize","uBlurredReflectionDistance","uFluidTexture","controls","crystals","PerspectiveCamera","mainFramebuffer","WebGLMultisampleRenderTarget","encoding","sRGBEncoding","displayProgram","uSceneTex","uFluidVelocityTex","uFluidDyeTex","quad","PlaneBufferGeometry","plane","sphere","depthProgram","cursorAPI","planeScene","whiteRocks","mountainsDepthScene","mountainsDepthRT","waterDepthRT","bundledTorusesScene","colorRT","postProcessBuffer","reflectedColorRT","LinearMipmapLinearFilter","LinearFilter","generateMipmaps","positionProgram","reflectionDistanceProgram","blurReflectionDistanceProgram","blitReflectedColorProgram","computeFogProgram","postProcessProgram","reflectionPositionRT","NearestFilter","reflectionDistanceRT","blurDistanceRT","planePositionRT","console","log","curtainEl","cameraInitPosStart","cameraInitPosEnd","cameraPositionAnimT","a","WebGLRenderer","antialias","setSize","toneMapping","CustomToneMapping","outputEncoding","tonemapping_pars_fragment","OrbitControls","target","enableDamping","dampingFactor","rotateSpeed","enableZoom","enablePan","enableRotate","maxPolarAngle","copy","curtainPEl","freeCamera","innerHTML","textContent","GLTFLoader","loadAsync","process","mountainsScene","groups","isle","toruses","TextureLoader","mountainsText","flipY","isleText","name","rock1","rock1Text","rock2","rock2Text","rock3","rock3Text","rock4","rock4Text","astronaut","astronautText","traverse","o","translateX","translateY","translateZ","rotateX","rotateY","rotateZ","updateMatrix","geometry","applyMatrix","matrix","rotation","torusesGeometries","MeshStandardMaterial","emissive","emissiveIntensity","bundledTorusesGeometries","mergeBufferGeometries","bundledToruses","pmremGenerator","PMREMGenerator","cubemapRT","fromScene","sphereText","metalness","envMap","envMapIntensity","state","sphereActive","sphereClickTimer","setAnimationLoop","loop","reflectMaterials","setReflectPositionPass","lerp","opacity","fogTime","setWindLevel","transSpeed","transAmt","rot","roughness","blitPosition","blitReflectedColor","blitReflectionDistance","blur","blitDepth","fluidSimFramebuffers","autoClear","compute","GlobalStyles","createGlobalStyle","App","useRef","useEffect","initThree","current","className","ref","ReactDOM","StrictMode","getElementById"],"mappings":"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","file":"static/js/main.63476ff2.chunk.js","sourcesContent":["import * as THREE from \"three\";\r\n\r\nexport default class Blit {\r\n    constructor(renderer, customFragment) {\r\n        this.material = new THREE.ShaderMaterial({\r\n            uniforms: {\r\n                uTexture: { type: \"t\", value: null }\r\n            },\r\n            \r\n            vertexShader: `\r\n                varying vec2 vUv;\r\n\r\n                void main() {\r\n                    vUv = uv;\r\n                    gl_Position = vec4(position.xy, 0.0, 1.0);    \r\n                }\r\n            `,\r\n\r\n            fragmentShader: `\r\n                uniform sampler2D uTexture;\r\n\r\n                varying vec2 vUv;\r\n\r\n                void main() {\r\n                    ${ customFragment ? customFragment : \"gl_FragColor = texture2D(uTexture, vUv);\" }  \r\n                }\r\n            `,\r\n\r\n            depthTest:  false,\r\n            depthWrite: false,\r\n        });\r\n\r\n        this.mesh = new THREE.Mesh(new THREE.PlaneBufferGeometry(2,2), this.material);\r\n        this.camera = new THREE.PerspectiveCamera( 45, 1 /* remember that the camera is worthless here */, 1, 1000 );\r\n        this.renderer = renderer;\r\n\r\n        this.scene = new THREE.Scene();\r\n        this.scene.add(this.mesh);\r\n    }\r\n\r\n    blit(textureFrom, renderTargetDest) {\r\n        this.renderer.setRenderTarget(renderTargetDest);\r\n\r\n        this.material.uniforms.uTexture.value = textureFrom;\r\n        this.renderer.render(this.scene, this.camera);\r\n\r\n        this.renderer.setRenderTarget(null);\r\n    }\r\n}","import * as THREE from \"three\";\r\nimport { DoubleSide } from \"three\";\r\n\r\nexport default class BlitDepth {\r\n    constructor(renderer, scene, camera) {\r\n        this.material = new THREE.ShaderMaterial({\r\n            uniforms: {\r\n                uTexture: { type: \"t\", value: null }\r\n            },\r\n            \r\n            vertexShader: `\r\n                varying float vDepth;\r\n\r\n                void main() {\r\n                    vDepth = - (modelViewMatrix * vec4(position, 1.0)).z;  \r\n                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);    \r\n                }\r\n            `,\r\n\r\n            fragmentShader: `\r\n                varying float vDepth;\r\n\r\n                void main() {\r\n                    gl_FragColor = vec4(vDepth, vDepth, vDepth, 1.0);\r\n                }\r\n            `,\r\n\r\n            side: DoubleSide,\r\n        });\r\n\r\n        this.renderer = renderer;\r\n        this.scene = scene;\r\n        this.camera = camera;\r\n    }\r\n\r\n    blitDepth(renderTargetDest) {\r\n        this.renderer.setRenderTarget(renderTargetDest);\r\n\r\n        this.scene.overrideMaterial = this.material;\r\n        this.renderer.render(this.scene, this.camera);\r\n        this.scene.overrideMaterial = null;\r\n\r\n        this.renderer.setRenderTarget(null);\r\n    }\r\n}","import * as THREE from \"three\";\r\nimport { DoubleSide, Vector3 } from \"three\";\r\n\r\nexport default class BlitPosition {\r\n    constructor(renderer, scene, camera) {\r\n        this.material = new THREE.ShaderMaterial({\r\n            uniforms: {\r\n                uTexture: { type: \"t\", value: null },\r\n                uCameraPos: { value: new Vector3(0,0,0) },\r\n            },\r\n            \r\n            vertexShader: `\r\n                varying vec3 vPosition;\r\n\r\n                void main() {\r\n                    vPosition = (modelMatrix * vec4(position, 1.0)).xyz;  \r\n                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);    \r\n                }\r\n            `,\r\n\r\n            fragmentShader: `\r\n                varying vec3 vPosition;\r\n\r\n                uniform vec3 uCameraPos;\r\n\r\n                void main() {\r\n                    float depth = length(vPosition - uCameraPos);\r\n                    gl_FragColor = vec4(vPosition, depth);\r\n                }\r\n            `,\r\n\r\n            side: DoubleSide,\r\n        });\r\n\r\n        this.renderer = renderer;\r\n        this.scene = scene;\r\n        this.camera = camera;\r\n    }\r\n\r\n    blitPosition(renderTargetDest) {\r\n        this.renderer.setRenderTarget(renderTargetDest);\r\n\r\n        this.material.uniforms.uCameraPos.value = this.camera.position.clone();\r\n\r\n        this.scene.overrideMaterial = this.material;\r\n        this.renderer.render(this.scene, this.camera);\r\n        this.scene.overrideMaterial = null;\r\n\r\n        this.renderer.setRenderTarget(null);\r\n    }\r\n}","import * as THREE from \"three\";\r\n\r\nexport default class BlitReflectedColor {\r\n    constructor(renderer) {\r\n        this.material = new THREE.ShaderMaterial({\r\n            uniforms: {\r\n                uPosition: { type: \"t\", value: null },\r\n                uPlanePosition: { type: \"t\", value: null },\r\n                uColor: { type: \"t\", value: null },\r\n            },\r\n            \r\n            vertexShader: `\r\n                varying vec2 vUv;\r\n\r\n                void main() {\r\n                    vUv = uv;\r\n                    gl_Position = vec4(position.xy, 0.0, 1.0);    \r\n                }\r\n            `,\r\n\r\n            fragmentShader: `\r\n                uniform sampler2D uPosition;\r\n                uniform sampler2D uPlanePosition;\r\n                uniform sampler2D uColor;\r\n\r\n                varying vec2 vUv;\r\n\r\n                void main() {   \r\n                    vec3 position = texture2D(uPosition, vUv).xyz;\r\n                    vec3 planePosition = texture2D(uPlanePosition, vUv).xyz;\r\n                    vec3 color = texture2D(uColor, vUv).xyz;\r\n\r\n                    // this is necessary to only blit the reflections of the plane \r\n                    if(planePosition != position) color = vec3(0.0);\r\n\r\n                    gl_FragColor = vec4(color, 1.0);\r\n                }\r\n            `,\r\n\r\n            depthTest:  false,\r\n            depthWrite: false,\r\n        });\r\n\r\n        this.mesh = new THREE.Mesh(new THREE.PlaneBufferGeometry(2,2), this.material);\r\n        this.camera = new THREE.PerspectiveCamera( 45, 1 /* remember that the camera is worthless here */, 1, 1000 );\r\n        this.renderer = renderer;\r\n\r\n        this.scene = new THREE.Scene();\r\n        this.scene.add(this.mesh);\r\n    }\r\n\r\n    blitReflectedColor(colorTexture, planePositionTexture, positionTexture, renderTargetDest) {\r\n        this.renderer.setRenderTarget(renderTargetDest);\r\n\r\n        this.material.uniforms.uPosition.value = positionTexture;\r\n        this.material.uniforms.uPlanePosition.value = planePositionTexture;\r\n        this.material.uniforms.uColor.value = colorTexture;\r\n        this.renderer.render(this.scene, this.camera);\r\n\r\n        this.renderer.setRenderTarget(null);\r\n    }\r\n}","import * as THREE from \"three\";\r\n\r\nexport default class BlitReflectionDistance {\r\n    constructor(renderer) {\r\n        this.material = new THREE.ShaderMaterial({\r\n            uniforms: {\r\n                uPosition: { type: \"t\", value: null },\r\n                uPlanePosition: { type: \"t\", value: null },\r\n                uReflectionPosition: { type: \"t\", value: null },\r\n            },\r\n            \r\n            vertexShader: `\r\n                varying vec2 vUv;\r\n\r\n                void main() {\r\n                    vUv = uv;\r\n                    gl_Position = vec4(position.xy, 0.0, 1.0);    \r\n                }\r\n            `,\r\n\r\n            fragmentShader: `\r\n                uniform sampler2D uPosition;\r\n                uniform sampler2D uPlanePosition;\r\n                uniform sampler2D uReflectionPosition;\r\n\r\n                varying vec2 vUv;\r\n\r\n                void main() {   \r\n                    vec3 position = texture2D(uPosition, vUv).xyz;\r\n                    vec3 planePosition = texture2D(uPlanePosition, vUv).xyz;\r\n                    vec3 reflectedPosition = texture2D(uReflectionPosition, vUv).xyz;\r\n\r\n                    float distance = length(reflectedPosition - planePosition);\r\n                    if(reflectedPosition == vec3(0.0)) distance = 0.0;\r\n                    \r\n                    // this is necessary to only blit the reflections of the plane \r\n                    if(planePosition != position) distance = 0.0;\r\n\r\n                    gl_FragColor = vec4(vec3(distance), 1.0);\r\n                }\r\n            `,\r\n\r\n            depthTest:  false,\r\n            depthWrite: false,\r\n        });\r\n\r\n        this.mesh = new THREE.Mesh(new THREE.PlaneBufferGeometry(2,2), this.material);\r\n        this.camera = new THREE.PerspectiveCamera( 45, 1 /* remember that the camera is worthless here */, 1, 1000 );\r\n        this.renderer = renderer;\r\n\r\n        this.scene = new THREE.Scene();\r\n        this.scene.add(this.mesh);\r\n    }\r\n\r\n    blitReflectionDistance(reflectionPositionTexture, planePositionTexture, positionTexture, renderTargetDest) {\r\n        this.renderer.setRenderTarget(renderTargetDest);\r\n\r\n        this.material.uniforms.uPosition.value = positionTexture;\r\n        this.material.uniforms.uPlanePosition.value = planePositionTexture;\r\n        this.material.uniforms.uReflectionPosition.value = reflectionPositionTexture;\r\n        this.renderer.render(this.scene, this.camera);\r\n\r\n        this.renderer.setRenderTarget(null);\r\n    }\r\n}","import * as THREE from \"three\";\r\nimport { FloatType, Vector2, WebGLRenderTarget } from \"three\";\r\nimport Blit from \"./blit\";\r\n\r\nexport default class BlurReflectionDistance {\r\n    constructor(renderer, width, height) {\r\n        let pr = 0.45;\r\n\r\n        this.fb0 = new WebGLRenderTarget(width * pr, height * pr, { type: FloatType });\r\n        this.fb1 = new WebGLRenderTarget(width * pr, height * pr, { type: FloatType });\r\n\r\n        this.material = new THREE.ShaderMaterial({\r\n            uniforms: {\r\n                uInputTexture: { type: \"t\", value: null },\r\n                uColorTexture: { type: \"t\", value: null },\r\n                uOriginalTexture: { type: \"t\", value: null },\r\n                uHorizontal: { value: false },\r\n                uStep: { value: 1 },\r\n                uPixelStep: { value: new Vector2(1 / (width * pr), 1 / (height * pr)) },\r\n            },\r\n            \r\n            vertexShader: `\r\n                varying vec2 vUv;\r\n\r\n                void main() {\r\n                    vUv = uv;\r\n                    gl_Position = vec4(position.xy, 0.0, 1.0);    \r\n                }\r\n            `,\r\n\r\n            fragmentShader: `\r\n                uniform sampler2D uInputTexture;\r\n                uniform sampler2D uOriginalTexture;\r\n                uniform sampler2D uColorTexture;\r\n\r\n                uniform vec2 uPixelStep;\r\n                uniform bool uHorizontal;\r\n                uniform float uStep;\r\n\r\n                varying vec2 vUv;\r\n\r\n                float weight[5] = float[] (0.227027, 0.1945946, 0.1216216, 0.054054, 0.016216);\r\n\r\n                void main() {   \r\n                    \r\n\r\n                    // prendi il valore mediano e poi basi il blur radius su quello\r\n                    float average = 0.0;\r\n                    for(int i = -4; i <= +4; i++) {\r\n                        vec2 offs = vec2(0.0); \r\n\r\n                        if(uHorizontal)  offs = vec2(uPixelStep.x * float(i) * (1.0 + uStep * 1.0), 0.0);\r\n                        if(!uHorizontal) offs = vec2(0.0, uPixelStep.x * float(i) * (1.0 + uStep * 1.0));\r\n\r\n                        // if(uHorizontal)  offs = vec2(uPixelStep.x * float(i), 0.0);\r\n                        // if(!uHorizontal) offs = vec2(0.0, uPixelStep.x * float(i));\r\n\r\n                        // USING ORIGINAL TEXTURE\r\n                        // USING ORIGINAL TEXTURE\r\n                        // USING ORIGINAL TEXTURE\r\n                        // USING ORIGINAL TEXTURE\r\n                        // USING ORIGINAL TEXTURE\r\n                        float value = texture2D(uOriginalTexture, vUv + offs).x;\r\n\r\n                        average += value;\r\n                    }\r\n                    average /= 9.0;\r\n\r\n\r\n                    // float blurRadius = 0.25 + average * 15.0;\r\n                    float blurRadius = 0.125 + average * 7.5;\r\n\r\n\r\n                    // float accum = 0.0;\r\n                    // for(int i = -4; i <= +4; i++) {\r\n                    //     vec2 offs = vec2(0.0); \r\n\r\n                    //     if(uHorizontal)  offs = vec2(uPixelStep.x * float(i) * blurRadius, 0.0);\r\n                    //     if(!uHorizontal) offs = vec2(0.0, uPixelStep.x * float(i) * blurRadius);\r\n\r\n                    //     float value = texture2D(uInputTexture, vUv + offs).x;\r\n                        \r\n                    //     float weightedValue = 0.0;\r\n                    //     if(i < 0) weightedValue = value * weight[abs(i)];\r\n                    //     if(i > 0) weightedValue = value * weight[i];\r\n                    //     if(i == 0) weightedValue = value * weight[0];\r\n\r\n                    //     accum += weightedValue;\r\n                    // }\r\n                    \r\n                    // gl_FragColor = vec4(vec3(accum), 1.0);\r\n\r\n\r\n                    vec3 accum = vec3(0.0);\r\n                    for(int i = -4; i <= +4; i++) {\r\n                        vec2 offs = vec2(0.0); \r\n\r\n                        if(uHorizontal)  offs = vec2(uPixelStep.x * float(i) * blurRadius, 0.0);\r\n                        if(!uHorizontal) offs = vec2(0.0, uPixelStep.x * float(i) * blurRadius);\r\n\r\n                        vec3 value = texture2D(uInputTexture, vUv + offs).xyz;\r\n                        \r\n                        vec3 weightedValue = vec3(0.0);\r\n                        if(i < 0) weightedValue = value * weight[abs(i)];\r\n                        if(i > 0) weightedValue = value * weight[i];\r\n                        if(i == 0) weightedValue = value * weight[0];\r\n\r\n                        accum += weightedValue;\r\n                    }\r\n                    \r\n                    gl_FragColor = vec4(accum, 1.0);\r\n                }\r\n            `,\r\n\r\n            depthTest:  false,\r\n            depthWrite: false,\r\n        });\r\n\r\n        this.mesh = new THREE.Mesh(new THREE.PlaneBufferGeometry(2,2), this.material);\r\n        this.camera = new THREE.PerspectiveCamera( 45, 1 /* remember that the camera is worthless here */, 1, 1000 );\r\n        this.renderer = renderer;\r\n\r\n        this.scene = new THREE.Scene();\r\n        this.scene.add(this.mesh);\r\n        \r\n        this.blitProgram = new Blit(renderer);\r\n    }\r\n\r\n    blur(reflectionDistanceTexture, colorTexture, renderTargetDest) {\r\n\r\n        this.material.uniforms.uOriginalTexture.value = reflectionDistanceTexture;\r\n        this.material.uniforms.uColorTexture.value = colorTexture;\r\n\r\n        // ping pong blur\r\n        for(let i = 0; i < 7; i++) {\r\n            this.material.uniforms.uStep.value = 1 + i;\r\n\r\n            // horizontal pass\r\n            this.renderer.setRenderTarget(this.fb0);\r\n            this.material.uniforms.uHorizontal.value = true;\r\n            // this.material.uniforms.uHorizontal.value = i % 2 == 0;\r\n            this.material.uniforms.uInputTexture.value = this.fb1.texture;\r\n            // if(i === 0) this.material.uniforms.uInputTexture.value = reflectionDistanceTexture;\r\n            if(i === 0) this.material.uniforms.uInputTexture.value = colorTexture;\r\n            this.renderer.render(this.scene, this.camera);\r\n        \r\n            // vertical pass\r\n            this.renderer.setRenderTarget(this.fb1);\r\n            this.material.uniforms.uHorizontal.value = false;\r\n            this.material.uniforms.uInputTexture.value = this.fb0.texture;\r\n            this.renderer.render(this.scene, this.camera);\r\n        }\r\n\r\n        this.blitProgram.blit(this.fb1.texture, renderTargetDest);\r\n    }\r\n}","import { AddEquation, AdditiveBlending, BufferAttribute, CustomBlending, DoubleSide, Euler, OneFactor, ShaderMaterial } from \"three\";\r\nimport { Mesh } from \"three\";\r\nimport { Raycaster } from \"three\";\r\nimport { Vector2 } from \"three\";\r\nimport { Clock } from \"three\";\r\nimport { BufferGeometry } from \"three\";\r\nimport { Spherical } from \"three\";\r\nimport { Vector3 } from \"three\";\r\n\r\nexport default class CentralParticles {\r\n  constructor(camera, waterScene) {\r\n    \r\n    let n = 800;\r\n    this.hoverN = 200;\r\n    this.particles = [];\r\n    for(let i = 0; i < n; i++) {\r\n      this.particles.push(this.createParticle());\r\n    }\r\n\r\n    this.particlesGeo = new BufferGeometry();\r\n    const vertices = new Float32Array(n * 9);\r\n    this.particlesGeo.setAttribute( 'position', new BufferAttribute( vertices, 3 ) );\r\n\r\n\r\n    this.particlesMaterial = new ShaderMaterial({\r\n      vertexShader: `\r\n      varying vec3 vWorldPos;\r\n\r\n      void main() {\r\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);    \r\n        vWorldPos = (modelMatrix * vec4(position, 1.0)).xyz;\r\n      }\r\n      `,\r\n\r\n      fragmentShader: `\r\n      varying vec3 vWorldPos;\r\n     \r\n      void main() {   \r\n\r\n        // vec3 sphereCenter = vec3(0.71, -0.13, -0.05);\r\n        // vec3 dir = normalize(vWorldPos - sphereCenter);\r\n\r\n        // float d = clamp(dot(dir, vec3(1.0, -0.75, -0.8)), 0.0, 1.0);\r\n        // d = pow(d, 6.0);\r\n        // d = clamp(d, 0.0, 0.75);\r\n\r\n        gl_FragColor = vec4(1.0, 0.5, 0.5, 0.8);\r\n        // gl_FragColor = vec4(vec3(1.0, 0.5, 0.5) * (1.0 - d), 0.8);\r\n      }\r\n      `,\r\n\r\n      side: DoubleSide,\r\n      transparent: true,\r\n      blendEquation: AddEquation,\r\n      blending: AdditiveBlending,\r\n    });\r\n\r\n    this.mesh = new Mesh(this.particlesGeo, this.particlesMaterial);\r\n    this.clock = new Clock();\r\n    this.clock.start();\r\n\r\n    const raycaster = new Raycaster();\r\n    this.raycastPoint = new Vector3(0,0,0);\r\n    this.raycastDelta = new Vector3(0,0,0);\r\n    this.windLevel = 0;\r\n\r\n    window.addEventListener(\"mousemove\", (e) => {\r\n      let mouse = new Vector2(\r\n        ( e.clientX / window.innerWidth ) * 2 - 1,\r\n        - ( e.clientY / window.innerHeight ) * 2 + 1,\r\n      );\r\n      raycaster.setFromCamera( mouse, camera );\r\n      const intersects = raycaster.intersectObjects( waterScene.children );\r\n      if(intersects[0]) {\r\n        let intersectionPoint = intersects[0].point;\r\n\r\n        if(this.raycastPoint.x == 0 && this.raycastPoint.y == 0 && this.raycastPoint.z == 0) {\r\n          this.raycastPoint = intersectionPoint;\r\n        } else {\r\n          this.raycastDelta = this.raycastPoint.clone().sub(intersectionPoint);\r\n          this.raycastPoint = intersectionPoint;\r\n\r\n          for(let i = 0; i < 2; i++) {\r\n            let pi = Math.floor(Math.random() * this.hoverN) + (n - this.hoverN);\r\n            if(pi >= n) pi = n - 1;\r\n            if(pi <= 0) pi = 0;\r\n\r\n            let sphericalDir = new Spherical(\r\n              0.025 + Math.random() * 0.1, \r\n              Math.random() * Math.PI, \r\n              Math.random() * 2 * Math.PI);\r\n\r\n            this.particles[pi] = this.createParticle();\r\n            this.particles[pi].position = this.raycastPoint.clone().add(\r\n              new Vector3().setFromSpherical(sphericalDir).add(new Vector3(0, 0.05, 0))\r\n            );\r\n            this.particles[pi].velocity = this.raycastDelta.clone().multiplyScalar(-(Math.random() * 1.0 + 0.5) * 0.5);\r\n          }\r\n        }\r\n      }\r\n    });\r\n  }\r\n\r\n  createParticle() {\r\n    let sphericalDir = new Spherical(\r\n      // Math.random() * 1 + 0.07, \r\n      0.35 + Math.pow(Math.random() * 1, 1), \r\n      Math.random() * Math.PI, \r\n      Math.random() * 2 * Math.PI);\r\n\r\n    return {\r\n      position: new Vector3()\r\n                .setFromSpherical(sphericalDir)\r\n                .add(new Vector3(0.71, -0.13, -0.05)),\r\n      velocity: new Vector3(0,0,0),\r\n      rotx: 0,\r\n      roty: 0,\r\n      rotz: 0,\r\n      rotxS: Math.random() * 0.02,\r\n      rotyS: Math.random() * 0.02,\r\n      rotzS: Math.random() * 0.02,\r\n      t: 0,\r\n      // radius: 0.01 + Math.random() * 0.025,\r\n      radius: 0.013 + Math.random() * 0.035,\r\n\r\n      accumulatedWindTranslation: 0,\r\n      age: Math.random() * 20,\r\n\r\n      swirlRadius: Math.random() * 0.001,\r\n      swirlSpeed: Math.random() * 0.7 + 0.3,\r\n      gravitySpeed: Math.random() * 0.01 + Math.random() * 0.002,\r\n    };\r\n  }\r\n\r\n  setWindLevel(value) {\r\n    this.windLevel = value;\r\n  }\r\n\r\n  update() {\r\n    let delta = this.clock.getDelta();\r\n\r\n    let n = this.particles.length;\r\n\r\n    for(let i = 0; i < n; i++) {\r\n      // reset particle\r\n      if(\r\n        (\r\n          this.particles[i].position.y < -0.5 || \r\n          this.particles[i].age > 20\r\n          // this.particles[i].accumulatedWindTranslation > 0.02 \r\n        ) && \r\n        i <= (n - this.hoverN) /* i > this.hoverN will be treated differently */\r\n      ) {\r\n        let sphericalDir = new Spherical(\r\n          // Math.random() * 1 + 0.07, \r\n          0.35 + Math.pow(Math.random() * 1, 1), \r\n          Math.random() * Math.PI, \r\n          Math.random() * 2 * Math.PI);\r\n  \r\n        this.particles[i] = this.createParticle();\r\n      }\r\n\r\n      let particle = this.particles[i];\r\n      let pos = particle.position;\r\n      particle.rotx += particle.rotxS;\r\n      particle.roty += particle.rotyS;\r\n      particle.rotz += particle.rotzS;\r\n\r\n      particle.age += delta;\r\n\r\n      particle.t += delta;\r\n      particle.position.add(\r\n        new Vector3(\r\n          Math.sin(particle.t * particle.swirlSpeed) * particle.swirlRadius, \r\n          -particle.gravitySpeed * delta, \r\n          Math.cos(particle.t * particle.swirlSpeed) * particle.swirlRadius\r\n        )\r\n      );\r\n\r\n      // add wind\r\n      if(this.windLevel > 0) {\r\n        let windTranslation = this.windLevel * 0.15;\r\n        // particle.accumulatedWindTranslation += windTranslation;\r\n        particle.position.add(new Vector3(windTranslation, 0, 0));\r\n      }\r\n\r\n      // perturb velocity\r\n      particle.position.add(particle.velocity);\r\n      particle.velocity.multiplyScalar(0.985);\r\n\r\n      let vIdx = i * 9;\r\n      let v0 = new Vector3(-0.1, 0.0, 0).multiplyScalar(particle.radius);\r\n      let v1 = new Vector3(+0.1, 0.0, 0).multiplyScalar(particle.radius);\r\n      let v2 = new Vector3(0.1, 0.15, 0).multiplyScalar(particle.radius);\r\n\r\n      v0.applyEuler(new Euler(particle.rotx, particle.roty, particle.rotz));\r\n      v1.applyEuler(new Euler(particle.rotx, particle.roty, particle.rotz));\r\n      v2.applyEuler(new Euler(particle.rotx, particle.roty, particle.rotz));\r\n\r\n      this.particlesGeo.attributes.position.array[vIdx + 0] = v0.x + pos.x;\r\n      this.particlesGeo.attributes.position.array[vIdx + 1] = v0.y + pos.y;\r\n      this.particlesGeo.attributes.position.array[vIdx + 2] = v0.z + pos.z;\r\n      \r\n      this.particlesGeo.attributes.position.array[vIdx + 3] = v1.x + pos.x;\r\n      this.particlesGeo.attributes.position.array[vIdx + 4] = v1.y + pos.y;\r\n      this.particlesGeo.attributes.position.array[vIdx + 5] = v1.z + pos.z;\r\n      \r\n      this.particlesGeo.attributes.position.array[vIdx + 6] = v2.x + pos.x;\r\n      this.particlesGeo.attributes.position.array[vIdx + 7] = v2.y + pos.y;\r\n      this.particlesGeo.attributes.position.array[vIdx + 8] = v2.z + pos.z;\r\n    }\r\n  \r\n    this.particlesGeo.attributes.position.needsUpdate = true;\r\n  }\r\n  \r\n}","import * as THREE from \"three\";\r\nimport { MeshBasicMaterial } from \"three\";\r\nimport { FloatType, WebGLRenderTarget } from \"three\";\r\nimport { Vector3, Vector2 } from \"three\";\r\n\r\nexport default class ComputeFog {\r\n  constructor(renderer, width, height, torusesScene, torusesSceneCamera, positionRT, blitProgram) {\r\n    this.rt0 = new WebGLRenderTarget(\r\n      Math.floor(width * 0.25),\r\n      Math.floor(height * 0.25),\r\n      { type: FloatType }\r\n    );\r\n    this.rt1 = new WebGLRenderTarget(\r\n      Math.floor(width * 0.25),\r\n      Math.floor(height * 0.25),\r\n      { type: FloatType }\r\n    );\r\n\r\n    // this.fogMaskRT = new WebGLRenderTarget(width, height);\r\n\r\n    this.torusesScene = torusesScene;\r\n    this.torusesSceneCamera = torusesSceneCamera;\r\n    this.blitProgram = blitProgram;\r\n\r\n    this.torusesMaterial = new THREE.ShaderMaterial({\r\n      vertexShader: `\r\n      varying vec3 vWorldPos;\r\n\r\n      void main() {\r\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);    \r\n        vWorldPos = (modelMatrix * vec4(position, 1.0)).xyz;\r\n      }\r\n      `,\r\n\r\n      fragmentShader: `\r\n      varying vec3 vWorldPos;\r\n   \r\n      void main() {   \r\n        if(vWorldPos.y < -0.46) discard;\r\n\r\n        gl_FragColor = vec4(1.0);\r\n      }\r\n      `\r\n    });\r\n      \r\n    this.blurMaterial = new THREE.ShaderMaterial({\r\n      uniforms: {\r\n        uTexture: { type: \"t\", value: null },\r\n        uHorizontal: { value: false },\r\n        uStep: { value: 1 },\r\n        uPixelStep: { value: new Vector2(1 / width, 1 / height) },\r\n      },\r\n\r\n      vertexShader: `\r\n      varying vec2 vUv;\r\n\r\n      void main() {\r\n          vUv = uv;\r\n          gl_Position = vec4(position.xy, 0.0, 1.0);    \r\n      }\r\n      `,\r\n\r\n      fragmentShader: `\r\n      uniform sampler2D uTexture;\r\n\r\n      uniform vec2 uPixelStep;\r\n      uniform bool uHorizontal;\r\n      uniform float uStep;\r\n\r\n      varying vec2 vUv;\r\n\r\n      float weight[5] = float[] (0.227027, 0.1945946, 0.1216216, 0.054054, 0.016216);\r\n\r\n      void main() {   \r\n          float blurRadius = 2.0 + uStep * 9.5;\r\n\r\n          vec3 accum = vec3(0.0);\r\n          for(int i = -4; i <= +4; i++) {\r\n              vec2 offs = vec2(0.0); \r\n\r\n              if(uHorizontal)  offs = vec2(uPixelStep.x * float(i) * blurRadius, 0.0);\r\n              if(!uHorizontal) offs = vec2(0.0, uPixelStep.x * float(i) * blurRadius);\r\n\r\n              vec3 value = texture2D(uTexture, vUv + offs).xyz;\r\n              \r\n              vec3 weightedValue = vec3(0.0);\r\n              if(i < 0) weightedValue = value * weight[abs(i)];\r\n              if(i > 0) weightedValue = value * weight[i];\r\n              if(i == 0) weightedValue = value * weight[0];\r\n\r\n              accum += weightedValue * 0.7;\r\n\r\n              vec3 value2 = texture2D(uTexture, vUv + offs * 0.2).xyz;\r\n              vec3 weightedValue2 = vec3(0.0);\r\n              if(i < 0) weightedValue2 = value2 * weight[abs(i)];\r\n              if(i > 0) weightedValue2 = value2 * weight[i];\r\n              if(i == 0) weightedValue2 = value2 * weight[0];\r\n              accum += weightedValue2 * 0.3;\r\n\r\n\r\n          }\r\n          \r\n          gl_FragColor = vec4(accum, 1.0);\r\n      }\r\n            `,\r\n\r\n      depthTest: false,\r\n      depthWrite: false,\r\n    });\r\n\r\n    this.fogMaterial = new THREE.ShaderMaterial({\r\n      uniforms: {\r\n        // uFogMask: { type: \"t\", value: this.fogMaskRT.texture },\r\n        uColorTexture: { type: \"t\", value: null },\r\n        uPositionTexture: { type: \"t\", value: positionRT.texture },\r\n        uTorusesBloom: { type: \"t\", value: null },\r\n        uCameraPos: { value: new Vector3(0,0,0) },\r\n        uTime: { value: 0 },\r\n        uWind: { value: 0 },\r\n        uFogStartOffset: { value: 0 },\r\n      },\r\n\r\n      vertexShader: `\r\n      varying vec2 vUv;\r\n\r\n      void main() {\r\n          vUv = uv;\r\n          gl_Position = vec4(position.xy, 0.0, 1.0);    \r\n      }\r\n      `,\r\n\r\n      fragmentShader: `\r\n      varying vec2 vUv;\r\n      \r\n      uniform sampler2D uColorTexture;\r\n      uniform sampler2D uTorusesBloom;\r\n      uniform sampler2D uPositionTexture;\r\n      // uniform sampler2D uFogMask;\r\n      \r\n      uniform vec3 uCameraPos;\r\n      uniform float uTime;\r\n      uniform float uWind;\r\n      uniform float uFogStartOffset;\r\n\r\n    /* discontinuous pseudorandom uniformly distributed in [-0.5, +0.5]^3 */\r\nvec3 random3(vec3 c) {\r\n\tfloat j = 4096.0*sin(dot(c,vec3(17.0, 59.4, 15.0)));\r\n\tvec3 r;\r\n\tr.z = fract(512.0*j);\r\n\tj *= .125;\r\n\tr.x = fract(512.0*j);\r\n\tj *= .125;\r\n\tr.y = fract(512.0*j);\r\n\treturn r-0.5;\r\n}\r\n\r\nconst float F3 =  0.3333333;\r\nconst float G3 =  0.1666667;\r\n\r\n/* 3d simplex noise */\r\nfloat simplex3d(vec3 p) {\r\n\t vec3 s = floor(p + dot(p, vec3(F3)));\r\n\t vec3 x = p - s + dot(s, vec3(G3));\r\n\t vec3 e = step(vec3(0.0), x - x.yzx);\r\n\t vec3 i1 = e*(1.0 - e.zxy);\r\n\t vec3 i2 = 1.0 - e.zxy*(1.0 - e);\r\n\t vec3 x1 = x - i1 + G3;\r\n\t vec3 x2 = x - i2 + 2.0*G3;\r\n\t vec3 x3 = x - 1.0 + 3.0*G3;\r\n\t vec4 w, d;\r\n\t w.x = dot(x, x);\r\n\t w.y = dot(x1, x1);\r\n\t w.z = dot(x2, x2);\r\n\t w.w = dot(x3, x3);\r\n\t w = max(0.6 - w, 0.0);\r\n\t d.x = dot(random3(s), x);\r\n\t d.y = dot(random3(s + i1), x1);\r\n\t d.z = dot(random3(s + i2), x2);\r\n\t d.w = dot(random3(s + 1.0), x3);\r\n\t w *= w;\r\n\t w *= w;\r\n\t d *= w;\r\n\t return dot(d, vec4(52.0));\r\n}\r\nconst mat3 rot1 = mat3(-0.37, 0.36, 0.85,-0.14,-0.93, 0.34,0.92, 0.01,0.4);\r\nconst mat3 rot2 = mat3(-0.55,-0.39, 0.74, 0.33,-0.91,-0.24,0.77, 0.12,0.63);\r\nconst mat3 rot3 = mat3(-0.71, 0.52,-0.47,-0.08,-0.72,-0.68,-0.7,-0.45,0.56);\r\nfloat simplex3d_fractal(vec3 m) {\r\n    return   0.5333333*simplex3d(m*rot1)\r\n\t\t\t+0.2666667*simplex3d(2.0*m*rot2)\r\n\t\t\t+0.1333333*simplex3d(4.0*m*rot3)\r\n\t\t\t+0.0666667*simplex3d(8.0*m);\r\n}\r\n\r\nvec3 hueShift( vec3 color, float hueAdjust ){\r\n  const vec3  kRGBToYPrime = vec3 (0.299, 0.587, 0.114);\r\n  const vec3  kRGBToI      = vec3 (0.596, -0.275, -0.321);\r\n  const vec3  kRGBToQ      = vec3 (0.212, -0.523, 0.311);\r\n  const vec3  kYIQToR     = vec3 (1.0, 0.956, 0.621);\r\n  const vec3  kYIQToG     = vec3 (1.0, -0.272, -0.647);\r\n  const vec3  kYIQToB     = vec3 (1.0, -1.107, 1.704);\r\n  float   YPrime  = dot (color, kRGBToYPrime);\r\n  float   I       = dot (color, kRGBToI);\r\n  float   Q       = dot (color, kRGBToQ);\r\n  float   hue     = atan (Q, I);\r\n  float   chroma  = sqrt (I * I + Q * Q);\r\n  hue += hueAdjust;\r\n  Q = chroma * sin (hue);\r\n  I = chroma * cos (hue);\r\n  vec3    yIQ   = vec3 (YPrime, I, Q);\r\n  return vec3( dot (yIQ, kYIQToR), dot (yIQ, kYIQToG), dot (yIQ, kYIQToB) );\r\n}\r\n\r\n      void main() {   \r\n        vec3 color = texture2D(uColorTexture, vUv).xyz;\r\n        vec3 torusesColor = texture2D(uTorusesBloom, vUv).xyz;\r\n        vec3 position = texture2D(uPositionTexture, vUv).xyz;\r\n        // float fogMask = 1.0 - texture2D(uFogMask, vUv).x;\r\n\r\n        if(position == vec3(0.0)) position = vec3(100.0);\r\n     \r\n        // float distFromCenter = length(position);\r\n        // if(distFromCenter > 3.5) {\r\n        //   float t = (distFromCenter - 3.5) / 2.0;\r\n        //   position += normalize(position - uCameraPos) * 20.0 * t;\r\n        // }\r\n\r\n        vec3 dir = normalize(uCameraPos - position);\r\n        float distance = length(uCameraPos - position);\r\n        float particles = 0.0;\r\n        int steps = 10;\r\n        float fogStart = 3.5 + uFogStartOffset;\r\n        vec3 rd = dir;\r\n        vec3 ro = uCameraPos + rd * fogStart;\r\n        if(distance > fogStart) {\r\n          float stepDistance = (distance - fogStart) / float(steps);\r\n          for(int i = 0; i < steps; i++) {\r\n            float dist = stepDistance * float(i);\r\n            vec3 p = ro + rd * (fogStart + dist);\r\n\r\n            float nv = (simplex3d_fractal(p * 0.16 + vec3(uTime * 0.1 + uWind, 0.0, 0.0)) + 0.25 );\r\n            nv = clamp(nv, 0.0, 1.0);\r\n            nv += dist * 0.01;\r\n\r\n            particles += nv * stepDistance * 18.0;\r\n          }\r\n        }\r\n\r\n        float fogFactor = 1.0 - exp(-particles * 0.1);\r\n        color = mix(color, vec3(1.0, 0.6, 0.4) * 0.25, fogFactor);\r\n        // color = mix(color, vec3(1.0, 0.7, 0.5) * 0.25, fogFactor);\r\n\r\n        torusesColor *= vec3(1.0, 0.3, 0.15) * 8.0;\r\n        torusesColor = ACESFilmicToneMapping(torusesColor);\r\n\r\n        float Talpha = torusesColor.x;\r\n        // Talpha *= fogMask;\r\n\r\n        // vec3 finalColor = mix(color, torusesColor, Talpha) * 0.5 + (color + torusesColor) * 0.5;\r\n        // vec3 finalColor = hueShift(color, -0.05) + torusesColor * 0.75;\r\n        vec3 finalColor = color + torusesColor * 0.5;\r\n\r\n        gl_FragColor = vec4(finalColor, 1.0);\r\n      }\r\n      `,\r\n\r\n      depthTest: false,\r\n      depthWrite: false,\r\n    });\r\n\r\n    this.blackMaterial = new MeshBasicMaterial({ color: 0x0 });\r\n    this.mesh = new THREE.Mesh(\r\n      new THREE.PlaneBufferGeometry(2, 2),\r\n      this.blurMaterial\r\n    );\r\n    this.camera = new THREE.PerspectiveCamera(\r\n      45,\r\n      1 /* remember that the camera is worthless here */,\r\n      1,\r\n      1000\r\n    );\r\n    this.renderer = renderer;\r\n\r\n    this.scene = new THREE.Scene();\r\n    this.scene.add(this.mesh);\r\n \r\n    this.clock = new THREE.Clock();\r\n    this.clock.start();\r\n  }\r\n\r\n  setWindLevel(windValue /* [0...deltatime] */, fogStartOffset /* [0...1] */) {\r\n    this.fogMaterial.uniforms.uWind.value += windValue;\r\n    this.fogMaterial.uniforms.uFogStartOffset.value = fogStartOffset * -1.0;\r\n  }\r\n\r\n  compute(colorTexture, renderTargetDest) {\r\n    this.renderer.setRenderTarget(this.rt1);\r\n    this.torusesScene.overrideMaterial = this.torusesMaterial;\r\n    this.renderer.render(this.torusesScene, this.torusesSceneCamera);\r\n    this.torusesScene.overrideMaterial = null;\r\n    \r\n    this.mesh.material = this.blurMaterial;\r\n    // ping pong blur toruses scene\r\n    for(let i = 0; i < 7; i++) {\r\n      this.blurMaterial.uniforms.uStep.value = i;\r\n\r\n      if(i > 5) this.blurMaterial.uniforms.uStep.value = 1;\r\n\r\n      // horizontal pass\r\n      this.renderer.setRenderTarget(this.rt0);\r\n      this.blurMaterial.uniforms.uHorizontal.value = true;\r\n      this.blurMaterial.uniforms.uTexture.value = this.rt1.texture;\r\n      this.renderer.render(this.scene, this.camera);\r\n\r\n      // vertical pass\r\n      this.renderer.setRenderTarget(this.rt1);\r\n      this.blurMaterial.uniforms.uHorizontal.value = false;\r\n      this.blurMaterial.uniforms.uTexture.value = this.rt0.texture;\r\n      this.renderer.render(this.scene, this.camera);\r\n    }\r\n\r\n\r\n    this.fogMaterial.uniforms.uColorTexture.value = colorTexture;\r\n    this.fogMaterial.uniforms.uTorusesBloom.value = this.rt1.texture;\r\n    this.fogMaterial.uniforms.uCameraPos.value = this.torusesSceneCamera.position.clone();\r\n    this.fogMaterial.uniforms.uTime.value = this.clock.getElapsedTime();\r\n    this.mesh.material = this.fogMaterial;\r\n    this.renderer.setRenderTarget(renderTargetDest);\r\n    this.renderer.render(this.scene, this.camera);\r\n    this.renderer.setRenderTarget(null);\r\n  }\r\n}\r\n","import { Color, DoubleSide, Vector3 } from \"three\";\r\nimport { MeshBasicMaterial } from \"three\";\r\nimport { Mesh } from \"three\";\r\nimport { Clock } from \"three\";\r\nimport { BufferGeometry } from \"three\";\r\nimport { BufferAttribute } from \"three\";\r\nimport { clamp, smoothstep } from \"three/src/math/MathUtils\";\r\n\r\nexport default class Crystals {\r\n  constructor() {\r\n    this.geo = new BufferGeometry();\r\n    this.clock = new Clock();\r\n    this.clock.start();\r\n\r\n    let material = new MeshBasicMaterial({\r\n      color: new Color('#FF5624').multiplyScalar(2.5),\r\n      side: DoubleSide,\r\n      toneMapped: false,\r\n    });\r\n\r\n\r\n    // crystal geometry\r\n    let vertices = [];\r\n    // this.createPartialCrystal(2, 0.15, new Vector3(0,1,0), 0.5, 0.95, vertices);\r\n\r\n    this.geo.setAttribute(\"position\", new BufferAttribute(new Float32Array(vertices), 3));\r\n\r\n    this.mesh = new Mesh(this.geo, material);\r\n  }\r\n\r\n  createCrystal(length, width, transl = new Vector3(0,0,0), scale = 1, vertices) {\r\n    let baselength = width * 1.7;\r\n    length = length - baselength * 2;\r\n\r\n    let base = new Vector3(0, -baselength - length * 0.5, 0);\r\n\r\n    let v1 = new Vector3(-width, -length * 0.5, -width);\r\n    let v2 = new Vector3(-width, -length * 0.5, +width);\r\n    let v3 = new Vector3(+width, -length * 0.5, +width);\r\n    let v4 = new Vector3(+width, -length * 0.5, -width);\r\n\r\n    let v5 = v1.clone().add(new Vector3(0, length, 0));\r\n    let v6 = v2.clone().add(new Vector3(0, length, 0));\r\n    let v7 = v3.clone().add(new Vector3(0, length, 0));\r\n    let v8 = v4.clone().add(new Vector3(0, length, 0));\r\n\r\n    let top = new Vector3(0, +baselength + length * 0.5, 0);\r\n    let structVerts = [base, v1, v2, v3, v4, v5, v6, v7, v8, top];\r\n\r\n    // translation / scaling\r\n    structVerts.forEach((v) => v.multiplyScalar(scale).add(transl));\r\n\r\n    // creating vertices\r\n    vertices.push(\r\n      base.x, base.y, base.z,  v1.x, v1.y, v1.z,  v2.x, v2.y, v2.z,    \r\n      base.x, base.y, base.z,  v2.x, v2.y, v2.z,  v3.x, v3.y, v3.z,    \r\n      base.x, base.y, base.z,  v3.x, v3.y, v3.z,  v4.x, v4.y, v4.z,    \r\n      base.x, base.y, base.z,  v4.x, v4.y, v4.z,  v1.x, v1.y, v1.z,\r\n      \r\n      v1.x, v1.y, v1.z,   v2.x, v2.y, v2.z,   v5.x, v5.y, v5.z,\r\n      v2.x, v2.y, v2.z,   v5.x, v5.y, v5.z,   v6.x, v6.y, v6.z,\r\n\r\n      v2.x, v2.y, v2.z,   v3.x, v3.y, v3.z,   v6.x, v6.y, v6.z,\r\n      v3.x, v3.y, v3.z,   v6.x, v6.y, v6.z,   v7.x, v7.y, v7.z,\r\n      \r\n      v3.x, v3.y, v3.z,   v4.x, v4.y, v4.z,   v7.x, v7.y, v7.z,\r\n      v4.x, v4.y, v4.z,   v7.x, v7.y, v7.z,   v8.x, v8.y, v8.z,\r\n      \r\n      v1.x, v1.y, v1.z,   v5.x, v5.y, v5.z,   v8.x, v8.y, v8.z,\r\n      v1.x, v1.y, v1.z,   v4.x, v4.y, v4.z,   v8.x, v8.y, v8.z,\r\n      \r\n      top.x, top.y, top.z,  v5.x, v5.y, v5.z,  v6.x, v6.y, v6.z,    \r\n      top.x, top.y, top.z,  v6.x, v6.y, v6.z,  v7.x, v7.y, v7.z,    \r\n      top.x, top.y, top.z,  v7.x, v7.y, v7.z,  v8.x, v8.y, v8.z,    \r\n      top.x, top.y, top.z,  v8.x, v8.y, v8.z,  v5.x, v5.y, v5.z,\r\n    );\r\n  };\r\n\r\n  createPartialCrystal(length, width, transl = new Vector3(0,0,0), scale = 1, t = 1, vertices) {\r\n    let lengthBasedT = t * length;\r\n\r\n    let baselength = width * 1.7;\r\n    length = length - baselength * 2;\r\n\r\n    let base = new Vector3(0, -baselength - length * 0.5, 0);\r\n\r\n    let v1 = new Vector3(-width, -length * 0.5, -width);\r\n    let v2 = new Vector3(-width, -length * 0.5, +width);\r\n    let v3 = new Vector3(+width, -length * 0.5, +width);\r\n    let v4 = new Vector3(+width, -length * 0.5, -width);\r\n\r\n    let v5 = v1.clone().add(new Vector3(0, length, 0));\r\n    let v6 = v2.clone().add(new Vector3(0, length, 0));\r\n    let v7 = v3.clone().add(new Vector3(0, length, 0));\r\n    let v8 = v4.clone().add(new Vector3(0, length, 0));\r\n\r\n    let top = new Vector3(0, +baselength + length * 0.5, 0);\r\n    let structVerts = [base, v1, v2, v3, v4, v5, v6, v7, v8, top];\r\n\r\n    if (lengthBasedT <= 0) {\r\n      return;\r\n\r\n    } else if(lengthBasedT <= baselength) {\r\n      let nt = lengthBasedT / baselength;\r\n      v1.add(new Vector3(0, length * 0.5 + baselength)).multiplyScalar(nt).add(new Vector3(0,-length * 0.5 - baselength,0));\r\n      v2.add(new Vector3(0, length * 0.5 + baselength)).multiplyScalar(nt).add(new Vector3(0,-length * 0.5 - baselength,0));\r\n      v3.add(new Vector3(0, length * 0.5 + baselength)).multiplyScalar(nt).add(new Vector3(0,-length * 0.5 - baselength,0));\r\n      v4.add(new Vector3(0, length * 0.5 + baselength)).multiplyScalar(nt).add(new Vector3(0,-length * 0.5 - baselength,0));\r\n\r\n      // translation / scaling\r\n      structVerts.forEach((v) => v.multiplyScalar(scale).add(transl));\r\n\r\n      vertices.push(\r\n        base.x, base.y, base.z,  v1.x, v1.y, v1.z,  v2.x, v2.y, v2.z,    \r\n        base.x, base.y, base.z,  v2.x, v2.y, v2.z,  v3.x, v3.y, v3.z,    \r\n        base.x, base.y, base.z,  v3.x, v3.y, v3.z,  v4.x, v4.y, v4.z,    \r\n        base.x, base.y, base.z,  v4.x, v4.y, v4.z,  v1.x, v1.y, v1.z,\r\n      );\r\n    } else if (lengthBasedT > baselength && lengthBasedT < (baselength + length)) {\r\n      let nt = (lengthBasedT - baselength) / length;\r\n      let offset = length * (1-nt);\r\n\r\n      v5.add(new Vector3(0,-offset,0));\r\n      v6.add(new Vector3(0,-offset,0));\r\n      v7.add(new Vector3(0,-offset,0));\r\n      v8.add(new Vector3(0,-offset,0));\r\n\r\n      // translation / scaling\r\n      structVerts.forEach((v) => v.multiplyScalar(scale).add(transl));\r\n      \r\n      vertices.push(\r\n        base.x, base.y, base.z,  v1.x, v1.y, v1.z,  v2.x, v2.y, v2.z,    \r\n        base.x, base.y, base.z,  v2.x, v2.y, v2.z,  v3.x, v3.y, v3.z,    \r\n        base.x, base.y, base.z,  v3.x, v3.y, v3.z,  v4.x, v4.y, v4.z,    \r\n        base.x, base.y, base.z,  v4.x, v4.y, v4.z,  v1.x, v1.y, v1.z,\r\n\r\n        v1.x, v1.y, v1.z,   v2.x, v2.y, v2.z,   v5.x, v5.y, v5.z,\r\n        v2.x, v2.y, v2.z,   v5.x, v5.y, v5.z,   v6.x, v6.y, v6.z,\r\n\r\n        v2.x, v2.y, v2.z,   v3.x, v3.y, v3.z,   v6.x, v6.y, v6.z,\r\n        v3.x, v3.y, v3.z,   v6.x, v6.y, v6.z,   v7.x, v7.y, v7.z,\r\n\r\n        v3.x, v3.y, v3.z,   v4.x, v4.y, v4.z,   v7.x, v7.y, v7.z,\r\n        v4.x, v4.y, v4.z,   v7.x, v7.y, v7.z,   v8.x, v8.y, v8.z,\r\n\r\n        v1.x, v1.y, v1.z,   v5.x, v5.y, v5.z,   v8.x, v8.y, v8.z,\r\n        v1.x, v1.y, v1.z,   v4.x, v4.y, v4.z,   v8.x, v8.y, v8.z,\r\n      );\r\n    } else if (lengthBasedT >= (baselength + length) && lengthBasedT < (baselength * 2 + length)) { \r\n      let nt = 1 - (lengthBasedT - (baselength + length)) / baselength;\r\n\r\n      let v9  = v5.clone().add(new Vector3(0, -length * 0.5 + baselength)).multiply(new Vector3(nt, 1-nt, nt)).add(new Vector3(0, length * 0.5, 0));\r\n      let v10 = v6.clone().add(new Vector3(0, -length * 0.5 + baselength)).multiply(new Vector3(nt, 1-nt, nt)).add(new Vector3(0, length * 0.5, 0));\r\n      let v11 = v7.clone().add(new Vector3(0, -length * 0.5 + baselength)).multiply(new Vector3(nt, 1-nt, nt)).add(new Vector3(0, length * 0.5, 0));\r\n      let v12 = v8.clone().add(new Vector3(0, -length * 0.5 + baselength)).multiply(new Vector3(nt, 1-nt, nt)).add(new Vector3(0, length * 0.5, 0));\r\n\r\n      structVerts.push(v9, v10, v11, v12);\r\n\r\n      // translation / scaling\r\n      structVerts.forEach((v) => v.multiplyScalar(scale).add(transl));\r\n\r\n      vertices.push(\r\n        base.x, base.y, base.z,  v1.x, v1.y, v1.z,  v2.x, v2.y, v2.z,    \r\n        base.x, base.y, base.z,  v2.x, v2.y, v2.z,  v3.x, v3.y, v3.z,    \r\n        base.x, base.y, base.z,  v3.x, v3.y, v3.z,  v4.x, v4.y, v4.z,    \r\n        base.x, base.y, base.z,  v4.x, v4.y, v4.z,  v1.x, v1.y, v1.z,\r\n\r\n        v1.x, v1.y, v1.z,   v2.x, v2.y, v2.z,   v5.x, v5.y, v5.z,\r\n        v2.x, v2.y, v2.z,   v5.x, v5.y, v5.z,   v6.x, v6.y, v6.z,\r\n\r\n        v2.x, v2.y, v2.z,   v3.x, v3.y, v3.z,   v6.x, v6.y, v6.z,\r\n        v3.x, v3.y, v3.z,   v6.x, v6.y, v6.z,   v7.x, v7.y, v7.z,\r\n\r\n        v3.x, v3.y, v3.z,   v4.x, v4.y, v4.z,   v7.x, v7.y, v7.z,\r\n        v4.x, v4.y, v4.z,   v7.x, v7.y, v7.z,   v8.x, v8.y, v8.z,\r\n\r\n        v1.x, v1.y, v1.z,   v5.x, v5.y, v5.z,   v8.x, v8.y, v8.z,\r\n        v1.x, v1.y, v1.z,   v4.x, v4.y, v4.z,   v8.x, v8.y, v8.z,\r\n\r\n\r\n        v5.x, v5.y, v5.z,   v6.x, v6.y, v6.z,   v9.x, v9.y, v9.z,\r\n        v6.x, v6.y, v6.z,   v9.x, v9.y, v9.z,   v10.x, v10.y, v10.z,\r\n\r\n        v6.x, v6.y, v6.z,   v7.x, v7.y, v7.z,     v10.x, v10.y, v10.z,\r\n        v7.x, v7.y, v7.z,   v10.x, v10.y, v10.z,  v11.x, v11.y, v11.z,\r\n\r\n        v7.x, v7.y, v7.z,   v8.x, v8.y, v8.z,    v11.x, v11.y, v11.z,\r\n        v8.x, v8.y, v8.z,   v11.x, v11.y, v11.z, v12.x, v12.y, v12.z,\r\n\r\n        v5.x, v5.y, v5.z,   v9.x, v9.y, v9.z, v12.x, v12.y, v12.z,\r\n        v5.x, v5.y, v5.z,   v8.x, v8.y, v8.z, v12.x, v12.y, v12.z,\r\n      );\r\n    } else if (lengthBasedT >= baselength * 2 + length) {\r\n\r\n      // translation / scaling\r\n      structVerts.forEach((v) => v.multiplyScalar(scale).add(transl));\r\n\r\n      // creating vertices\r\n      vertices.push(\r\n        base.x, base.y, base.z,  v1.x, v1.y, v1.z,  v2.x, v2.y, v2.z,    \r\n        base.x, base.y, base.z,  v2.x, v2.y, v2.z,  v3.x, v3.y, v3.z,    \r\n        base.x, base.y, base.z,  v3.x, v3.y, v3.z,  v4.x, v4.y, v4.z,    \r\n        base.x, base.y, base.z,  v4.x, v4.y, v4.z,  v1.x, v1.y, v1.z,\r\n\r\n        v1.x, v1.y, v1.z,   v2.x, v2.y, v2.z,   v5.x, v5.y, v5.z,\r\n        v2.x, v2.y, v2.z,   v5.x, v5.y, v5.z,   v6.x, v6.y, v6.z,\r\n\r\n        v2.x, v2.y, v2.z,   v3.x, v3.y, v3.z,   v6.x, v6.y, v6.z,\r\n        v3.x, v3.y, v3.z,   v6.x, v6.y, v6.z,   v7.x, v7.y, v7.z,\r\n\r\n        v3.x, v3.y, v3.z,   v4.x, v4.y, v4.z,   v7.x, v7.y, v7.z,\r\n        v4.x, v4.y, v4.z,   v7.x, v7.y, v7.z,   v8.x, v8.y, v8.z,\r\n\r\n        v1.x, v1.y, v1.z,   v5.x, v5.y, v5.z,   v8.x, v8.y, v8.z,\r\n        v1.x, v1.y, v1.z,   v4.x, v4.y, v4.z,   v8.x, v8.y, v8.z,\r\n\r\n        top.x, top.y, top.z,  v5.x, v5.y, v5.z,  v6.x, v6.y, v6.z,    \r\n        top.x, top.y, top.z,  v6.x, v6.y, v6.z,  v7.x, v7.y, v7.z,    \r\n        top.x, top.y, top.z,  v7.x, v7.y, v7.z,  v8.x, v8.y, v8.z,    \r\n        top.x, top.y, top.z,  v8.x, v8.y, v8.z,  v5.x, v5.y, v5.z,\r\n      );\r\n    }\r\n  };\r\n\r\n\r\n  update(sphereActiveTimer) {\r\n    let delta = this.clock.getDelta();\r\n    let time = this.clock.getElapsedTime();\r\n\r\n\r\n    // let center = new Vector3(0.61, -0.13, 0.2);\r\n    let center = new Vector3(0.71, -0.13, -0.05);\r\n    let vertices = [];\r\n\r\n    let animTime = (time * 1.5) % 12;\r\n\r\n    let steps = 18;\r\n    // let steps = 35;\r\n    let rad = 0.35;\r\n    let length = 0.15;\r\n    let width = 0.0075;\r\n\r\n    for(let i = 0; i < steps; i++) {\r\n\r\n      // let timeAngleOff = animTime * 0.1; \r\n\r\n      // let x = Math.sin(i / (steps) * Math.PI * 2 - 1.15 + timeAngleOff) * rad;\r\n      // let z = Math.cos(i / (steps) * Math.PI * 2 - 1.15 + timeAngleOff) * rad;\r\n\r\n      // let pos = center.clone().add(new Vector3(x, 0, z));\r\n\r\n      // let sinSpeed = i * 2;\r\n\r\n    //   if(animTime < 3) {\r\n    //     let dist = Math.abs(i - steps * 0.5);   // [0 ... steps/2]\r\n    //     let tOffs = -dist / (steps * 0.5) * 2;  // [0 ... -2]\r\n\r\n    //     pos.add(new Vector3(0, Math.sin(i + animTime) * 0.05 * Math.cos(animTime), 0));\r\n\r\n    //     // this.createPartialCrystal(length, width, pos, 1 + Math.sin(sinSpeed + Math.PI * 1.25) * 0.3, animTime + tOffs, vertices);\r\n    //     this.createPartialCrystal(length * (1 + Math.sin(sinSpeed + Math.PI * 1.25) * 0.3), width, pos, 1, animTime + tOffs, vertices);\r\n    //   } else if (animTime < 6) {\r\n    //     let newT = (animTime - 3) / 1.5;\r\n\r\n    //     let scaleOffset = (Math.sin(newT * Math.PI - Math.PI * 0.5) * 0.5 + 0.5) * 3.0 + newT * 1.5;\r\n\r\n    //     pos.add(new Vector3(0, Math.sin(i + animTime) * 0.05 * Math.cos(animTime), 0));\r\n\r\n    //     // this.createPartialCrystal(length, width, pos, 1 + Math.sin(sinSpeed + Math.PI * 1.25 + scaleOffset) * 0.3, 1, vertices);\r\n    //     this.createPartialCrystal(length * (1 + Math.sin(sinSpeed + Math.PI * 1.25 + scaleOffset) * 0.3), width, pos, 1, 1, vertices);\r\n    //   } else if (animTime < 12) {\r\n    //     let newT = (animTime - 6) / 1.5;\r\n\r\n    //     let scaleOffset = 6.0 + 3.0 + newT * 1.5;\r\n\r\n    //     let show = 1;\r\n    //     if(animTime > 11) {\r\n    //       show = (1 - (animTime - 11)) * 3;   // [3 ... 0]\r\n\r\n    //       let dist = Math.abs(i - steps * 0.5);   // [0 ... steps/2]\r\n    //       let tOffs = 2 - dist / (steps * 0.5) * 2;  // [2 ... 0]\r\n\r\n    //       show -= tOffs;\r\n\r\n    //       if(show > 1) show = 1;\r\n    //       if(show < 0) show = 0;\r\n    //     }\r\n\r\n    //     pos.add(new Vector3(0, Math.sin(i + animTime) * 0.05 * Math.cos(animTime), 0));\r\n\r\n    //     // this.createPartialCrystal(length, width, pos, 1 + Math.sin(sinSpeed + Math.PI * 1.25 + scaleOffset) * 0.3, show, vertices);\r\n    //     this.createPartialCrystal(length * (1 + Math.sin(sinSpeed + Math.PI * 1.25 + scaleOffset) * 0.3), width, pos, show, 1, vertices);\r\n    //   } \r\n\r\n    let timeAngleOff = time * 0.1; \r\n\r\n    let x = Math.sin(i / (steps) * Math.PI * 2 - 1.15 + timeAngleOff) * rad;\r\n    let z = Math.cos(i / (steps) * Math.PI * 2 - 1.15 + timeAngleOff) * rad;\r\n\r\n    let pos = center.clone().add(new Vector3(x, 0, z));\r\n    let sinSpeed = i * 2;\r\n\r\n    let newT = time;\r\n    let scaleOffset = newT * 1.5;\r\n    let scale = smoothstep(clamp(sphereActiveTimer, 0, 1), 0, 1);\r\n\r\n    pos.add(new Vector3(0, Math.sin(i + time) * 0.05 * Math.cos(time), 0));\r\n    this.createPartialCrystal(length * (1 + Math.sin(sinSpeed + Math.PI * 1.25 + scaleOffset) * 0.3), width, pos, scale, 1, vertices);\r\n  }\r\n\r\n\r\n\r\n    // let crystalsN = 20;\r\n    // if(animTime < 12) {\r\n    //   let showT = animTime;\r\n    //   let scaleT = 1;\r\n    //   if(animTime > 11) {\r\n    //     scaleT = Math.max(Math.min(1 - (animTime - 11), 1), 0);\r\n    //   }\r\n\r\n    //   if(!this.floatingCrystalsData) {\r\n    //     this.floatingCrystalsData = [];\r\n    //     for(let i = 0; i < crystalsN; i++) {\r\n    //       // let angle = Math.PI * 2 * Math.random();\r\n    //       let angle = (Math.PI * 2 * (i / crystalsN) + Math.random() * 0);\r\n    //       let rad = Math.random() * 0.75 + 0.75;\r\n  \r\n    //       let pos = center.clone().add(\r\n    //         new Vector3(\r\n    //           Math.sin(angle) * rad, \r\n    //           Math.random() * 0.3 - 0.1, \r\n    //           Math.cos(angle) * rad\r\n    //         )\r\n    //       );\r\n\r\n    //       this.floatingCrystalsData.push({\r\n    //         pos,\r\n    //         startT: Math.random() * 2.5,\r\n    //       }); \r\n    //     }\r\n    //   }\r\n\r\n    //   for(let i = 0; i < crystalsN; i++) {\r\n    //     let pos = this.floatingCrystalsData[i].pos.clone();\r\n    //     pos.add(new Vector3(0,Math.sin(i + animTime) * 0.07,0));\r\n\r\n    //     let startT = this.floatingCrystalsData[i].startT;\r\n\r\n    //     this.createPartialCrystal(length, width, pos, scaleT, showT - startT, vertices);\r\n    //   }\r\n    // }\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n    this.geo.setAttribute(\"position\", new BufferAttribute(new Float32Array(vertices), 3));\r\n  }\r\n}","import * as THREE from \"three\";\r\nimport { Vector3 } from \"three\";\r\nimport { Scene } from \"three\";\r\nimport { Raycaster, Vector2 } from \"three\";\r\n\r\n\r\n// how to use it:\r\n\r\n// import { updateFluidSim, initFluidSim, framebuffers }\r\n// have fun!\r\n\r\n\r\nlet config = {\r\n  SIM_RESOLUTION: 256,\r\n  DYE_RESOLUTION: 1024,\r\n  CAPTURE_RESOLUTION: 512,\r\n  DENSITY_DISSIPATION: 0.6, // 1,\r\n  VELOCITY_DISSIPATION: 0.2,\r\n  PRESSURE: 1,\r\n  PRESSURE_ITERATIONS: 20,\r\n  CURL: 25,\r\n  SPLAT_RADIUS: 0.25,\r\n  SPLAT_FORCE: 6000,\r\n  SHADING: false,\r\n  COLORFUL: true,\r\n  COLOR_UPDATE_SPEED: 10,\r\n  PAUSED: false,\r\n  BACK_COLOR: { r: 0, g: 0, b: 0 },\r\n  TRANSPARENT: false,\r\n};\r\n\r\nfunction pointerPrototype() {\r\n  this.id = -1;\r\n  this.texcoordX = 0;\r\n  this.texcoordY = 0;\r\n  this.prevTexcoordX = 0;\r\n  this.prevTexcoordY = 0;\r\n  this.deltaX = 0;\r\n  this.deltaY = 0;\r\n  this.down = false;\r\n  this.moved = false;\r\n  // not restricted to [0, 255]\r\n  this.color = [300, 200, 200];\r\n}\r\n\r\nlet pointers = [];\r\nlet splatStack = [];\r\npointers.push(new pointerPrototype());\r\n\r\nlet canvas;\r\nlet scene;\r\nlet camera;\r\nlet renderer;\r\nexport let framebuffers = { \r\n  dye: null,\r\n  velocity: null,\r\n};\r\n\r\nexport function initFluidSim(rendererRef, canvasRef, overrideConfig) {\r\n  if(overrideConfig) {\r\n    config = overrideConfig;\r\n  }\r\n\r\n  canvas = canvasRef;\r\n  renderer = rendererRef;\r\n\r\n  scene = new THREE.Scene();\r\n\r\n  camera = new THREE.PerspectiveCamera( 45, canvas.width / canvas.height, 0.1, 10 );\r\n\r\n  initFramebuffers();\r\n  initMaterials();\r\n};\r\n\r\nfunction debug() {\r\n  multipleSplats(5);\r\n  debugTexture(dye.read.texture);\r\n}\r\n\r\nfunction debugTexture(texture) {\r\n  quadPlaneMesh.material = copyProgram;\r\n  copyProgram.uniforms.uTexture.value = texture;\r\n  renderer.setRenderTarget(null);\r\n  renderer.render(scene, camera);\r\n}\r\n\r\nfunction getResolution(resolution) {\r\n  let aspectRatio = canvas.width / canvas.height;\r\n  if (aspectRatio < 1) aspectRatio = 1.0 / aspectRatio;\r\n\r\n  let min = Math.round(resolution);\r\n  let max = Math.round(resolution * aspectRatio);\r\n\r\n  if (canvas.width > canvas.height) return { width: max, height: min };\r\n  else return { width: min, height: max };\r\n}\r\n\r\nlet dye;\r\nlet velocity;\r\nlet divergence;\r\nlet curl;\r\nlet pressure;\r\nfunction initFramebuffers() {\r\n  let simRes = getResolution(config.SIM_RESOLUTION);\r\n  let dyeRes = getResolution(config.DYE_RESOLUTION);\r\n\r\n  if (dye == null)\r\n    dye = createDoubleFBO(dyeRes.width, dyeRes.height, THREE.LinearFilter);\r\n  // dye = resizeDoubleFBO(dye, dyeRes.width, dyeRes.height, rgba.internalFormat, rgba.format, texType, filtering);\r\n  else throw new Error(\"not implemented\");\r\n\r\n  if (velocity == null)\r\n    velocity = createDoubleFBO(simRes.width, simRes.height, THREE.LinearFilter);\r\n  // velocity = resizeDoubleFBO(velocity, simRes.width, simRes.height, rg.internalFormat, rg.format, texType, filtering);\r\n  else throw new Error(\"not implemented\");\r\n\r\n  divergence = createFBO(simRes.width, simRes.height, THREE.NearestFilter);\r\n  curl = createFBO(simRes.width, simRes.height, THREE.NearestFilter);\r\n  pressure = createDoubleFBO(simRes.width, simRes.height, THREE.NearestFilter);\r\n\r\n  framebuffers.dye = dye;\r\n  framebuffers.velocity = velocity;\r\n}\r\n\r\nfunction createFBO(w, h, filtering) {\r\n  let rt = new THREE.WebGLRenderTarget(w, h, {\r\n    type: THREE.FloatType,\r\n    minFilter: filtering,\r\n    magFilter: filtering,\r\n    format: THREE.RGBAFormat,\r\n    depthBuffer: false,\r\n    stencilBuffer: false,\r\n    anisotropy: 1,\r\n  });\r\n\r\n  let texelSizeX = 1.0 / w;\r\n  let texelSizeY = 1.0 / h;\r\n\r\n  return {\r\n    texture: rt.texture,\r\n    fbo: rt,\r\n    width: w,\r\n    height: h,\r\n    texelSizeX: texelSizeX,\r\n    texelSizeY: texelSizeY,\r\n  };\r\n}\r\nfunction createDoubleFBO(w, h, filtering) {\r\n  let fbo1 = createFBO(w, h, filtering);\r\n  let fbo2 = createFBO(w, h, filtering);\r\n\r\n  return {\r\n    width: w,\r\n    height: h,\r\n    texelSizeX: fbo1.texelSizeX,\r\n    texelSizeY: fbo1.texelSizeY,\r\n\r\n    get read() {\r\n      return fbo1;\r\n    },\r\n    set read(value) {\r\n      fbo1 = value;\r\n    },\r\n    get write() {\r\n      return fbo2;\r\n    },\r\n    set write(value) {\r\n      fbo2 = value;\r\n    },\r\n\r\n    swap() {\r\n      let temp = fbo1;\r\n      fbo1 = fbo2;\r\n      fbo2 = temp;\r\n    },\r\n  };\r\n}\r\n\r\nlet copyProgram;\r\nlet splatProgram;\r\nlet curlProgram;\r\nlet vorticityProgram;\r\nlet divergenceProgram;\r\nlet clearProgram;\r\nlet pressureProgram;\r\nlet gradienSubtractProgram;\r\nlet advectionProgram;\r\nlet displayMaterial;\r\nlet quadPlaneMesh;\r\nfunction initMaterials() {\r\n  copyProgram = new THREE.ShaderMaterial({\r\n    uniforms: {\r\n      uTexture: { type: \"t\", value: velocity.read.texture },\r\n    },\r\n    vertexShader: baseVertexShader,\r\n    fragmentShader: copyShader,\r\n  });\r\n\r\n  splatProgram = new THREE.ShaderMaterial({\r\n    uniforms: {\r\n      uTarget: { type: \"t\", value: velocity.read.texture },\r\n      aspectRatio: { value: canvas.width / canvas.height },\r\n      point: { value: new THREE.Vector2(0, 0) },\r\n      color: { value: new THREE.Vector3(0, 0, 0) },\r\n      radius: { value: correctRadius(config.SPLAT_RADIUS / 100.0) },\r\n    },\r\n    vertexShader: baseVertexShader,\r\n    fragmentShader: splatShader,\r\n  });\r\n\r\n  curlProgram = new THREE.ShaderMaterial({\r\n    uniforms: {\r\n      texelSize: {\r\n        value: new THREE.Vector2(velocity.texelSizeX, velocity.texelSizeY),\r\n      },\r\n      uVelocity: { type: \"t\", value: velocity.read.texture },\r\n    },\r\n    vertexShader: baseVertexShader,\r\n    fragmentShader: curlShader,\r\n  });\r\n\r\n  vorticityProgram = new THREE.ShaderMaterial({\r\n    uniforms: {\r\n      texelSize: {\r\n        value: new THREE.Vector2(velocity.texelSizeX, velocity.texelSizeY),\r\n      },\r\n      uVelocity: { type: \"t\", value: velocity.read.texture },\r\n      uCurl: { type: \"t\", value: curl.texture },\r\n      curl: { value: config.CURL },\r\n      dt: { value: 0.0 },\r\n    },\r\n    vertexShader: baseVertexShader,\r\n    fragmentShader: vorticityShader,\r\n  });\r\n\r\n  divergenceProgram = new THREE.ShaderMaterial({\r\n    uniforms: {\r\n      texelSize: {\r\n        value: new THREE.Vector2(velocity.texelSizeX, velocity.texelSizeY),\r\n      },\r\n      uVelocity: { type: \"t\", value: velocity.read.texture },\r\n    },\r\n    vertexShader: baseVertexShader,\r\n    fragmentShader: divergenceShader,\r\n  });\r\n\r\n  clearProgram = new THREE.ShaderMaterial({\r\n    uniforms: {\r\n      uTexture: { type: \"t\", value: pressure.read.texture },\r\n      value: { value: config.PRESSURE },\r\n    },\r\n    vertexShader: baseVertexShader,\r\n    fragmentShader: clearShader,\r\n  });\r\n\r\n  pressureProgram = new THREE.ShaderMaterial({\r\n    uniforms: {\r\n      texelSize: {\r\n        value: new THREE.Vector2(velocity.texelSizeX, velocity.texelSizeY),\r\n      },\r\n      uDivergence: { type: \"t\", value: divergence.texture },\r\n      uPressure: { type: \"t\", value: pressure.read.texture },\r\n    },\r\n    vertexShader: baseVertexShader,\r\n    fragmentShader: pressureShader,\r\n  });\r\n\r\n  gradienSubtractProgram = new THREE.ShaderMaterial({\r\n    uniforms: {\r\n      texelSize: {\r\n        value: new THREE.Vector2(velocity.texelSizeX, velocity.texelSizeY),\r\n      },\r\n      uPressure: { type: \"t\", value: pressure.read.texture },\r\n      uVelocity: { type: \"t\", value: velocity.read.texture },\r\n    },\r\n    vertexShader: baseVertexShader,\r\n    fragmentShader: gradientSubtractShader,\r\n  });\r\n\r\n  advectionProgram = new THREE.ShaderMaterial({\r\n    uniforms: {\r\n      texelSize: {\r\n        value: new THREE.Vector2(velocity.texelSizeX, velocity.texelSizeY),\r\n      },\r\n      uVelocity: { type: \"t\", value: velocity.read.texture },\r\n      uSource: { type: \"t\", value: velocity.read.texture },\r\n      dt: { value: 0.0 },\r\n      dissipation: { value: config.VELOCITY_DISSIPATION },\r\n    },\r\n    vertexShader: baseVertexShader,\r\n    fragmentShader: advectionShader,\r\n  });\r\n\r\n  displayMaterial = new THREE.ShaderMaterial({\r\n    uniforms: {\r\n      texelSize: {\r\n        value: new THREE.Vector2(velocity.texelSizeX, velocity.texelSizeY),\r\n      },\r\n      uVelocity: { type: \"t\", value: velocity.read.texture },\r\n      uTexture: { type: \"t\", value: dye.read.texture },\r\n      uPressure: { type: \"t\", value: pressure.read.texture },\r\n      uCurl: { type: \"t\", value: curl.texture },\r\n    },\r\n    vertexShader: baseVertexShader,\r\n    fragmentShader: displayShaderSource,\r\n  });\r\n\r\n  let quadPlane = new THREE.PlaneBufferGeometry(2, 2);\r\n  quadPlaneMesh = new THREE.Mesh(quadPlane, curlProgram);\r\n  scene.add(quadPlaneMesh);\r\n}\r\n\r\nexport function updateFluidSim() {\r\n  const dt = calcDeltaTime();\r\n  // if (resizeCanvas())\r\n  //     initFramebuffers();\r\n\r\n  updateColors(dt);\r\n  applyInputs();\r\n  // if (!config.PAUSED)\r\n  step(dt);\r\n  // render();\r\n}\r\n\r\nlet lastUpdateTime = Date.now();\r\nfunction calcDeltaTime() {\r\n  let now = Date.now();\r\n  let dt = (now - lastUpdateTime) / 1000;\r\n  dt = Math.min(dt, 0.016666);\r\n  lastUpdateTime = now;\r\n  return dt;\r\n}\r\n\r\nfunction step(dt) {\r\n  // we'll change quadPlaneMesh.material as needed\r\n  quadPlaneMesh.material = curlProgram;\r\n  curlProgram.uniforms.uVelocity.value = velocity.read.texture;\r\n  renderer.setRenderTarget(curl.fbo);\r\n  renderer.render(scene, camera);\r\n\r\n  quadPlaneMesh.material = vorticityProgram;\r\n  vorticityProgram.uniforms.uVelocity.value = velocity.read.texture;\r\n  vorticityProgram.uniforms.uCurl.value = curl.texture;\r\n  vorticityProgram.uniforms.curl.value = config.CURL;\r\n  vorticityProgram.uniforms.dt.value = dt;\r\n  renderer.setRenderTarget(velocity.write.fbo);\r\n  renderer.render(scene, camera);\r\n  velocity.swap();\r\n\r\n  quadPlaneMesh.material = divergenceProgram;\r\n  divergenceProgram.uniforms.uVelocity.value = velocity.read.texture;\r\n  renderer.setRenderTarget(divergence.fbo);\r\n  renderer.render(scene, camera);\r\n\r\n  quadPlaneMesh.material = clearProgram;\r\n  clearProgram.uniforms.uTexture.value = pressure.read.texture;\r\n  clearProgram.uniforms.value.value = config.PRESSURE;\r\n  renderer.setRenderTarget(pressure.write.fbo);\r\n  renderer.render(scene, camera);\r\n\r\n  quadPlaneMesh.material = pressureProgram;\r\n  pressureProgram.uniforms.uDivergence.value = divergence.texture;\r\n  for (let i = 0; i < config.PRESSURE_ITERATIONS; i++) {\r\n    pressureProgram.uniforms.uPressure.value = pressure.read.texture;\r\n    renderer.setRenderTarget(pressure.write.fbo);\r\n    renderer.render(scene, camera);\r\n    pressure.swap();\r\n  }\r\n\r\n  quadPlaneMesh.material = gradienSubtractProgram;\r\n  gradienSubtractProgram.uniforms.uPressure.value = pressure.read.texture;\r\n  gradienSubtractProgram.uniforms.uVelocity.value = velocity.read.texture;\r\n  renderer.setRenderTarget(velocity.write.fbo);\r\n  renderer.render(scene, camera);\r\n  velocity.swap();\r\n\r\n  quadPlaneMesh.material = advectionProgram;\r\n  advectionProgram.uniforms.uVelocity.value = velocity.read.texture;\r\n  advectionProgram.uniforms.uSource.value = velocity.read.texture;\r\n  advectionProgram.uniforms.dt.value = dt;\r\n  advectionProgram.uniforms.dissipation.value = config.VELOCITY_DISSIPATION;\r\n  renderer.setRenderTarget(velocity.write.fbo);\r\n  renderer.render(scene, camera);\r\n  velocity.swap();\r\n\r\n  quadPlaneMesh.material = advectionProgram;\r\n  advectionProgram.uniforms.uVelocity.value = velocity.read.texture;\r\n  advectionProgram.uniforms.uSource.value = dye.read.texture;\r\n  advectionProgram.uniforms.dt.value = dt;\r\n  advectionProgram.uniforms.dissipation.value = config.DENSITY_DISSIPATION;\r\n  renderer.setRenderTarget(dye.write.fbo);\r\n  renderer.render(scene, camera);\r\n  dye.swap();\r\n\r\n  renderer.setRenderTarget(null);\r\n}\r\nfunction render() {\r\n  drawDisplay(window.innerWidth, window.innerHeight);\r\n}\r\nfunction drawDisplay(width, height) {\r\n  renderer.setRenderTarget(null);\r\n  quadPlaneMesh.material = displayMaterial;\r\n  displayMaterial.uniforms.uTexture.value = dye.read.texture;\r\n  displayMaterial.uniforms.uVelocity.value = velocity.read.texture;\r\n  displayMaterial.uniforms.uPressure.value = pressure.read.texture;\r\n  displayMaterial.uniforms.uCurl.value = curl.texture;\r\n  renderer.render(scene, camera);\r\n}\r\nfunction splat(x, y, dx, dy, color, pointer, colorMultiplier) {\r\n  if (!colorMultiplier) colorMultiplier = 1;\r\n\r\n  quadPlaneMesh.material = splatProgram;\r\n  splatProgram.uniforms.uTarget.value = velocity.read.texture;\r\n  splatProgram.uniforms.aspectRatio.value = canvas.width / canvas.height;\r\n  splatProgram.uniforms.point.value = new THREE.Vector2(x, y);\r\n  splatProgram.uniforms.color.value = new THREE.Vector3(dx, dy, 0);\r\n  splatProgram.uniforms.radius.value = correctRadius(\r\n    config.SPLAT_RADIUS / 100.0\r\n  );\r\n  renderer.setRenderTarget(velocity.write.fbo);\r\n  renderer.render(scene, camera);\r\n  velocity.swap();\r\n\r\n  // let colorIntensity = 0.2 * colorMultiplier;\r\n  // let c = { r: 1, g: 0.8, b: 0.5 };\r\n  // // let c = new THREE.Vector3(x,y,0).sub(new THREE.Vector3(dx, dy, 0)).normalize().multiplyScalar(0.5).addScalar(0.5);\r\n  // let c = new THREE.Vector3(x,y,0).sub(new THREE.Vector3(dx, dy, 0)).normalize();\r\n  // c = {r: c.x, g: c.y, b: c.z};\r\n  // if (pointer.downRight) {\r\n  //   c = { r: -1, g: -1, b: -1 };\r\n  //   colorIntensity = 0.08;\r\n  // }\r\n\r\n  if (!pointer.downMiddle) {\r\n    splatProgram.uniforms.uTarget.value = dye.read.texture;\r\n    splatProgram.uniforms.color.value = new THREE.Vector3(1,1,1).multiplyScalar(0.2);\r\n    // splatProgram.uniforms.color.value = new THREE.Vector3(\r\n    //   /* color.r */ c.r,\r\n    //   /* color.g */ c.g,\r\n    //   /* color.b */ c.b\r\n    // )\r\n    // .normalize()\r\n    // .multiplyScalar(colorIntensity);\r\n\r\n    renderer.setRenderTarget(dye.write.fbo);\r\n    renderer.render(scene, camera);\r\n    dye.swap();\r\n  }\r\n}\r\nfunction correctRadius(radius) {\r\n  let aspectRatio = canvas.width / canvas.height;\r\n  if (aspectRatio > 1) radius *= aspectRatio;\r\n  return radius;\r\n}\r\n\r\nfunction applyInputs() {\r\n  pointers.forEach((p) => {\r\n    if (p.moved) {\r\n      p.moved = false;\r\n      splatPointer(p);\r\n    }\r\n  });\r\n}\r\nfunction multipleSplats(amount) {\r\n  for (let i = 0; i < amount; i++) {\r\n    let color = { r: 100, g: 100, b: 100 };\r\n\r\n    const x = Math.random();\r\n    const y = Math.random();\r\n    const dx = 2700 * (Math.random() - 0.5);\r\n    const dy = 2700 * (Math.random() - 0.5);\r\n    splat(x, y, dx, dy, color, { downRight: Math.random() > 0.5 }, 10);\r\n  }\r\n}\r\n\r\nconst raycaster = new Raycaster();\r\nexport function initMouseCommands(camera, waterScene) {\r\n  window.addEventListener(\"mousedown\", (e) => {\r\n    let posX = scaleByPixelRatio(e.clientX);\r\n    let posY = scaleByPixelRatio(e.clientY);\r\n    let pointer = pointers.find((p) => p.id == -1);\r\n    if (pointer == null) pointer = new pointerPrototype();\r\n    updatePointerDownData(pointer, -1, posX, posY, e.which == 3, e.which == 2);\r\n  });\r\n\r\n  window.addEventListener(\"touchstart\", (e) => {\r\n    let posX = scaleByPixelRatio(e.touches[0].clientX);\r\n    let posY = scaleByPixelRatio(e.touches[0].clientY);\r\n    let pointer = pointers.find((p) => p.id == -1);\r\n    if (pointer == null) pointer = new pointerPrototype();\r\n    updatePointerDownData(pointer, -1, posX, posY, e.which == 3, e.which == 2);\r\n  });\r\n\r\n  window.addEventListener(\"mousemove\", (e) => {\r\n    let pointer = pointers[0];\r\n    // if (!pointer.down) return;\r\n    // let posX = scaleByPixelRatio(e.clientX);\r\n    // let posY = scaleByPixelRatio(e.clientY);\r\n\r\n    // calculate mouse position in normalized device coordinates\r\n\t  // (-1 to +1) for both components\r\n    let mouse = new Vector2(\r\n      ( e.clientX / window.innerWidth ) * 2 - 1,\r\n      - ( e.clientY / window.innerHeight ) * 2 + 1,\r\n    );\r\n    // update the picking ray with the camera and mouse position\r\n    raycaster.setFromCamera( mouse, camera );\r\n    // calculate objects intersecting the picking ray\r\n    const intersects = raycaster.intersectObjects( waterScene.children );\r\n    if(intersects[0]) {\r\n      let intersectionPoint = intersects[0].point;\r\n      let distVec = intersectionPoint.clone().sub(new Vector3(0.71, -0.13, -0.05)).multiplyScalar(0.75);\r\n      if(distVec.x > 1.0) distVec.x = 1.0;\r\n      if(distVec.x < -1.0) distVec.x = -1.0;\r\n      if(distVec.y > 1.0) distVec.y = 1.0;\r\n      if(distVec.y < -1.0) distVec.y = -1.0;\r\n      let fluidUv = distVec.clone().multiplyScalar(0.5).addScalar(0.5);\r\n\r\n      let posX = fluidUv.x;\r\n      let posY = fluidUv.z;\r\n\r\n      updatePointerMoveData(pointer, posX, posY);\r\n    }\r\n  });\r\n\r\n  window.addEventListener(\"touchmove\", (e) => {\r\n    let pointer = pointers[0];\r\n    // if (!pointer.down) return;\r\n    let posX = scaleByPixelRatio(e.touches[0].clientX);\r\n    let posY = scaleByPixelRatio(e.touches[0].clientY);\r\n    updatePointerMoveData(pointer, posX, posY);\r\n  });\r\n\r\n  window.addEventListener(\"mouseup\", () => {\r\n    updatePointerUpData(pointers[0]);\r\n  });\r\n}\r\nfunction splatPointer(pointer) {\r\n  let dx = pointer.deltaX * config.SPLAT_FORCE;\r\n  let dy = pointer.deltaY * config.SPLAT_FORCE;\r\n\r\n  splat(pointer.texcoordX, pointer.texcoordY, dx, dy, pointer.color, pointer);\r\n}\r\n\r\nfunction scaleByPixelRatio(input) {\r\n  let pixelRatio = window.devicePixelRatio || 1;\r\n  return Math.floor(input * pixelRatio);\r\n}\r\n\r\nfunction updatePointerDownData(pointer, id, posX, posY, rightKey, middleKey) {\r\n  pointer.id = id;\r\n  pointer.down = true;\r\n  pointer.downRight = rightKey;\r\n  pointer.downMiddle = middleKey;\r\n  pointer.moved = false;\r\n  pointer.texcoordX = posX / canvas.width;\r\n  pointer.texcoordY = 1.0 - posY / canvas.height;\r\n  pointer.prevTexcoordX = pointer.texcoordX;\r\n  pointer.prevTexcoordY = pointer.texcoordY;\r\n  pointer.deltaX = 0;\r\n  pointer.deltaY = 0;\r\n  pointer.color = generateColor(ciclingHue);\r\n}\r\n\r\nfunction updatePointerMoveData(pointer, posX, posY) {\r\n  pointer.prevTexcoordX = pointer.texcoordX;\r\n  pointer.prevTexcoordY = pointer.texcoordY;\r\n  // pointer.texcoordX = posX / canvas.width;\r\n  // pointer.texcoordY = 1.0 - posY / canvas.height;\r\n  pointer.texcoordX = posX; \r\n  pointer.texcoordY = posY; \r\n  pointer.deltaX = correctDeltaX(pointer.texcoordX - pointer.prevTexcoordX);\r\n  pointer.deltaY = correctDeltaY(pointer.texcoordY - pointer.prevTexcoordY);\r\n  pointer.moved = Math.abs(pointer.deltaX) > 0 || Math.abs(pointer.deltaY) > 0;\r\n}\r\n\r\nfunction updatePointerUpData(pointer) {\r\n  pointer.down = false;\r\n}\r\n\r\nlet colorUpdateTimer = 0;\r\nlet ciclingHue = 0;\r\nfunction updateColors(dt) {\r\n  if (!config.COLORFUL) return;\r\n\r\n  ciclingHue += dt * config.COLOR_UPDATE_SPEED * 0.03;\r\n  ciclingHue = ciclingHue % 360;\r\n  colorUpdateTimer += dt * config.COLOR_UPDATE_SPEED;\r\n  // if (colorUpdateTimer >= 1) {\r\n  colorUpdateTimer = wrap(colorUpdateTimer, 0, 1);\r\n  pointers.forEach((p) => {\r\n    p.color = generateColor(ciclingHue);\r\n  });\r\n  // }\r\n}\r\nfunction wrap(value, min, max) {\r\n  let range = max - min;\r\n  if (range == 0) return min;\r\n  return ((value - min) % range) + min;\r\n}\r\n\r\nfunction correctDeltaX(delta) {\r\n  let aspectRatio = canvas.width / canvas.height;\r\n  if (aspectRatio < 1) delta *= aspectRatio;\r\n  return delta;\r\n}\r\n\r\nfunction correctDeltaY(delta) {\r\n  let aspectRatio = canvas.width / canvas.height;\r\n  if (aspectRatio > 1) delta /= aspectRatio;\r\n  return delta;\r\n}\r\n\r\nfunction generateColor(hue) {\r\n  let c = HSVtoRGB(hue || Math.random(), 1.0, 1.0);\r\n  c.r *= 0.15;\r\n  c.g *= 0.15;\r\n  c.b *= 0.15;\r\n  return c;\r\n}\r\n\r\nfunction HSVtoRGB(h, s, v) {\r\n  let r, g, b, i, f, p, q, t;\r\n  i = Math.floor(h * 6);\r\n  f = h * 6 - i;\r\n  p = v * (1 - s);\r\n  q = v * (1 - f * s);\r\n  t = v * (1 - (1 - f) * s);\r\n\r\n  switch (i % 6) {\r\n    case 0:\r\n      r = v; g = t; b = p;\r\n      break;\r\n    case 1:\r\n      r = q; g = v; b = p;\r\n      break;\r\n    case 2:\r\n      r = p; g = v; b = t;\r\n      break;\r\n    case 3:\r\n      r = p; g = q; b = v;\r\n      break;\r\n    case 4:\r\n      r = t; g = p; b = v;\r\n      break;\r\n    case 5:\r\n      r = v; g = p; b = q;\r\n      break;\r\n  }\r\n\r\n  return {\r\n    r,\r\n    g,\r\n    b,\r\n  };\r\n}\r\n\r\nconst baseVertexShader = `\r\n    varying vec2 vUv;\r\n    varying vec2 vL;\r\n    varying vec2 vR;\r\n    varying vec2 vT;\r\n    varying vec2 vB;\r\n    uniform vec2 texelSize;\r\n    \r\n    void main () {\r\n        vUv = position.xy * 0.5 + 0.5;\r\n        vL = vUv - vec2(texelSize.x, 0.0);\r\n        vR = vUv + vec2(texelSize.x, 0.0);\r\n        vT = vUv + vec2(0.0, texelSize.y);\r\n        vB = vUv - vec2(0.0, texelSize.y);\r\n        gl_Position = vec4(position.xy, 0.0, 1.0);\r\n    }\r\n    `;\r\n\r\nconst blurVertexShader = `\r\n    varying vec2 vUv;\r\n    varying vec2 vL;\r\n    varying vec2 vR;\r\n    uniform vec2 texelSize;\r\n    \r\n    void main () {\r\n        vUv = position.xy * 0.5 + 0.5;\r\n        float offset = 1.33333333;\r\n        vL = vUv - texelSize * offset;\r\n        vR = vUv + texelSize * offset;\r\n        gl_Position = vec4(position.xy, 0.0, 1.0);\r\n    }\r\n    `;\r\n\r\nconst blurShader = `\r\n    varying vec2 vUv;\r\n    varying vec2 vL;\r\n    varying vec2 vR;\r\n    uniform sampler2D uTexture;\r\n    \r\n    void main () {\r\n        vec4 sum = texture2D(uTexture, vUv) * 0.29411764;\r\n        sum += texture2D(uTexture, vL) * 0.35294117;\r\n        sum += texture2D(uTexture, vR) * 0.35294117;\r\n        gl_FragColor = sum;\r\n    }\r\n    `;\r\n\r\nconst copyShader = `\r\n    varying highp vec2 vUv;\r\n    uniform sampler2D uTexture;\r\n    \r\n    void main () {\r\n        gl_FragColor = texture2D(uTexture, vUv);\r\n    }\r\n    `;\r\n\r\nconst clearShader = `\r\n    varying highp vec2 vUv;\r\n    uniform sampler2D uTexture;\r\n    uniform float value;\r\n    \r\n    void main () {\r\n        gl_FragColor = value * texture2D(uTexture, vUv);\r\n    }\r\n    `;\r\n\r\nconst colorShader = `\r\n    uniform vec4 color;\r\n    \r\n    void main () {\r\n        gl_FragColor = color;\r\n    }\r\n    `;\r\n\r\nconst checkerboardShader = `\r\n    varying vec2 vUv;\r\n    uniform sampler2D uTexture;\r\n    uniform float aspectRatio;\r\n    \r\n    #define SCALE 25.0\r\n    \r\n    void main () {\r\n        vec2 uv = floor(vUv * SCALE * vec2(aspectRatio, 1.0));\r\n        float v = mod(uv.x + uv.y, 2.0);\r\n        v = v * 0.1 + 0.8;\r\n        gl_FragColor = vec4(vec3(v), 1.0);\r\n    }\r\n    `;\r\n\r\nconst displayShaderSource = `\r\n    varying vec2 vUv;\r\n    varying vec2 vL;\r\n    varying vec2 vR;\r\n    varying vec2 vT;\r\n    varying vec2 vB;\r\n    uniform sampler2D uTexture;\r\n    uniform sampler2D uBloom;\r\n    uniform sampler2D uSunrays;\r\n    uniform sampler2D uDithering;\r\n    uniform sampler2D uVelocity;\r\n    uniform sampler2D uPressure;\r\n    uniform sampler2D uCurl;\r\n    uniform vec2 ditherScale;\r\n    uniform vec2 texelSize;\r\n    \r\n    vec3 linearToGamma (vec3 color) {\r\n        color = max(color, vec3(0));\r\n        return max(1.055 * pow(color, vec3(0.416666667)) - 0.055, vec3(0));\r\n    }\r\n    \r\n    vec3 acesFilm(const vec3 x) {\r\n        const float a = 2.51;\r\n        const float b = 0.03;\r\n        const float c = 2.43;\r\n        const float d = 0.59;\r\n        const float e = 0.14;\r\n        return clamp((x * (a * x + b)) / (x * (c * x + d ) + e), 0.0, 1.0);\r\n    }\r\n    \r\n    \r\n    void main () {\r\n        vec3 c = texture2D(uTexture, vUv).rgb;\r\n    \r\n    \r\n        float a = max(c.r, max(c.g, c.b));\r\n        gl_FragColor = vec4(c, a);\r\n        // return;  // uncomment to see the base version of the shader\r\n    \r\n    \r\n        vec3 vdata = ((texture2D(uVelocity, vUv).rgb)   * 0.5 + 0.5)  * 0.007;\r\n        vec3 pdata = vec3(0.0, 0.0, texture2D(uPressure, vUv).r * 0.01);\r\n        float cdata = texture2D(uCurl, vUv).r * 0.01;\r\n        vec3 finalVelocityColor = vec3(0.6) + vdata * (1.0 + cdata);\r\n        gl_FragColor = vec4(finalVelocityColor, 1.0);\r\n        // return;  // uncomment to see the velocity version of the shader\r\n    \r\n    \r\n        // // mixed version of the shader\r\n        // gl_FragColor = vec4(c, a) * gl_FragColor * 2.0 + gl_FragColor * 0.25;\r\n        \r\n    \r\n        float x = 0.6 + vdata.x;\r\n        float y = 0.6 + vdata.y;\r\n        float z = 0.6 + vdata.z;\r\n        if(x < 0.0) x = 0.0;\r\n        if(y < 0.0) y = 0.0;\r\n        if(z < 0.0) z = 0.0;\r\n        vec3 vcol = vec3(x,y,z);\r\n        vec3 dcol = vec4(c, a).rgb;\r\n        vec3 fcol = dcol + vcol * 0.25;\r\n        if(fcol.r < 0.0) fcol.r = 0.0;\r\n        if(fcol.g < 0.0) fcol.g = 0.0;\r\n        if(fcol.b < 0.0) fcol.b = 0.0;\r\n    \r\n        gl_FragColor.rgb = acesFilm(fcol);\r\n    }\r\n    `;\r\n\r\nconst splatShader = `\r\n    varying vec2 vUv;\r\n    uniform sampler2D uTarget;\r\n    uniform float aspectRatio;\r\n    uniform vec3 color;\r\n    uniform vec2 point;\r\n    uniform float radius;\r\n    \r\n    void main () {\r\n        vec2 p = vUv - point.xy;\r\n        p.x *= aspectRatio;\r\n        vec3 splat = exp(-dot(p, p) / radius) * color;\r\n        vec3 base = texture2D(uTarget, vUv).xyz;\r\n        gl_FragColor = vec4(base + splat, 1.0);\r\n    }\r\n    `;\r\n\r\nconst advectionShader = `\r\n    varying vec2 vUv;\r\n    uniform sampler2D uVelocity;\r\n    uniform sampler2D uSource;\r\n    uniform vec2 texelSize;\r\n    uniform vec2 dyeTexelSize;\r\n    uniform float dt;\r\n    uniform float dissipation;\r\n    \r\n    void main () {\r\n        vec2 coord = vUv - dt * texture2D(uVelocity, vUv).xy * texelSize;\r\n        vec4 result = texture2D(uSource, coord);\r\n    \r\n        float decay = 1.0 + dissipation * dt;\r\n        gl_FragColor = result / decay;\r\n    }`;\r\n\r\nconst divergenceShader = `\r\n    varying highp vec2 vUv;\r\n    varying highp vec2 vL;\r\n    varying highp vec2 vR;\r\n    varying highp vec2 vT;\r\n    varying highp vec2 vB;\r\n    uniform sampler2D uVelocity;\r\n    \r\n    void main () {\r\n        float L = texture2D(uVelocity, vL).x;\r\n        float R = texture2D(uVelocity, vR).x;\r\n        float T = texture2D(uVelocity, vT).y;\r\n        float B = texture2D(uVelocity, vB).y;\r\n    \r\n        vec2 C = texture2D(uVelocity, vUv).xy;\r\n        if (vL.x < 0.0) { L = -C.x; }\r\n        if (vR.x > 1.0) { R = -C.x; }\r\n        if (vT.y > 1.0) { T = -C.y; }\r\n        if (vB.y < 0.0) { B = -C.y; }\r\n    \r\n        float div = 0.5 * (R - L + T - B);\r\n        gl_FragColor = vec4(div, 0.0, 0.0, 1.0);\r\n    }\r\n    `;\r\n\r\nconst curlShader = `\r\n    varying highp vec2 vUv;\r\n    varying highp vec2 vL;\r\n    varying highp vec2 vR;\r\n    varying highp vec2 vT;\r\n    varying highp vec2 vB;\r\n    uniform sampler2D uVelocity;\r\n    \r\n    void main () {\r\n        float L = texture2D(uVelocity, vL).y;\r\n        float R = texture2D(uVelocity, vR).y;\r\n        float T = texture2D(uVelocity, vT).x;\r\n        float B = texture2D(uVelocity, vB).x;\r\n        float vorticity = R - L - T + B;\r\n        gl_FragColor = vec4(0.5 * vorticity, 0.0, 0.0, 1.0);\r\n    }\r\n    `;\r\n\r\nconst vorticityShader = `\r\n    varying vec2 vUv;\r\n    varying vec2 vL;\r\n    varying vec2 vR;\r\n    varying vec2 vT;\r\n    varying vec2 vB;\r\n    uniform sampler2D uVelocity;\r\n    uniform sampler2D uCurl;\r\n    uniform float curl;\r\n    uniform float dt;\r\n    \r\n    void main () {\r\n        float L = texture2D(uCurl, vL).x;\r\n        float R = texture2D(uCurl, vR).x;\r\n        float T = texture2D(uCurl, vT).x;\r\n        float B = texture2D(uCurl, vB).x;\r\n        float C = texture2D(uCurl, vUv).x;\r\n    \r\n        vec2 force = 0.5 * vec2(abs(T) - abs(B), abs(R) - abs(L));\r\n        force /= length(force) + 0.0001;\r\n        force *= curl * C;\r\n        force.y *= -1.0;\r\n    \r\n        vec2 vel = texture2D(uVelocity, vUv).xy;\r\n        gl_FragColor = vec4(vel + force * dt, 0.0, 1.0);\r\n    }\r\n    `;\r\n\r\nconst pressureShader = `\r\n    varying highp vec2 vUv;\r\n    varying highp vec2 vL;\r\n    varying highp vec2 vR;\r\n    varying highp vec2 vT;\r\n    varying highp vec2 vB;\r\n    uniform sampler2D uPressure;\r\n    uniform sampler2D uDivergence;\r\n    \r\n    void main () {\r\n        float L = texture2D(uPressure, vL).x;\r\n        float R = texture2D(uPressure, vR).x;\r\n        float T = texture2D(uPressure, vT).x;\r\n        float B = texture2D(uPressure, vB).x;\r\n        float C = texture2D(uPressure, vUv).x;\r\n        float divergence = texture2D(uDivergence, vUv).x;\r\n        float pressure = (L + R + B + T - divergence) * 0.25;\r\n        gl_FragColor = vec4(pressure, 0.0, 0.0, 1.0);\r\n    }\r\n    `;\r\n\r\nconst gradientSubtractShader = `\r\n    varying highp vec2 vUv;\r\n    varying highp vec2 vL;\r\n    varying highp vec2 vR;\r\n    varying highp vec2 vT;\r\n    varying highp vec2 vB;\r\n    uniform sampler2D uPressure;\r\n    uniform sampler2D uVelocity;\r\n    \r\n    void main () {\r\n        float L = texture2D(uPressure, vL).x;\r\n        float R = texture2D(uPressure, vR).x;\r\n        float T = texture2D(uPressure, vT).x;\r\n        float B = texture2D(uPressure, vB).x;\r\n        vec2 velocity = texture2D(uVelocity, vUv).xy;\r\n        velocity.xy -= vec2(R - L, T - B);\r\n        gl_FragColor = vec4(velocity, 0.0, 1.0);\r\n    }\r\n    `;\r\n","import { ShaderChunk } from \"three\";\r\n\r\nexport function last(array) {\r\n  return array[array.length - 1];\r\n}\r\n\r\nexport function parseIncludes(string) {\r\n  var utils_includepattern = /#include <(.*)>/gm;\r\n\r\n  function replace(match, include) {\r\n    var replace = ShaderChunk[include];\r\n    return parseIncludes(replace);\r\n  }\r\n\r\n  return string.replace(utils_includepattern, replace);\r\n}\r\n\r\nlet onceMemory = {};\r\nexport function once(tag) {\r\n  if (!onceMemory[tag]) {\r\n    onceMemory[tag] = true;\r\n    return true;\r\n  }\r\n\r\n  return false;\r\n}\r\n","import { DoubleSide, Scene, SphereBufferGeometry } from \"three\";\r\nimport { MeshBasicMaterial } from \"three\";\r\nimport { Vector3 } from \"three\";\r\nimport { Mesh } from \"three\";\r\nimport { Raycaster } from \"three\";\r\nimport { Vector2 } from \"three\";\r\nimport { once } from \"../utils\";\r\n\r\nexport function initCentralRaycast(canvas, camera, onClick) {\r\n  const raycaster = new Raycaster();\r\n  const placeholderScene = new Scene();\r\n\r\n  const centralSphereGeo = new SphereBufferGeometry(0.32, 6, 6);\r\n  const centralSphere = new Mesh(centralSphereGeo, new MeshBasicMaterial({\r\n    color: 0xffffff,\r\n    side: DoubleSide,\r\n  }));\r\n  centralSphere.position.set(0.71, -0.13, -0.05);\r\n  centralSphere.updateMatrixWorld();\r\n\r\n  placeholderScene.add(centralSphere);\r\n\r\n\r\n  let hover = false;\r\n  let clickPt;\r\n\r\n  window.addEventListener(\"mousedown\", (e) => {\r\n    clickPt = new Vector2(\r\n      ( e.clientX / window.innerWidth ) * 2 - 1,\r\n      - ( e.clientY / window.innerHeight ) * 2 + 1,\r\n    );\r\n\r\n    centralCursorEl.classList.add(\"active\");\r\n    outerCursorEl.classList.add(\"active\");\r\n  });\r\n  window.addEventListener(\"mouseup\", (e) => {\r\n    let upClickPt = new Vector2(\r\n      ( e.clientX / window.innerWidth ) * 2 - 1,\r\n      - ( e.clientY / window.innerHeight ) * 2 + 1,\r\n    );\r\n\r\n    // if we didn't move the mouse around and this is an actual click,\r\n    // notify listeners\r\n    if(clickPt.clone().sub(upClickPt).length() < 0.01) {\r\n      onClick(hover);\r\n    }\r\n\r\n    centralCursorEl.classList.remove(\"active\");\r\n    outerCursorEl.classList.remove(\"active\");\r\n  });\r\n\r\n  let outerCursorPos = new Vector2(window.innerWidth * 0.5, window.innerHeight * 0.75);\r\n  let newCursorPos = new Vector2(window.innerWidth * 0.5, window.innerHeight * 0.75);\r\n\r\n  window.addEventListener(\"mousemove\", (e) => {\r\n    let mouse = new Vector2(\r\n      ( e.clientX / window.innerWidth ) * 2 - 1,\r\n      - ( e.clientY / window.innerHeight ) * 2 + 1,\r\n    );\r\n    // update the picking ray with the camera and mouse position\r\n    raycaster.setFromCamera( mouse, camera );\r\n\r\n    newCursorPos.setX(e.clientX);\r\n    newCursorPos.setY(e.clientY);\r\n\r\n    // calculate objects intersecting the picking ray\r\n    const intersects = raycaster.intersectObjects( placeholderScene.children );\r\n    if(intersects[0]) {\r\n\r\n      if(once(\"hide-mouse-icon\")) {\r\n        setTimeout(() => {\r\n          mouseIconEl.classList.add(\"hide\");\r\n          \r\n          setTimeout(() => {\r\n            mouseIconEl.style.display = \"none\";\r\n          }, 500);\r\n        }, 250);\r\n      }\r\n\r\n      hover = true;\r\n      if(!outerCursorEl.classList.contains(\"hover\")) {\r\n        outerCursorEl.classList.add(\"hover\");\r\n      }\r\n\r\n    } else {\r\n      hover = false;\r\n      if(outerCursorEl.classList.contains(\"hover\")) {\r\n        outerCursorEl.classList.remove(\"hover\");\r\n      }\r\n    }\r\n  });\r\n\r\n\r\n  let centralCursorEl = document.querySelector(\".central-cursor\");\r\n  let outerCursorEl = document.querySelector(\".outer-cursor\");\r\n  let mouseIconEl = document.querySelector(\".mouse-icon\");\r\n\r\n  let ccr = centralCursorEl.getBoundingClientRect();\r\n  let ocr = outerCursorEl.getBoundingClientRect();\r\n  let mcr = mouseIconEl.getBoundingClientRect();\r\n\r\n  function update(deltatime) {\r\n    // exponential average outerCursor's pos\r\n    let exponentialAverageFactor = 0.8;\r\n    outerCursorPos.multiplyScalar(exponentialAverageFactor).add(newCursorPos.clone().multiplyScalar(1 - exponentialAverageFactor));\r\n\r\n    centralCursorEl.style.left = `${newCursorPos.x - ccr.width * 0.5}px`;\r\n    centralCursorEl.style.top  = `${newCursorPos.y - ccr.height * 0.5}px`;\r\n\r\n    outerCursorEl.style.left = `${outerCursorPos.x - ocr.width * 0.5}px`;\r\n    outerCursorEl.style.top  = `${outerCursorPos.y - ocr.height * 0.5}px`;\r\n\r\n    // central point projection\r\n    // let ndcMousePos = new Vector3(0.71, -0.13, -0.05).project(camera);\r\n    let ndcMousePos = new Vector3(0.87, 0, -0.15).project(camera);\r\n    ndcMousePos.multiplyScalar(0.5).addScalar(0.5).multiply(new Vector3(window.innerWidth, window.innerHeight, 0));\r\n\r\n    mouseIconEl.style.left = `${ndcMousePos.x - mcr.width * 0.5}px`;\r\n    mouseIconEl.style.top  = `${window.innerHeight - (ndcMousePos.y - mcr.height * 0.5)}px`;\r\n  }\r\n\r\n  // public API\r\n  return {\r\n    update\r\n  }\r\n}","let saturate = `\r\nfloat sat( float t ) {\r\n\treturn clamp( t, 0.0, 1.0 );\r\n}\r\n\r\nvec2 sat( vec2 t ) {\r\n\treturn clamp( t, 0.0, 1.0 );\r\n}`;\r\n\r\n// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - \r\n\r\nlet remap = `\r\n//remaps inteval [a;b] to [0;1]\r\nfloat remap ( float t, float a, float b ) {\r\n\treturn sat( (t - a) / (b - a) );\r\n}`;\r\n\r\n// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - \r\n\r\nlet linterp = `\r\n//note: /\\ t=[0; 0.5; 1], y=[0; 1; 0]\r\nfloat linterp( float t ) {\r\n\treturn sat( 1.0 - abs( 2.0*t - 1.0 ) );\r\n}\r\n`;\r\n\r\n// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - \r\n\r\n// **** REQUIRES ****:   remap, linterp\r\nlet spectrum_offset = `\r\n// given t = [0, 1] \r\n// if t < 0.5    lo = 0 & hi = 1  else  lo = 1 && hi = 0\r\n// 'w' will take the form:  [0, 1, 0] and 'neg_w' = [1, 0, 1]\r\nvec3 spectrum_offset( float t ) {\r\n\tvec3 ret;\r\n    // remember that t is the edge, not 0.5... so it's a bit confusing since normally you'd expect\r\n    // for this call to be written as: step(0.5 /* edge */, t /* x */) as per the specs on:\r\n    // https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/step.xhtml\r\n    float lo = step(t, 0.5);\r\n\tfloat hi = 1.0-lo;\r\n    \r\n    // float w = linterp( remap( t, 0.166, 0.833 ) );\r\n    float w = linterp( t );\r\n\tfloat neg_w = 1.0 - w;\r\n    \r\n    // t = 0:       vec3(0,1,1)     * vec3(1.0, 0.0, 1.0);  -->  return vec3(0.0, 0.0, 1.0);\r\n    // t = 0.1:     vec3(0,1,1)     * vec3(0.8, 0.2, 0.8);  -->  return vec3(0.0, 0.2, 0.8);\r\n    // t = 0.2:     vec3(0,1,1)     * vec3(0.6, 0.4, 0.6);  -->  return vec3(0.0, 0.4, 0.6);\r\n    // t = 0.3:     vec3(0,1,1)     * vec3(0.4, 0.6, 0.4);  -->  return vec3(0.0, 0.6, 0.4);\r\n    // t = 0.4:     vec3(0,1,1)     * vec3(0.2, 0.8, 0.2);  -->  return vec3(0.0, 0.8, 0.2);\r\n    // t = 0.5:     vec3(0,1,1)     * vec3(0.0, 1.0, 0.0);  -->  return vec3(0.0, 1.0, 0.0);\r\n    // t = 0.6:     vec3(1,1,0)     * vec3(0.2, 0.8, 0.2);  -->  return vec3(0.2, 0.8, 0.0);\r\n    // t = 0.7:     vec3(1,1,0)     * vec3(0.4, 0.6, 0.4);  -->  return vec3(0.4, 0.6, 0.0);\r\n    // t = 0.8:     vec3(1,1,0)     * vec3(0.6, 0.4, 0.6);  -->  return vec3(0.6, 0.4, 0.0);\r\n    // t = 0.9:     vec3(1,1,0)     * vec3(0.8, 0.2, 0.8);  -->  return vec3(0.8, 0.2, 0.0);\r\n    // t = 1.0:     vec3(1,1,0)     * vec3(1.0, 0.0, 1.0);  -->  return vec3(1.0, 0.0, 0.0);\r\n\tret =           vec3(lo,1.0,hi) * vec3(neg_w, w, neg_w);\r\n\t// return pow( ret, vec3(1.0/2.2) );\r\n\treturn ret;\r\n}\r\n`;\r\n\r\n// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - \r\n\r\nlet rand = `\r\n// note: [0;1]\r\nfloat rand( vec2 n ) {\r\n    return fract(sin(dot(n.xy, vec2(12.9898, 78.233)))* 43758.5453);\r\n}\r\n  \r\n// note: [-1;1]\r\nfloat srand( vec2 n ) {\r\n    return rand(n) * 2.0 - 1.0;\r\n}\r\n`;  \r\n\r\n// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - \r\n\r\nexport {\r\n    saturate, \r\n    remap, \r\n    linterp,\r\n    spectrum_offset,\r\n    rand,\r\n};","import * as THREE from \"three\";\r\nimport { linterp, rand, remap, saturate, spectrum_offset } from \"./shaderFragments\";\r\n\r\nexport default class PostProcess {\r\n    constructor(renderer, positionRT) {\r\n        this.material = new THREE.ShaderMaterial({\r\n            uniforms: {\r\n                uTexture: { type: \"t\", value: null },\r\n                uPosition: { type: \"t\", value: positionRT.texture },\r\n                uWindLevel: { value: 0 },\r\n                uTime: { value: 0 },\r\n                uSphereActiveTimer: { value: 0 },\r\n                uAspect: { value: window.innerWidth / window.innerHeight },\r\n                uBottomDistortion: { value: 0.5 },\r\n                uDispersion: { value: 0 },\r\n            },\r\n            \r\n            vertexShader: `\r\n                varying vec2 vUv;\r\n\r\n                void main() {\r\n                    vUv = uv;\r\n                    gl_Position = vec4(position.xy, 0.0, 1.0);    \r\n                }\r\n            `,\r\n\r\n            fragmentShader: `\r\n                uniform sampler2D uTexture;\r\n                uniform sampler2D uPosition;\r\n                uniform float uWindLevel;\r\n                uniform float uTime;\r\n                uniform float uSphereActiveTimer;\r\n                uniform float uAspect;\r\n                uniform bool  uBottomDistortion;\r\n                uniform float uDispersion;\r\n\r\n                varying vec2 vUv;\r\n\r\n                ${rand}\r\n                ${saturate}\r\n                ${remap}\r\n                ${linterp}\r\n                ${spectrum_offset}\r\n\r\n\r\n                /* discontinuous pseudorandom uniformly distributed in [-0.5, +0.5]^3 */\r\n                vec3 random3(vec3 c) {\r\n                    float j = 4096.0*sin(dot(c,vec3(17.0, 59.4, 15.0)));\r\n                    vec3 r;\r\n                    r.z = fract(512.0*j);\r\n                    j *= .125;\r\n                    r.x = fract(512.0*j);\r\n                    j *= .125;\r\n                    r.y = fract(512.0*j);\r\n                    return r-0.5;\r\n                }\r\n                \r\n                const float F3 =  0.3333333;\r\n                const float G3 =  0.1666667;\r\n                \r\n                /* 3d simplex noise */\r\n                float simplex3d(vec3 p) {\r\n                     vec3 s = floor(p + dot(p, vec3(F3)));\r\n                     vec3 x = p - s + dot(s, vec3(G3));\r\n                     vec3 e = step(vec3(0.0), x - x.yzx);\r\n                     vec3 i1 = e*(1.0 - e.zxy);\r\n                     vec3 i2 = 1.0 - e.zxy*(1.0 - e);\r\n                     vec3 x1 = x - i1 + G3;\r\n                     vec3 x2 = x - i2 + 2.0*G3;\r\n                     vec3 x3 = x - 1.0 + 3.0*G3;\r\n                     vec4 w, d;\r\n                     w.x = dot(x, x);\r\n                     w.y = dot(x1, x1);\r\n                     w.z = dot(x2, x2);\r\n                     w.w = dot(x3, x3);\r\n                     w = max(0.6 - w, 0.0);\r\n                     d.x = dot(random3(s), x);\r\n                     d.y = dot(random3(s + i1), x1);\r\n                     d.z = dot(random3(s + i2), x2);\r\n                     d.w = dot(random3(s + 1.0), x3);\r\n                     w *= w;\r\n                     w *= w;\r\n                     d *= w;\r\n                     return dot(d, vec4(52.0));\r\n                }\r\n                const mat3 rot1 = mat3(-0.37, 0.36, 0.85,-0.14,-0.93, 0.34,0.92, 0.01,0.4);\r\n                const mat3 rot2 = mat3(-0.55,-0.39, 0.74, 0.33,-0.91,-0.24,0.77, 0.12,0.63);\r\n                const mat3 rot3 = mat3(-0.71, 0.52,-0.47,-0.08,-0.72,-0.68,-0.7,-0.45,0.56);\r\n                float simplex3d_fractal(vec3 m) {\r\n                    return   0.5333333*simplex3d(m*rot1)\r\n                            +0.2666667*simplex3d(2.0*m*rot2)\r\n                            +0.1333333*simplex3d(4.0*m*rot3)\r\n                            +0.0666667*simplex3d(8.0*m);\r\n                }\r\n\r\n                // vec4 block:  .xy bottomcoords - .zw topcoords\r\n                float isInBlock(vec2 uv, vec4 block) {\r\n                    vec2 a = sign(uv - block.xy);\r\n                    vec2 b = sign(block.zw - uv);\r\n                    return min(sign(a.x + a.y + b.x + b.y - 3.), 0.);\r\n                }\r\n\r\n                vec2 moveDiff(vec2 uv, vec4 swapA, vec4 swapB) {\r\n                    vec2 diff = swapB.xy - swapA.xy;\r\n                    return diff * isInBlock(uv, swapA);\r\n                }\r\n\r\n                vec2 randSwap(\r\n                    vec2 uv, \r\n                    vec2 gridSize, /* in uv space */\r\n                    vec2 subGridSize, /* e.g. vec2(3, 3) for a 3x3 grid */ \r\n                    float time,\r\n                    inout float dispersion\r\n                ) {\r\n                    vec2 gridBottom = uv - mod(uv, gridSize);\r\n                    vec2 gridCenter = gridBottom + gridSize * 0.5;\r\n\r\n                    if(uBottomDistortion) {\r\n                        uv.y += srand(gridBottom) * 0.025;\r\n                    }\r\n\r\n                    float subGridCellsCount = subGridSize.x * subGridSize.y;\r\n\r\n                    float gridRand1 = rand(gridCenter + vec2(time));\r\n                    float gridRand2 = rand(gridBottom + vec2(time));\r\n\r\n                    dispersion += srand(gridBottom + vec2(time)) * (gridSize.x + gridSize.y);\r\n\r\n                    float randSubGridIdx1 = floor( gridRand1 * subGridCellsCount  );\r\n                    float randSubGridIdx2 = floor( gridRand2 * subGridCellsCount  );\r\n\r\n                    vec2 subCellSize = gridSize / subGridSize;\r\n                    \r\n                    vec2 scell1Bottom = gridBottom + vec2(\r\n                        mod(randSubGridIdx1, subGridSize.x) * subCellSize.x,\r\n                        floor(randSubGridIdx1 / subGridSize.x) * subCellSize.y\r\n                    );\r\n                    vec2 scell2Bottom = gridBottom + vec2(\r\n                        mod(randSubGridIdx2, subGridSize.x) * subCellSize.x,\r\n                        floor(randSubGridIdx2 / subGridSize.x) * subCellSize.y\r\n                    );\r\n                    \r\n                    vec4 swapA = vec4(scell1Bottom, scell1Bottom + subCellSize);\r\n                    vec4 swapB = vec4(scell2Bottom, scell2Bottom + subCellSize);\r\n\r\n                    vec2 newUv = uv;\r\n                    // if we're in swapA, move to swapB\r\n                    newUv += moveDiff(uv, swapA, swapB);\r\n                    // if we're in swapB, move to swapA\r\n                    newUv += moveDiff(uv, swapB, swapA);\r\n                    return newUv;\r\n                }\r\n\r\n                void main() {\r\n                    float rgbOffs = 0.0;\r\n                    vec2 windOffs = vec2(0.0);\r\n\r\n                    vec3 position = texture2D(uPosition, vUv).xyz;\r\n\r\n                    if(uWindLevel > 0.0) {\r\n                        float noisex = simplex3d(vec3(uTime * 1.5, 0.0, 0.0));\r\n                        float noisey = simplex3d(vec3(uTime * 1.5 + 57.897, 0.0, 0.0));\r\n\r\n                        windOffs = vec2(noisex, noisey) * uWindLevel * 0.0035;\r\n\r\n                        rgbOffs += uWindLevel * 0.006 * length(vUv - vec2(0.5));\r\n                    } \r\n\r\n                    // vec3 c1 = texture2D(uTexture, vUv + windOffs + vec2(-rgbOffs, 0.0)).xyz;\r\n                    // vec3 c2 = texture2D(uTexture, vUv + windOffs + vec2(0.0, 0.0)).xyz;\r\n                    // vec3 c3 = texture2D(uTexture, vUv + windOffs + vec2(+rgbOffs, 0.0)).xyz;\r\n\r\n                    // vec3 finalColor = vec3(c1.x, c2.y, c3.z);\r\n                    // gl_FragColor = vec4(finalColor, 1.0); \r\n\r\n\r\n                    vec2 nuvs = vUv + windOffs;\r\n\r\n                    float sphereActiveTime = uSphereActiveTimer;\r\n                    float strength = 0.0;\r\n                    float targetDist = length(vec3(position.x, 0.0, position.z) - vec3(0.71, 0.0, -0.05));\r\n\r\n                    sphereActiveTime -= 0.3;\r\n                    if(targetDist > 0.5 && targetDist < 0.65 && position.y < -0.4575) {\r\n                        strength += 0.15 * clamp(sphereActiveTime, 0.0, 1.0);\r\n                    }\r\n\r\n                    sphereActiveTime -= 0.5;\r\n                    if(targetDist > 0.75 && targetDist < 0.8 && position.y < -0.40) {\r\n                        strength += 0.15 * clamp(sphereActiveTime, 0.0, 1.0);\r\n                    }\r\n                    \r\n                    float modT = mod(uTime, 5.0);\r\n                    sphereActiveTime -= 0.2;\r\n                    if(targetDist > modT && targetDist < (0.6 + modT)) {\r\n                        float mid = 0.3 + modT;\r\n                        float t = 1.0 - abs(targetDist - mid) / 0.3;\r\n\r\n                        if(targetDist < 0.9) t = 0.0;\r\n                        if(targetDist > 4.0) t *= 1.0 - (targetDist - 4.0);\r\n\r\n                        strength += t * 0.15 * clamp(sphereActiveTime, 0.0, 1.0);\r\n                    }\r\n\r\n                    {\r\n                        float modT = mod(uTime * 2.0 + 1.0, 10.0);\r\n                        if(targetDist > modT && targetDist < (0.3 + modT)) {\r\n                            float mid = 0.15 + modT;\r\n                            float t = 1.0 - abs(targetDist - mid) / 0.15;\r\n    \r\n                            if(targetDist < 0.9) t = 0.0;\r\n                            if(targetDist > 4.0) t *= 1.0 - (targetDist - 4.0);\r\n    \r\n                            strength += t * 0.15 * clamp(sphereActiveTime, 0.0, 1.0);\r\n                        }\r\n                    }\r\n                    \r\n\r\n\r\n\r\n                    float time = uTime;\r\n                    float dispersion = 0.0;\r\n                    float nullop = 0.0; // we'll use this value instead of dispersion just because the compiler complaints if I don't do it\r\n\r\n                    vec2 uv = randSwap(nuvs, vec2(0.40 + nuvs.x * 0.0000025, 0.20),  vec2(3.0, 3.0), time - mod(time, 0.15), dispersion);\r\n                    uv      = randSwap(uv,  vec2(0.02 + uv.x  * 0.0000025, 0.015), vec2(3.0, 2.0), time - mod(time, 0.05), nullop);\r\n                    uv      = randSwap(uv,  vec2(0.06 + uv.x  * 0.0000025, 0.12),  vec2(2.0, 3.0), time - mod(time, 0.02), nullop);\r\n                    uv      = randSwap(uv,  vec2(0.35 + uv.x  * 0.0000025, 0.35),  vec2(2.0, 2.0), time - mod(time, 0.07), dispersion);\r\n\r\n                    vec2 dist = nuvs - uv;\r\n                    uv += dist * (1.0 - strength);\r\n                    dispersion = sat(dispersion) * strength * 15.0;\r\n\r\n\r\n                    float direction = rand(vec2(dispersion)) > 0.5 ? -1.0 : 1.0;\r\n                    const int steps = 10;\r\n                    vec3 sum = vec3(0.0);\r\n                    vec3 cumw = vec3(0.0);\r\n\r\n                    // rand pixel offset to ease dispersion a bit\r\n                    uv.x += srand(uv) * 0.01 * dispersion;\r\n\r\n                    for(int i = 0; i < steps; i++) {\r\n                        float t = float(i) / float(steps);\r\n                        vec2 dispUv = uv + vec2(dispersion * 0.1 * direction * t, 0.0);\r\n                        vec3 spectr = spectrum_offset(t);\r\n                        cumw += spectr;\r\n                        sum += texture2D(uTexture, dispUv).rgb * spectr;\r\n                    }\r\n\r\n                    gl_FragColor = vec4(sum / cumw, 1.0);\r\n                }\r\n            `,\r\n\r\n            depthTest:  false,\r\n            depthWrite: false,\r\n        });\r\n\r\n        this.mesh = new THREE.Mesh(new THREE.PlaneBufferGeometry(2,2), this.material);\r\n        this.camera = new THREE.PerspectiveCamera( 45, 1 /* remember that the camera is worthless here */, 1, 1000 );\r\n        this.renderer = renderer;\r\n\r\n        this.scene = new THREE.Scene();\r\n        this.scene.add(this.mesh);\r\n    }\r\n\r\n    compute({ windLevel, time, sphereActiveTimer }, textureFrom, renderTargetDest) {\r\n        this.renderer.setRenderTarget(renderTargetDest);\r\n\r\n        this.material.uniforms.uTexture.value = textureFrom;\r\n        this.material.uniforms.uWindLevel.value = windLevel;\r\n        this.material.uniforms.uTime.value = time;\r\n        this.material.uniforms.uSphereActiveTimer.value = sphereActiveTimer;\r\n        this.renderer.render(this.scene, this.camera);\r\n\r\n        this.renderer.setRenderTarget(null);\r\n    }\r\n}","import { MeshBasicMaterial } from \"three\";\r\nimport { DoubleSide, ShaderMaterial } from \"three\";\r\n\r\nexport const mountainsMaterial = (texture) => {\r\n  return new ShaderMaterial({\r\n    side: DoubleSide,\r\n    \r\n    uniforms: {\r\n      map: { type: \"t\", value: texture },\r\n      uTime: { value: 0 },\r\n      uSphereActiveTimer: { value: 0 },\r\n    },\r\n\r\n    vertexShader: `\r\n      varying vec3 vFragPos;\r\n      varying vec2 vUv;\r\n\r\n      void main() {\r\n\r\n\r\n        // ******* this code block is necessary for compatibility with\r\n        // reflectable-material ********\r\n        vec4 mvPosition = vec4(position, 1.0);\r\n        mvPosition = modelViewMatrix * mvPosition;\r\n        // ******* this code block is necessary for compatibility with\r\n        // reflectable-material ********\r\n\r\n\r\n        gl_Position = projectionMatrix * mvPosition;\r\n        vFragPos = (modelMatrix * vec4(position, 1.0)).xyz;\r\n\r\n        vUv = uv;\r\n      }\r\n    `,\r\n\r\n    fragmentShader: `\r\n      varying vec3 vFragPos;\r\n      varying vec2 vUv;\r\n   \r\n      uniform sampler2D map;\r\n      uniform float uTime;\r\n      uniform float uSphereActiveTimer;\r\n\r\n      vec2 GetGradient(vec2 intPos, float t) {\r\n        // Uncomment for calculated rand\r\n        float rand = fract(sin(dot(intPos, vec2(12.9898, 78.233))) * 43758.5453);;\r\n        \r\n        // Texture-based rand (a bit faster on my GPU)\r\n        // float rand = texture(iChannel0, intPos / 64.0).r;\r\n        \r\n        // Rotate gradient: random starting rotation, random rotation rate\r\n        float angle = 6.283185 * rand + 4.0 * t * rand;\r\n        return vec2(cos(angle), sin(angle));\r\n      }\r\n    \r\n      float Pseudo3dNoise(vec3 pos) {\r\n        vec2 i = floor(pos.xy);\r\n        vec2 f = pos.xy - i;\r\n        vec2 blend = f * f * (3.0 - 2.0 * f);\r\n        float noiseVal = \r\n            mix(\r\n                mix(\r\n                    dot(GetGradient(i + vec2(0, 0), pos.z), f - vec2(0, 0)),\r\n                    dot(GetGradient(i + vec2(1, 0), pos.z), f - vec2(1, 0)),\r\n                    blend.x),\r\n                mix(\r\n                    dot(GetGradient(i + vec2(0, 1), pos.z), f - vec2(0, 1)),\r\n                    dot(GetGradient(i + vec2(1, 1), pos.z), f - vec2(1, 1)),\r\n                    blend.x),\r\n            blend.y\r\n        );\r\n        return noiseVal / 0.7; // normalize to about [-1..1]\r\n      }\r\n    \r\n\r\n      void main() {\r\n        // this is only necessary for compatibility with reflectable-material\r\n        // you can assume that this line doesn't exist at all\r\n        gl_FragColor = linearToOutputTexel( gl_FragColor );\r\n\r\n        float noiseVisibility = clamp(uSphereActiveTimer - 0.5, 0.0, 1.0);\r\n\r\n        vec3 color = texture2D(map, vUv).xyz;\r\n\r\n        vec2 nuv = vec2(vFragPos.x, vFragPos.z);\r\n\r\n        float offset = uTime * 0.01;\r\n        \r\n        float noise = (vFragPos.x + 99.0) * 10.0 + \r\n          (Pseudo3dNoise(vec3(nuv, offset * 6.0) * 0.5) * 0.5 + 0.5) * 30.0 + \r\n          (Pseudo3dNoise(vec3(nuv, offset * 0.5) * 4.0) * 0.5 + 0.5) * 6.0 +\r\n          (Pseudo3dNoise(vec3(nuv, offset * 0.5) * 20.0) * 0.5 + 0.5) * 1.1 +  \r\n          (Pseudo3dNoise(vec3(nuv, offset * 0.5) * 40.0) * 0.5 + 0.5) * 0.5 \r\n        ;\r\n        float modnoise = mod(noise, 3.0);\r\n        float opwindow = 0.09;\r\n        float linewidth = 0.3;\r\n\r\n        if(modnoise > linewidth) {\r\n          noise = 0.0;\r\n        } else if (modnoise > linewidth - opwindow) {\r\n          noise = 1.0 - (modnoise - (linewidth-opwindow)) / opwindow;\r\n        } else if (modnoise < opwindow) {\r\n          noise = modnoise / opwindow;\r\n        } else {\r\n          noise = 1.0;\r\n        }\r\n        noise *= 1.65 * noiseVisibility;\r\n\r\n\r\n        // time-based noise animation\r\n        float timeMult = 1.0;\r\n        float animT = mod(uTime * timeMult, 30.0);\r\n\r\n        if(animT > 3.5 && animT < 5.0) {\r\n          float t = (animT - 3.5) / 1.5;\r\n\r\n          float targetDist = (t - 0.15) * 9.0;\r\n          float dist = length(vec3(vFragPos.x, 0.0, vFragPos.z) - vec3(0.71, 0.0, -0.05));\r\n          \r\n          dist += Pseudo3dNoise(vec3(nuv, uTime * 0.2) * 4.7) * 0.35;\r\n          dist = abs(dist - targetDist);\r\n\r\n          dist = 1.0 - clamp(dist, 0.0, 0.9) / 0.9;\r\n        \r\n          noise *= dist;\r\n          noise *= 2.0;\r\n          color *= 1.0 + noise;\r\n\r\n        } else if(animT > 5.5 && animT < 6.5) {\r\n          float t = ((animT - 5.5) / 1.0) * 3.0 - 1.5;\r\n          t += Pseudo3dNoise(vec3(nuv, uTime * 0.2) * 4.7) * 1.0;\r\n          t = clamp(t, 0.0, 1.0);\r\n          noise *= t;\r\n          color *= 1.0 + noise;\r\n        } else if(animT > 6.5 && animT < 11.0) {\r\n\r\n          color *= 1.0 + noise;\r\n\r\n        } else if(animT > 11.0 && animT < 12.0) {\r\n          float t = -((animT - 11.0) / 1.0) * 3.0 + 1.5;\r\n          t += Pseudo3dNoise(vec3(nuv, uTime * 0.2) * 4.7) * 1.0;\r\n          t = clamp(t, 0.0, 1.0);\r\n          noise *= t;\r\n          color *= 1.0 + noise;\r\n        \r\n        } else if(animT < 16.0) {\r\n          // pause          \r\n        } else if(animT > 16.0 && animT < 24.0) {\r\n          float t = ((animT - 16.0) / 2.0) * 3.0 - 1.5;\r\n          t += Pseudo3dNoise(vec3(nuv, uTime * 0.2) * 2.0) * 0.8;\r\n          t += Pseudo3dNoise(vec3(nuv, uTime * 0.2) * 0.65) * 0.2;\r\n          t = clamp(t, 0.0, 1.0) * noiseVisibility;\r\n\r\n          color = mix(color, color * noise * 0.5 + color * 0.07, t);\r\n        } else if (animT > 24.0 && animT < 26.0) {\r\n          float t = -((animT - 24.0) / 2.0) * 3.0 + 1.5;\r\n          t += Pseudo3dNoise(vec3(nuv, uTime * 0.2) * 2.0) * 0.8;\r\n          t += Pseudo3dNoise(vec3(nuv, uTime * 0.2) * 0.65) * 0.2;\r\n          t = clamp(t, 0.0, 1.0) * noiseVisibility;\r\n\r\n          color = mix(color, color * noise * 0.5 + color * 0.07, t);\r\n        }\r\n\r\n        gl_FragColor = vec4(color, 1.0);\r\n      }\r\n    `,\r\n  });\r\n};\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n\r\nbackup\r\n\r\n // time-based noise animation\r\n        float timeMult = 1.0;\r\n        float animT = mod(uTime * timeMult, 15.0);\r\n        bool darkmode = false;\r\n        \r\n        if(mod(uTime * timeMult, 45.0) < 15.0) {\r\n          // darkmode = true;\r\n        }\r\n\r\n        if(animT > 3.5 && animT < 5.0) {\r\n          float t = (animT - 3.5) / 1.5;\r\n\r\n          float targetDist = (t - 0.15) * 9.0;\r\n          float dist = length(vec3(vFragPos.x, 0.0, vFragPos.z) - vec3(0.71, 0.0, -0.05));\r\n          dist = abs(dist - targetDist);\r\n\r\n          dist = 1.0 - clamp(dist, 0.0, 0.9) / 0.9;\r\n        \r\n          noise *= dist;\r\n          noise *= 2.0;\r\n        } else if(animT > 5.5 && animT < 6.5) {\r\n          float t = ((animT - 5.5) / 1.0) * 3.0 - 1.5;\r\n          t += Pseudo3dNoise(vec3(nuv, uTime * 0.2) * 4.7) * 1.0;\r\n          t = clamp(t, 0.0, 1.0);\r\n          noise *= t;\r\n          if(darkmode) {\r\n            color *= (1.0 - t) * 0.83 + 0.17;\r\n            noise *= 2.5;\r\n          }\r\n        } else if(animT > 6.5 && animT < 11.0) {\r\n          if(darkmode) {\r\n            color *= 0.17;\r\n            noise *= 2.5;\r\n          } \r\n        } else if(animT > 11.0 && animT < 12.0) {\r\n          float t = -((animT - 11.0) / 1.0) * 3.0 + 1.5;\r\n          t += Pseudo3dNoise(vec3(nuv, uTime * 0.2) * 4.7) * 1.0;\r\n          t = clamp(t, 0.0, 1.0);\r\n          noise *= t;\r\n          \r\n          if(darkmode) {\r\n            color *= (1.0 - t) * 0.83 + 0.17;\r\n            noise *= 2.5;\r\n          }\r\n        } else {\r\n          noise *= 0.0;\r\n        }\r\n\r\n\r\n\r\n */","import { parseIncludes } from \"../utils\";\r\n\r\nexport function ReflectableMaterial(material) {\r\n  material.userData.uReflect = { value: false };\r\n  material.userData.uReflectPositionPass = { value: false };\r\n  material.reflectable = true;\r\n\r\n  material.onBeforeCompile = (shader) => {\r\n    let prependUniforms = [\r\n      \"uniform bool uReflect;\\n\",\r\n      \"uniform bool uReflectPositionPass;\\n\",\r\n      \"varying vec3 vReflectedPos;\\n\"\r\n    ].join(\"\\n\");\r\n\r\n    let prependDefines = \"\";\r\n\r\n\r\n    // let val = \"0.460000\";\r\n    let val1 = \"+ 0.92\";\r\n    let val2 = \"- 0.46\";\r\n\r\n    shader.uniforms.uReflect = material.userData.uReflect;\r\n    shader.uniforms.uReflectPositionPass = material.userData.uReflectPositionPass;\r\n\r\n    shader.vertexShader = parseIncludes(shader.vertexShader); \r\n    shader.vertexShader = shader.vertexShader.replace(\r\n      \"mvPosition = modelViewMatrix * mvPosition;\",\r\n      `\r\n        mvPosition = modelMatrix * mvPosition;\r\n        if(uReflect) {\r\n          mvPosition.y = -(mvPosition.y ${val1});\r\n        }\r\n        vReflectedPos = mvPosition.xyz;\r\n        mvPosition = viewMatrix * mvPosition;\r\n      `,\r\n    );\r\n    shader.vertexShader = prependDefines + prependUniforms + shader.vertexShader;\r\n\r\n    shader.fragmentShader = parseIncludes(shader.fragmentShader); \r\n    shader.fragmentShader = shader.fragmentShader.replace(\r\n      \"gl_FragColor = linearToOutputTexel( gl_FragColor );\",\r\n      `\r\n      gl_FragColor = linearToOutputTexel( gl_FragColor );\r\n      if(uReflect && vReflectedPos.y > ${val2}) {\r\n        discard;\r\n      }\r\n\r\n      if(uReflectPositionPass) {\r\n        gl_FragColor = vec4(vReflectedPos, 1.0);\r\n        return;\r\n      }\r\n      `,\r\n    );\r\n    shader.fragmentShader = prependDefines + prependUniforms + shader.fragmentShader;\r\n  };\r\n\r\n  return material;\r\n}","import { ShaderMaterial, Vector3, Vector2, DoubleSide } from \"three\";\r\n\r\nexport function WaterMaterial() {\r\n  let program = new ShaderMaterial({\r\n    vertexShader: `\r\n      varying vec3 vFragPos;\r\n      varying vec3 vNormal;\r\n      varying mat4 vProjViewMatrix;\r\n      varying mat4 vViewMatrix;\r\n\r\n      void main() {\r\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0); \r\n      \r\n        vFragPos = (modelMatrix * vec4(position, 1.0)).xyz;\r\n        vNormal = mat3(transpose(inverse(modelMatrix))) * normal;\r\n        vProjViewMatrix = projectionMatrix * viewMatrix;\r\n        vViewMatrix = viewMatrix;\r\n      }\r\n    `,\r\n  \r\n    fragmentShader: `\r\n    varying vec3 vFragPos;\r\n    varying vec3 vNormal;\r\n    varying mat4 vProjViewMatrix;\r\n    varying mat4 vViewMatrix;\r\n\r\n    uniform sampler2D uMountainsDepth;\r\n    uniform sampler2D uWaterDepth;\r\n    uniform sampler2D uColor;\r\n    uniform sampler2D uBlurredReflectionDistance;\r\n    uniform sampler2D uFluidTexture;\r\n\r\n    uniform vec2 uScreenSize;\r\n    uniform vec2 uPixelSize;\r\n    uniform vec3 uCameraPos;\r\n\r\n    void main() {\r\n      vec3 norm = normalize(vNormal);\r\n\r\n      vec2 uv = gl_FragCoord.xy / uScreenSize.xy;\r\n      \r\n      \r\n      // fluid sim - these calculations need to match inside fluidsim.js as well\r\n      // get plane position\r\n      vec3 sphereCenter = vec3(0.71, -0.13, -0.05);\r\n      vec2 distVec = (vFragPos - sphereCenter).xz * 0.75;\r\n      vec2 fluidUv = clamp(distVec, -1.0, 1.0) * 0.5 + 0.5;\r\n      \r\n      vec3 fluidOffset = vec3(0.0);\r\n      vec3 fluidColor  = vec3(0.2, 0.1, 0.06);\r\n      float fluidAlpha = 0.0;\r\n      vec3 f0 = texture2D(uFluidTexture, fluidUv).xyz;\r\n      vec3 fdx = texture2D(uFluidTexture, fluidUv + vec2(uPixelSize.x, 0.0)).xyz;\r\n      vec3 fdy = texture2D(uFluidTexture, fluidUv + vec2(0.0, uPixelSize.y)).xyz;\r\n      fluidOffset.x = f0.x - fdx.x;\r\n      fluidOffset.y = f0.y - fdy.x;\r\n      fluidAlpha = clamp(f0.x, 0.0, 1.0);\r\n\r\n      if(distVec.x < -1.0 || distVec.x > 1.0 || distVec.y < -1.0 || distVec.y > 1.0) {\r\n        fluidOffset = vec3(0.0);\r\n        fluidColor  = vec3(0.0);\r\n        fluidAlpha  = 0.0;\r\n      }\r\n      \r\n      uv += fluidOffset.xy * 0.055;\r\n      \r\n      float mountainsDepth = texture2D(uMountainsDepth, uv).x;\r\n      float waterDepth = texture2D(uWaterDepth, uv).x;\r\n\r\n      float diff = max(-(waterDepth - mountainsDepth), 0.0) * 13.0;\r\n      diff = min(diff, 2.5);\r\n      vec3 color = vec3(0.09, 0.027, 0.0);\r\n      float alpha = 1.0 - exp(-diff);\r\n\r\n      vec3 reflectionColor = texture2D(uColor, uv).xyz;\r\n      reflectionColor *= 1.0;\r\n      reflectionColor *= vec3(1.0, 0.8, 0.4);\r\n\r\n\r\n      vec3 colorPlusReflections = color + reflectionColor;\r\n      // vec3 colorWithFluid = mix(colorPlusReflections, fluidColor, fluidAlpha);\r\n      // vec3 colorWithFluid = pow(colorPlusReflections, vec3(1.0 + fluidAlpha * 3.0));\r\n      \r\n      // vec3 colorWithFluid = colorPlusReflections * (1.0 + fluidAlpha * 2.0);\r\n      // colorWithFluid = mix(colorWithFluid, fluidColor, fluidAlpha * 0.9);\r\n\r\n      vec3 colorWithFluid = colorPlusReflections * (1.0 + fluidAlpha * 2.0);\r\n      if(fluidAlpha > 0.75) {\r\n        colorWithFluid = mix(colorWithFluid, fluidColor, (fluidAlpha - 0.75) * 3.5);\r\n      }\r\n\r\n      // vec3 colorWithFluid = colorPlusReflections + (colorPlusReflections - vec3(0.15)) * (fluidAlpha * 2.0);\r\n      // if(fluidAlpha > 0.75) {\r\n      //   colorWithFluid = mix(colorWithFluid, fluidColor, (fluidAlpha - 0.75) * 2.75);\r\n      // }\r\n\r\n\r\n\r\n      gl_FragColor = vec4(colorWithFluid, alpha);\r\n\r\n      // gl_FragColor = texture2D(uPosition, uv, 5.0);\r\n      // gl_FragColor = vec4(norm, 1.0);\r\n      // gl_FragColor = vec4(vFragPos, 1.0);\r\n      // gl_FragColor = vec4(waterDepth < mountainsDepth ? 1.0 : 0.0, 0.0, 0.0, 1.0);\r\n      // gl_FragColor = vec4(vec3(mountainsDepth) * 0.1  , 1.0);\r\n      // gl_FragColor = vec4(vec3(diff), 1.0);\r\n    }\r\n    `,\r\n  \r\n    uniforms: {\r\n      uMountainsDepth: { type: \"t\", value: null },\r\n      uWaterDepth: { type: \"t\", value: null },\r\n      uColor: { type: \"t\", value: null },\r\n      uScreenSize: { value: new Vector2(window.innerWidth, window.innerHeight) },\r\n      uPixelSize: { value: new Vector2(1 / window.innerWidth, 1 / window.innerHeight) },\r\n      uCameraPos: { value: new Vector3(0,0,0) },\r\n      uBlurredReflectionDistance: { type: \"t\", value: null },\r\n      uFluidTexture: { type: \"t\", value: null },\r\n    },\r\n \r\n    side: DoubleSide,     \r\n    transparent: true,\r\n  });\r\n\r\n  return program;\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/*\r\n  unused SSR code\r\n\r\n\r\n\r\n\r\n\r\n  // // SSR\r\n  // float depth = length(vFragPos - uCameraPos);\r\n  // vec3 viewDir = normalize(vFragPos - uCameraPos);\r\n  // if(dot(viewDir, norm) > 0.0) norm = -norm; \r\n  // vec3 mult = vec3(1.0);\r\n  // vec3 reflDir = reflect(viewDir, norm);\r\n  // reflDir = normalize(reflDir);  \r\n  // vec3 rd = reflDir;\r\n  // vec3 ro = vFragPos + reflDir * max(0.01, 0.01 * depth);  \r\n  // vec3 p2;\r\n  // vec3 lastP;\r\n  // vec3 debugColor = vec3(1.0);\r\n  // bool intersected = intersect(ro, rd, p2, lastP, debugColor);\r\n  // if(intersected) {\r\n  //   // intersection validated\r\n  //   vec4 projP2 = vProjViewMatrix * vec4(p2, 1.0);\r\n  //   vec2 p2Uv = (projP2 / projP2.w).xy * 0.5 + 0.5;\r\n  //   vec3 color = vec3(1.0); // texture2D(uColor, p2Uv).xyz;\r\n  //   mult *= debugColor;\r\n  // } else {\r\n  //   // intersection is invalid\r\n  //   mult *= 0.0;\r\n  // }  \r\n  // gl_FragColor.xyz += mult;\r\n\r\n\r\n\r\n\r\n\r\nfloat rand(float co) { return fract(sin(co*(91.3458)) * 47453.5453); }\r\n    float rand(vec2 co)  { return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453); }\r\n    float rand(vec3 co)  { return rand(co.xy+rand(co.z)); }\r\n\r\n    float depthBufferAtP(vec3 p) {\r\n      vec4 projP = vProjViewMatrix * vec4(p, 1.0);\r\n      vec2 pNdc = (projP / projP.w).xy;\r\n      vec2 pUv  = pNdc * 0.5 + 0.5;\r\n      float depthAtPointP = texture2D(uPosition, pUv).w;\r\n      if(depthAtPointP == 0.0) depthAtPointP = 9999999.0; \r\n      return depthAtPointP;\r\n    }\r\n\r\n    bool intersect(\r\n      vec3 ro, vec3 rd, \r\n      out vec3 intersectionP,\r\n      out vec3 lastP,\r\n      out vec3 color) \r\n    {\r\n      // bool jitter = true;\r\n      // float startingStep = 0.05;\r\n      // float stepMult = 1.15;\r\n      // const int steps = 40;\r\n      // const int binarySteps = 5;\r\n      // float maxIntersectionDepthDistance = 1.5;\r\n\r\n      bool jitter = true;\r\n      float startingStep = 0.01;\r\n      float stepMult = 1.055;\r\n      const int steps = 60;\r\n      const int binarySteps = 7;\r\n      float maxIntersectionDepthDistance = 0.05;\r\n\r\n      // vec2 halfPixelOffs = vec2(1.0 / uScreenSize.x, 1.0 / uScreenSize.y) * 0.5;\r\n      float step = startingStep;\r\n      vec3 p = ro;\r\n      bool intersected = false;\r\n      bool possibleIntersection = false;\r\n      float lastRecordedDepthBuffThatIntersected;\r\n      vec3 p1, p2;\r\n      vec3 initialP = p;\r\n      int stepsTaken = 0;\r\n      for(int i = 0; i < steps; i++) {\r\n        stepsTaken = i;\r\n        // at the end of the loop, we'll advance p by jittB to keep the jittered sampling in the proper \"cell\" \r\n        // float jittA = 0.5 + rand(p) * 0.5;\r\n        float jittA = fract(rand(p)); // + uRandoms.x);\r\n        if(!jitter) jittA = 1.0;\r\n        float jittB = 1.0 - jittA;\r\n        p += rd * step * jittA;\r\n        vec4 projP = vProjViewMatrix * vec4(p, 1.0);\r\n        vec2 pNdc = (projP / projP.w).xy;\r\n        vec2 pUv  = (pNdc * 0.5 + 0.5);\r\n        float depthAtPosBuff = texture2D(uPosition, pUv).w;\r\n        if(depthAtPosBuff == 0.0) {\r\n          depthAtPosBuff = 9999999.0;\r\n        } \r\n        // out of screen bounds condition\r\n        if(pUv.x < 0.0 || pUv.x > 1.0 || pUv.y < 0.0 || pUv.y > 1.0) {\r\n          break;\r\n        }\r\n        float depthAtPointP = -(vViewMatrix * vec4(p, 1.0)).z;\r\n        if(depthAtPointP > depthAtPosBuff) {\r\n          // intersection found!\r\n          p1 = initialP;\r\n          p2 = p;\r\n          lastRecordedDepthBuffThatIntersected = depthAtPosBuff;\r\n          possibleIntersection = true;\r\n          break;\r\n        }\r\n        // initialP needs to be the last jittered sample, and can't just be the \"p\" value at the start\r\n        // of the loop iteration, otherwise you run the risk of having both p1 and p2 at the same side of the depth buffer\r\n        // and (apparently) for the binary search to work properly you need to have p1 and p2 on different sides of the depth buffer\r\n        // p1 at the side of the depth buffer plane that it's closer to the camera, and p2 at the other side\r\n        initialP = p;\r\n        p += rd * step * jittB;\r\n        step *= stepMult; // this multiplication obviously need to appear AFTER we add jittB\r\n      }\r\n      // stranamente mi trovo a dover spostare la binary search fuori dal primo loop, altrimenti\r\n      // per qualche motivo esoterico la gpu inizia a prendere fuoco\r\n\r\n      // ******** binary search start *********\r\n      for(int j = 0; j < binarySteps; j++) {\r\n        vec3 mid = (p1 + p2) * 0.5;\r\n        float depthAtMid = - (vViewMatrix * vec4(mid, 1.0)).z;\r\n        float depthAtPosBuff = depthBufferAtP(mid);\r\n        if(depthAtMid > depthAtPosBuff) {\r\n          p2 = (p1 + p2) * 0.5;\r\n          // we need to save this value inside this if-statement otherwise if it was outside and above this\r\n          // if statement, it would be possible that it's value would be very large (e.g. if p1 intersected the \"background\"\r\n          // since in that case positionBufferAtP() returns viewDir * 99999999.0)\r\n          // and if that value is very large, it can create artifacts when evaluating this condition:\r\n          // ---> if(abs(distanceFromCameraAtP2 - lastRecordedDepthBuffThatIntersected) < maxIntersectionDepthDistance) \r\n          // to be honest though, these artifacts only appear for largerish values of maxIntersectionDepthDistance\r\n          lastRecordedDepthBuffThatIntersected = depthAtPosBuff;\r\n        } else {\r\n          p1 = (p1 + p2) * 0.5;\r\n        }\r\n      }\r\n      // ******** binary search end   *********\r\n\r\n      intersectionP = p2;\r\n      lastP = p;\r\n      \r\n      // use p2 as the intersection point\r\n      float depthAtP2 = - (vViewMatrix * vec4(p2, 1.0)).z;\r\n      if( possibleIntersection && // without using possibleIntersection apparently it's possible that lastRecordedDepthBuffThatIntersected\r\n                                  // ends up being valid thanks to the binary search, and that causes all sorts of troubles\r\n          abs(depthAtP2 - lastRecordedDepthBuffThatIntersected) < maxIntersectionDepthDistance\r\n      ) {\r\n        // intersection validated\r\n        intersected = true;\r\n      }\r\n\r\n      return intersected;\r\n    }\r\n*/","import { CustomToneMapping, ShaderChunk } from \"three\";\r\nimport { BufferGeometry } from \"three\";\r\nimport { Clock } from \"three\";\r\nimport { WebGLMultisampleRenderTarget } from \"three\";\r\nimport { ACESFilmicToneMapping, BoxBufferGeometry, Color, CubeCamera, DoubleSide, FloatType, GammaEncoding, LinearEncoding, LinearFilter, LinearMipmapLinearFilter, Mesh, MeshBasicMaterial, MeshPhysicalMaterial, MeshStandardMaterial, NearestFilter, PerspectiveCamera, PlaneBufferGeometry, PMREMGenerator, RGBFormat, Scene, ShaderMaterial, SphereBufferGeometry, sRGBEncoding, TextureLoader, Vector2, Vector3, WebGLCubeRenderTarget, WebGLRenderer, WebGLRenderTarget } from \"three\";\r\nimport { OrbitControls } from \"three/examples/jsm/controls/OrbitControls\";\r\nimport { GLTFLoader } from \"three/examples/jsm/loaders/GLTFLoader\";\r\nimport { mergeBufferGeometries } from \"three/examples/jsm/utils/BufferGeometryUtils\";\r\nimport { smoothstep } from \"three/src/math/MathUtils\";\r\nimport Blit from \"./graphics-components/blit\";\r\nimport BlitDepth from \"./graphics-components/blitDepth\";\r\nimport BlitNormals from \"./graphics-components/blitNormals\";\r\nimport BlitPosition from \"./graphics-components/blitPosition\";\r\nimport BlitReflectedColor from \"./graphics-components/blitReflectedColorRT\";\r\nimport BlitReflectionDistance from \"./graphics-components/blitReflectionDistance\";\r\nimport BlurReflectionDistance from \"./graphics-components/blurReflectionDistance\";\r\nimport CentralParticles from \"./graphics-components/centralParticles\";\r\nimport ComputeFog from \"./graphics-components/computeFog\";\r\nimport Crystals from \"./graphics-components/crystals\";\r\nimport { framebuffers as fluidSimFramebuffers, initFluidSim, initMouseCommands, updateFluidSim } from \"./graphics-components/fluidsim\";\r\nimport LightGrid from \"./graphics-components/lightGrid\";\r\nimport { initCentralRaycast } from \"./graphics-components/mainRaycast\";\r\nimport PostProcess from \"./graphics-components/postProcess\";\r\nimport { linterp, rand, remap, saturate, spectrum_offset } from \"./graphics-components/shaderFragments\";\r\nimport { mountainsMaterial } from \"./materials/mountains\";\r\nimport { ReflectableMaterial } from \"./materials/reflectable\";\r\nimport { WaterMaterial } from \"./materials/water\";\r\nimport { last, once } from \"./utils\";\r\n\r\nlet rnd  = (v = 1) => Math.random() * v;\r\nlet nrnd = (v = 1) => (Math.random() * 2 - 1) * v;\r\n\r\nlet width = window.innerWidth;\r\nlet height = window.innerHeight;\r\n\r\nlet renderer;\r\nlet controls;\r\nlet scene  = new Scene();\r\nlet camera = new PerspectiveCamera( 40, width / height, 0.1, 1000 );\r\nlet blitProgram;\r\nlet mainFramebuffer = new WebGLMultisampleRenderTarget(width, height, { });\r\nmainFramebuffer.texture.encoding = sRGBEncoding;\r\n\r\nlet lightGrid;\r\nlet clock;\r\nlet crystals;\r\n\r\n// **************** this block can be deleted I think **************\r\nlet displayProgram = new ShaderMaterial({\r\n  vertexShader: `\r\n    varying vec2 vUv;\r\n\r\n    void main() {\r\n      gl_Position = vec4(position.xy, 0.0, 1.0); \r\n      vUv = uv;\r\n    }\r\n  `,\r\n\r\n  fragmentShader: `\r\n  varying vec2 vUv;\r\n  \r\n  uniform sampler2D uSceneTex;\r\n  uniform sampler2D uFluidVelocityTex;\r\n  uniform sampler2D uFluidDyeTex;\r\n\r\n  ${saturate}\r\n  ${remap}\r\n  ${linterp}\r\n  ${spectrum_offset}\r\n  ${rand}\r\n  \r\n  void main() {\r\n\r\n    vec4 fluidVel = -texture2D(uFluidVelocityTex, vUv);\r\n    vec4 fluidDye = texture2D(uFluidDyeTex, vUv);\r\n\r\n\r\n    float velStrength = 0.00002;\r\n    velStrength = 0.0;\r\n    float dyeStrength = 0.01;\r\n\r\n    \r\n    vec2 uvOffset1 = fluidVel.xy * velStrength;\r\n    vec2 uvOffset2 = fluidDye.xy * dyeStrength;\r\n    vec2 uvOffset = uvOffset1 + uvOffset2;\r\n\r\n    vec4 accum = vec4(0.0);\r\n    vec3 soAccum = vec3(0.0);\r\n\r\n    int steps = 20;\r\n    float fsteps = float(steps);\r\n    float invSteps = 1.0 / float(steps);\r\n\r\n    for(int i = 0; i < steps; i++) {\r\n      vec2 transformedUv = vUv + uvOffset * ((float(i) * invSteps) * fsteps * 0.85 + fsteps * 0.15);\r\n      uvOffset *= (1.0 + srand(transformedUv + float(i) * 0.1987) * 0.05);\r\n      vec4 color = texture2D(uSceneTex, transformedUv);\r\n\r\n      vec3 so = spectrum_offset(float(i) * invSteps);\r\n      soAccum += so;\r\n\r\n      accum += color * vec4(so, 1.0);\r\n    }\r\n\r\n    accum.rgb /= soAccum;\r\n    accum.a = 1.0;\r\n\r\n\r\n    gl_FragColor = accum;\r\n    // gl_FragColor = fluidVel;\r\n\r\n\r\n    // vec4 fluidVel2 = texture2D(uFluidVelocityTex, vUv);\r\n    // gl_FragColor = fluidVel2;\r\n  }\r\n  `,\r\n\r\n  uniforms: {\r\n    uSceneTex: { type: \"t\", value: null },\r\n    uFluidVelocityTex: { type: \"t\", value: null },\r\n    uFluidDyeTex: { type: \"t\", value: null },\r\n  },\r\n\r\n  depthTest:  false,\r\n  depthWrite: false,\r\n});\r\nlet quad = new Mesh(new PlaneBufferGeometry(2,2), displayProgram);\r\nlet quadCamera = new PerspectiveCamera( 45, 1 /* remember that the camera is worthless here */, 1, 1000 );\r\nlet quadScene = new Scene();\r\nquadScene.add(quad);\r\n// **************** this block can be deleted I think **************\r\n\r\n\r\nlet planeScene = new Scene();\r\n\r\nlet whiteRocks = [];\r\nlet plane;\r\nlet sphere;\r\n\r\nlet mountainsDepthScene = new Scene();\r\nlet mountainsDepthRT = new WebGLRenderTarget(width, height, { type: FloatType });\r\nlet waterScene = new Scene();\r\nlet waterDepthRT = new WebGLRenderTarget(width, height, { type: FloatType });\r\nlet depthProgram;\r\n\r\nlet bundledTorusesScene = new Scene();\r\n\r\nlet cursorAPI;\r\n\r\nlet colorRT = new WebGLRenderTarget(width, height, { \r\n});\r\ncolorRT.texture.encoding = sRGBEncoding;\r\nlet postProcessBuffer = new WebGLRenderTarget(width, height, { depthBuffer: false, stencilBuffer: false });\r\nlet reflectedColorRT = new WebGLRenderTarget(width, height, { \r\n  // type: FloatType, \r\n  minFilter: LinearMipmapLinearFilter, \r\n  magFilter: LinearFilter \r\n});\r\nreflectedColorRT.texture.encoding = sRGBEncoding;\r\nreflectedColorRT.texture.generateMipmaps = true;\r\nlet reflectionPositionRT = new WebGLRenderTarget(width, height, { \r\n  type: FloatType, \r\n  minFilter: NearestFilter,\r\n  magFilter: NearestFilter,\r\n});\r\nlet reflectionDistanceRT = new WebGLRenderTarget(width, height, { \r\n  type: FloatType, \r\n  minFilter: NearestFilter,\r\n  magFilter: NearestFilter,\r\n});\r\nlet blurDistanceRT = new WebGLRenderTarget(width, height, { \r\n  type: FloatType, \r\n  minFilter: NearestFilter,\r\n  magFilter: NearestFilter,\r\n});\r\n// let normalRT = new WebGLRenderTarget(width, height, { type: FloatType });\r\nlet positionRT = new WebGLRenderTarget(width, height, { \r\n  type: FloatType, \r\n  // minFilter: LinearMipmapLinearFilter, \r\n  // magFilter: LinearFilter\r\n  \r\n  // if we don't use nearest filter (FOR BOTH!!), when doing a binary search between two pixels that have widly different depths,\r\n  // we could narrow down the research enough to interpolate to one of the other pixels and screw up all calculations\r\n  // interpolation between those two pixels could be very problematic and show artifacts\r\n  minFilter: NearestFilter,\r\n  magFilter: NearestFilter,\r\n});\r\nlet planePositionRT = new WebGLRenderTarget(width, height, { \r\n  type: FloatType, \r\n  minFilter: NearestFilter,\r\n  magFilter: NearestFilter,\r\n});\r\n// positionRT.texture.mipmaps = true;\r\n// positionRT.texture.generateMipmaps = true;\r\n// let normalProgram;\r\nlet positionProgram;\r\nlet reflectionDistanceProgram;\r\nlet blurReflectionDistanceProgram;\r\nlet blitReflectedColorProgram;\r\nlet computeFogProgram;\r\nlet postProcessProgram;\r\n\r\nconsole.log(\"TODO: resize rts on window resize\");\r\nconsole.log(\"TODO: resize water material on window resize\");\r\nconsole.log(\"TODO: resize gbuffers\");\r\n\r\nlet particles = new CentralParticles(camera, waterScene);\r\n\r\nlet cameraInitPosStart = new Vector3(4.389916588536426, 3.0581657791499914, -2.81715742168022);\r\nlet cameraInitPosEnd   = new Vector3( 3.5972306534901795, 1.2510861359705123, -2.010063762495709);\r\nlet cameraPositionAnimT = 0;\r\nlet curtainEl;\r\n\r\nexport async function initThree(canvas) {\r\n  renderer = new WebGLRenderer({ canvas, antialias: true });\r\n  // renderer.autoClear = false;\r\n  renderer.setSize( width, height );\r\n  // renderer.toneMapping = ACESFilmicToneMapping;\r\n  renderer.toneMapping = CustomToneMapping;\r\n  renderer.outputEncoding = sRGBEncoding; \r\n\r\n\r\n      /*\r\n      vec3 ACESFilmicToneMapping( vec3 color ) {\r\n        const mat3 ACESInputMat = mat3(\r\n        vec3( 0.59719, 0.07600, 0.02840 ), vec3( 0.35458, 0.90834, 0.13383 ), vec3( 0.04823, 0.01566, 0.83777 )\r\n        );\r\n        const mat3 ACESOutputMat = mat3(\r\n        vec3(  1.60475, -0.10208, -0.00327 ), vec3( -0.53108, 1.10813, -0.07276 ), vec3( -0.07367, -0.00605, 1.07602 )\r\n        );\r\n        color *= toneMappingExposure / 0.6;\r\n        color = ACESInputMat * color;\r\n        color = RRTAndODTFit( color );\r\n        color = ACESOutputMat * color;\r\n        return saturate( color );\r\n      }\r\n      */\r\n\r\n  ShaderChunk.tonemapping_pars_fragment = ShaderChunk.tonemapping_pars_fragment.replace(\r\n    'vec3 CustomToneMapping( vec3 color ) { return color; }',\r\n\r\n    // `#define Uncharted2Helper( x ) max( ( ( x * ( 0.15 * x + 0.10 * 0.50 ) + 0.20 * 0.02 ) / ( x * ( 0.15 * x + 0.50 ) + 0.20 * 0.30 ) ) - 0.02 / 0.30, vec3( 0.0 ) )\r\n    // float toneMappingWhitePoint = 1.0;\r\n    // vec3 CustomToneMapping( vec3 color ) {\r\n    //   color *= toneMappingExposure;\r\n    //   return saturate( Uncharted2Helper( color ) / Uncharted2Helper( vec3( toneMappingWhitePoint ) ) );\r\n    // }`\r\n\r\n    `\r\n    vec3 CustomToneMapping( vec3 color ) {\r\n      const mat3 ACESInputMat = mat3(\r\n        vec3( 0.59719, 0.07600, 0.02840 ), vec3( 0.35458, 0.90834, 0.13383 ), vec3( 0.04823, 0.01566, 0.83777 )\r\n        );\r\n        const mat3 ACESOutputMat = mat3(\r\n        vec3(  1.60475, -0.10208, -0.00327 ), vec3( -0.53108, 1.10813, -0.07276 ), vec3( -0.07367, -0.00605, 1.07602 )\r\n        );\r\n        color *= toneMappingExposure / 0.6;\r\n        color = ACESInputMat * color;\r\n        color = RRTAndODTFit( color );\r\n        color = ACESOutputMat * color;\r\n        return saturate( color );\r\n    }`\r\n  );\r\n\r\n\r\n  controls = new OrbitControls(camera, canvas);\r\n  controls.target.set(\r\n    0.38096045206150597,\r\n    -0.6850691022701711,\r\n    0.2873385380788971);\r\n  controls.enableDamping = true;\r\n  controls.dampingFactor = 0.05;\r\n  controls.rotateSpeed = 0.5;\r\n  controls.enableZoom = false;\r\n  controls.enablePan = false;\r\n  controls.enableRotate = false;\r\n  controls.maxPolarAngle = Math.PI * 0.4;\r\n\r\n  // camera.position.set(\r\n  //   3.5972306534901795,\r\n  //   1.2510861359705123,\r\n  //   -2.010063762495709,\r\n  // );\r\n  camera.position.copy(cameraInitPosStart);\r\n\r\n  curtainEl = document.querySelector(\".curtain\");\r\n  let curtainPEl = curtainEl.querySelector(\"p\");\r\n\r\n  let freeCamera = false;\r\n  document.querySelector(\".free-camera-btn\").addEventListener(\"click\", () => {\r\n    freeCamera = !freeCamera;\r\n    if(freeCamera) {\r\n      controls.enableZoom = true;\r\n      controls.enablePan = true;\r\n      controls.enableRotate = true;\r\n      controls.maxPolarAngle = Math.PI;\r\n      document.querySelector(\".free-camera-btn p\").innerHTML = \"Free camera<br>ON\";\r\n    } else {\r\n      controls.enableZoom = false;\r\n      controls.enablePan = false;\r\n      controls.enableRotate = true;\r\n      controls.maxPolarAngle = Math.PI * 0.4;\r\n      document.querySelector(\".free-camera-btn p\").innerHTML = \"Free camera<br>OFF\";\r\n    }\r\n  });\r\n\r\n  blitProgram = new Blit(renderer);\r\n  depthProgram = new BlitDepth(renderer, null, camera);\r\n  // normalProgram = new BlitNormals(renderer, null, camera);\r\n  positionProgram = new BlitPosition(renderer, null, camera);\r\n  reflectionDistanceProgram = new BlitReflectionDistance(renderer);\r\n  blurReflectionDistanceProgram = new BlurReflectionDistance(renderer, window.innerWidth, window.innerHeight);\r\n  blitReflectedColorProgram = new BlitReflectedColor(renderer);\r\n  postProcessProgram = new PostProcess(renderer, positionRT);\r\n\r\n  curtainPEl.textContent = \"downloading assets 01 / 12\";\r\n  let mountainsScene = (await new GLTFLoader().loadAsync(process.env.PUBLIC_URL + \"/assets/models/mountains.glb\")).scene;\r\n  let groups = mountainsScene.children[0].children[0].children[0].children;\r\n\r\n  curtainPEl.textContent = \"downloading assets 02 / 12\";\r\n  let isle = (await new GLTFLoader().loadAsync(process.env.PUBLIC_URL + \"/assets/models/isle.glb\")).scene;\r\n  isle = isle.children[0];\r\n\r\n  curtainPEl.textContent = \"downloading assets 03 / 12\";\r\n  let toruses = (await new GLTFLoader().loadAsync(process.env.PUBLIC_URL + \"/assets/models/toruses.glb\")).scene;\r\n  \r\n  curtainPEl.textContent = \"downloading assets 04 / 12\";\r\n  plane = (await new GLTFLoader().loadAsync(process.env.PUBLIC_URL + \"/assets/models/plane.glb\")).scene.children[0];\r\n  \r\n\r\n  curtainPEl.textContent = \"downloading assets 05 / 12\";\r\n  let mountainsText = await new TextureLoader().loadAsync(process.env.PUBLIC_URL + \"/assets/textures/baketest6-1000s.jpg\");\r\n  mountainsText.flipY = false;\r\n  mountainsText.encoding = sRGBEncoding;\r\n\r\n  curtainPEl.textContent = \"downloading assets 06 / 12\";\r\n  let isleText = await new TextureLoader().loadAsync(process.env.PUBLIC_URL + \"/assets/textures/islebake3-1000s.png\");\r\n  isleText.encoding = sRGBEncoding;\r\n  isleText.flipY = false;\r\n  \r\n  // isle\r\n  isle.material = ReflectableMaterial(new MeshBasicMaterial({ color: 'white', side: DoubleSide, map: isleText, toneMapped: false }));\r\n  isle.name = \"isle-group\";\r\n  scene.add(isle.clone());\r\n  mountainsDepthScene.add(isle.clone());\r\n\r\n\r\n  // rock1\r\n  curtainPEl.textContent = \"downloading assets 07 / 12\";\r\n  let rock1 = (await new GLTFLoader().loadAsync(process.env.PUBLIC_URL + \"/assets/models/rock1.glb\")).scene.children[0];\r\n  let rock1Text = await new TextureLoader().loadAsync(process.env.PUBLIC_URL + \"/assets/textures/rock1.png\");\r\n  rock1Text.flipY = false;\r\n  rock1Text.encoding = sRGBEncoding;\r\n  rock1.material = ReflectableMaterial(new MeshBasicMaterial({ color: 'white', side: DoubleSide, map: rock1Text, toneMapped: false }));\r\n  whiteRocks.push(rock1.clone());\r\n  scene.add(last(whiteRocks));\r\n\r\n  // rock2\r\n  curtainPEl.textContent = \"downloading assets 08 / 12\";\r\n  let rock2 = (await new GLTFLoader().loadAsync(process.env.PUBLIC_URL + \"/assets/models/rock2.glb\")).scene.children[0];\r\n  let rock2Text = await new TextureLoader().loadAsync(process.env.PUBLIC_URL + \"/assets/textures/rock2.png\");\r\n  rock2Text.flipY = false;\r\n  rock2Text.encoding = sRGBEncoding;\r\n  rock2.material = ReflectableMaterial(new MeshBasicMaterial({ color: 'white', side: DoubleSide, map: rock2Text, toneMapped: false }));\r\n  whiteRocks.push(rock2.clone());\r\n  scene.add(last(whiteRocks));\r\n\r\n  // rock3\r\n  curtainPEl.textContent = \"downloading assets 09 / 12\";\r\n  let rock3 = (await new GLTFLoader().loadAsync(process.env.PUBLIC_URL + \"/assets/models/rock3.glb\")).scene.children[0];\r\n  let rock3Text = await new TextureLoader().loadAsync(process.env.PUBLIC_URL + \"/assets/textures/rock3.png\");\r\n  rock3Text.flipY = false;\r\n  rock3Text.encoding = sRGBEncoding;\r\n  rock3.material = ReflectableMaterial(new MeshBasicMaterial({ color: 'white', side: DoubleSide, map: rock3Text, toneMapped: false }));\r\n  whiteRocks.push(rock3.clone());\r\n  scene.add(last(whiteRocks));\r\n\r\n  // rock4\r\n  curtainPEl.textContent = \"downloading assets 10 / 12\";\r\n  let rock4 = (await new GLTFLoader().loadAsync(process.env.PUBLIC_URL + \"/assets/models/rock4.glb\")).scene.children[0];\r\n  let rock4Text = await new TextureLoader().loadAsync(process.env.PUBLIC_URL + \"/assets/textures/rock4.png\");\r\n  rock4Text.flipY = false;\r\n  rock4Text.encoding = sRGBEncoding;\r\n  rock4.material = ReflectableMaterial(new MeshBasicMaterial({ color: 'white', side: DoubleSide, map: rock4Text, toneMapped: false }));\r\n  scene.add(rock4.clone());\r\n\r\n  // astronaut\r\n  curtainPEl.textContent = \"downloading assets 11 / 12\";\r\n  let astronaut = (await new GLTFLoader().loadAsync(process.env.PUBLIC_URL + \"/assets/models/astronaut.glb\")).scene.children[0];\r\n  let astronautText = await new TextureLoader().loadAsync(process.env.PUBLIC_URL + \"/assets/textures/astronaut.png\");\r\n  astronautText.flipY = false;\r\n  astronautText.encoding = sRGBEncoding;\r\n  astronaut.material = ReflectableMaterial(new MeshBasicMaterial({ color: 'white', side: DoubleSide, map: astronautText, toneMapped: false }));\r\n  scene.add(astronaut.clone());\r\n\r\n  // mountains\r\n  for(let i = 0; i < groups.length; i++) {\r\n    let g = groups[i];\r\n\r\n    g.traverse((o) => {\r\n      if(o instanceof Mesh) {\r\n        o.material = ReflectableMaterial(new MeshBasicMaterial({ \r\n          color: 'white', \r\n          side: DoubleSide, \r\n          map: mountainsText,\r\n          toneMapped: false, \r\n        }));\r\n\r\n        o.name = \"mountain-group\";\r\n\r\n        o.scale.set(9.426517486572266, 9.426517486572266, 9.426517486572266);\r\n\r\n        o.translateX(+0.00046069626114331186 * 9.426517486572266);\r\n        o.translateY(-0.096357062458992 * 9.426517486572266);\r\n        o.translateZ(+0.09635782241821289 * 9.426517486572266);\r\n\r\n        o.rotateX(-1.5707958795918522);\r\n        o.rotateY(-0.00478110738920276);\r\n        o.rotateZ(0.00009598708991624814);\r\n\r\n\r\n        o.updateMatrix();\r\n        o.geometry.applyMatrix( o.matrix );\r\n        o.position.set( 0, 0, 0 );\r\n        o.rotation.set( 0, 0, 0 );\r\n        o.scale.set( 1, 1, 1 );\r\n        o.updateMatrix();\r\n      }\r\n    });\r\n\r\n    scene.add(g.clone());\r\n    mountainsDepthScene.add(g.clone());\r\n  };\r\n\r\n  // lightGrid = new LightGrid(groups);\r\n  // scene.add(lightGrid.mesh);\r\n  \r\n  // toruses\r\n  let torusesGeometries = [];\r\n  toruses.children.forEach((g, i) => {\r\n    g.traverse((o) => {\r\n      if(o instanceof Mesh) {\r\n        o.material = ReflectableMaterial(new MeshStandardMaterial({ \r\n          emissive: new Color('#FF5624'), \r\n          emissiveIntensity: i === 0 ? 20 : 10,\r\n          side: DoubleSide,\r\n          toneMapped: false,\r\n        }));\r\n\r\n        o.updateMatrix();\r\n        o.geometry.applyMatrix( o.matrix );\r\n        o.position.set( 0, 0, 0 );\r\n        o.rotation.set( 0, 0, 0 );\r\n        o.scale.set( 1, 1, 1 );\r\n        o.updateMatrix();\r\n\r\n        torusesGeometries.push(o.geometry.clone());\r\n      }\r\n    })\r\n    scene.add(g.clone());\r\n  });\r\n  let bundledTorusesGeometries = mergeBufferGeometries(torusesGeometries);\r\n  let bundledToruses = new Mesh(bundledTorusesGeometries, new MeshBasicMaterial({ color: 0xffffff }));\r\n  bundledTorusesScene.add(bundledToruses);\r\n\r\n  computeFogProgram = new ComputeFog(renderer, window.innerWidth, window.innerHeight, bundledTorusesScene, camera, positionRT, blitProgram);\r\n\r\n  // plane\r\n  // plane.material = new MeshBasicMaterial({ color: 'black', side: DoubleSide, transparent: true, opacity: 0.7 });\r\n  plane.material = WaterMaterial();\r\n  plane.material.uniforms.uScreenSize.value = new Vector2(width, height);\r\n  plane.scale.set(100, 1, 100);\r\n  // new MeshPhysicalMaterial({ \r\n  //   color: new Color(0.5, 0.5, 0.5), \r\n  //   side: DoubleSide, \r\n  //   metalness: 0,\r\n  //   roughness: 0.33,\r\n  //   // ior: 1.5,\r\n  //   // transmission: 1,\r\n  //   // thickness: 0.01,\r\n  //   opacity: 0.7, \r\n  //   transparent: true, \r\n  // });\r\n\r\n  console.log(plane);\r\n  // scene.add(plane.clone());\r\n  waterScene.add(plane.clone());\r\n\r\n\r\n  crystals = new Crystals();\r\n  scene.add(crystals.mesh);\r\n\r\n\r\n  const pmremGenerator = new PMREMGenerator( renderer );\r\n  // pmremGenerator.compileCubemapShader();\r\n  // let cubemapRT = pmremGenerator.fromCubemap(cubeRT.texture);\r\n  scene.position.set(-0.699878, 0.134614, 0.036077);\r\n  let cubemapRT = pmremGenerator.fromScene(scene);\r\n  scene.position.set(0,0,0);\r\n  \r\n\r\n\r\n  // after PMREM does it's job, reassing mountains material\r\n  // apparently it seems like PMREM didn't like my custom material\r\n  scene.traverse((o) => {\r\n    if(o.name == \"mountain-group\"){\r\n      o.material = ReflectableMaterial(mountainsMaterial(mountainsText));\r\n    }\r\n    if(o.name == \"isle-group\"){\r\n      o.material = ReflectableMaterial(mountainsMaterial(isleText));\r\n    }\r\n  });\r\n\r\n\r\n\r\n  // reset toruses radiance data after PMREM runs\r\n  toruses.children.forEach((g, i) => {\r\n    g.traverse((o) => {\r\n      if(o instanceof Mesh) {\r\n        // o.material.emissiveIntensity = i === 0 ? 5 : 2.5;\r\n        o.material.emissiveIntensity = i === 0 ? 4 : 2;\r\n      }\r\n    })\r\n  });\r\n\r\n  // sphere\r\n  curtainPEl.textContent = \"downloading assets 12 / 12\";\r\n  sphere = (await new GLTFLoader().loadAsync(process.env.PUBLIC_URL + \"/assets/models/sphere.glb\")).scene.children[0];\r\n  let sphereText = await new TextureLoader().loadAsync(process.env.PUBLIC_URL + \"/assets/textures/sphere.png\");\r\n  sphereText.flipY = false;\r\n  // sphereText.encoding = sRGBEncoding;\r\n  sphere.material = ReflectableMaterial(new MeshStandardMaterial({ \r\n    metalness: 0,\r\n    // roughness: 0.185,  // set inside the loop function \r\n    envMap: cubemapRT.texture, \r\n    envMapIntensity: 1,\r\n    side: DoubleSide,\r\n    map: sphereText,\r\n    // toneMapped: false,\r\n  }));\r\n  scene.add(sphere);\r\n\r\n  curtainPEl.classList.add(\"hidden\");\r\n  \r\n  // initFluidSim(renderer, canvas, {\r\n  //   SIM_RESOLUTION: 256,\r\n  //   DYE_RESOLUTION: 1024,\r\n  //   CAPTURE_RESOLUTION: 512,\r\n  //   DENSITY_DISSIPATION: 0.7, // 1,\r\n  //   VELOCITY_DISSIPATION: 1.8,\r\n  //   PRESSURE: 1,\r\n  //   PRESSURE_ITERATIONS: 20,\r\n  //   CURL: 14,\r\n  //   SPLAT_RADIUS: 0.25,\r\n  //   SPLAT_FORCE: 6000,\r\n  //   SHADING: false,\r\n  //   COLORFUL: true,\r\n  //   COLOR_UPDATE_SPEED: 10,\r\n  //   PAUSED: false,\r\n  //   BACK_COLOR: { r: 0, g: 0, b: 0 },\r\n  //   TRANSPARENT: false,\r\n  // });\r\n  initFluidSim(renderer, canvas, {\r\n    SIM_RESOLUTION: 256,\r\n    DYE_RESOLUTION: 512,\r\n    CAPTURE_RESOLUTION: 256,\r\n    DENSITY_DISSIPATION: 0.7, // 1,\r\n    VELOCITY_DISSIPATION: 1.8,\r\n    PRESSURE: 1,\r\n    PRESSURE_ITERATIONS: 20,\r\n    CURL: 14,\r\n    SPLAT_RADIUS: 0.15,\r\n    SPLAT_FORCE: 6000,\r\n    SHADING: false,\r\n    COLORFUL: true,\r\n    COLOR_UPDATE_SPEED: 10,\r\n    PAUSED: false,\r\n    BACK_COLOR: { r: 0, g: 0, b: 0 },\r\n    TRANSPARENT: false,\r\n  });\r\n\r\n  \r\n  // we'll start the clock after the first render otherwise deltatime sucks because of compilation time of shaders\r\n  clock = new Clock();\r\n\r\n  initMouseCommands(camera, waterScene);\r\n  cursorAPI = initCentralRaycast(canvas, camera, (hover) => {\r\n    if(hover) {\r\n      state.sphereActive = !state.sphereActive;\r\n      state.sphereClickTimer = 0;\r\n    }\r\n  });\r\n\r\n  // initFluidSim(renderer, canvas);\r\n\r\n  renderer.setAnimationLoop(loop);\r\n}\r\n\r\nfunction reflectMaterials(scene) {\r\n  scene.traverse((o) => {\r\n    if(o instanceof Mesh && o.material.reflectable) {\r\n      o.material.userData.uReflect.value = !o.material.userData.uReflect.value;\r\n    }\r\n  })\r\n}\r\n\r\nfunction setReflectPositionPass(scene, value) {\r\n  scene.traverse((o) => {\r\n    if(o instanceof Mesh && o.material.reflectable) {\r\n      o.material.userData.uReflectPositionPass.value = value;\r\n    }\r\n  })\r\n}\r\n\r\nlet state = {\r\n  sphereActive: false,\r\n  sphereActiveTimer: 0,\r\n  sphereClickTimer: 999,  // resets back to zero after every click, continuously goes up\r\n};\r\n\r\nfunction loop(now) {\r\n  now *= 0.001;\r\n\r\n  let deltatime = clock.getDelta();\r\n  let time = clock.getElapsedTime(); // + 20.5;\r\n\r\n  cameraPositionAnimT += deltatime * 0.35;\r\n  if(cameraPositionAnimT < 1) {\r\n    camera.position.copy(cameraInitPosStart.clone().lerp(cameraInitPosEnd, smoothstep(cameraPositionAnimT, 0, 1)));\r\n    curtainEl.style.opacity = Math.max(smoothstep(1 - cameraPositionAnimT * 1.3, 0, 1), 0);\r\n  } else {\r\n    if(once(\"camera anim finish\")) {\r\n      camera.position.copy(cameraInitPosEnd);\r\n      curtainEl.remove();\r\n      controls.enableRotate = true;\r\n    }\r\n  }\r\n\r\n  controls.update();\r\n\r\n  cursorAPI.update(deltatime);\r\n\r\n  if(state.sphereActive && state.sphereActiveTimer < 2) {\r\n    state.sphereActiveTimer += deltatime;\r\n    // we'll let it grow past 1 to have better control on animation timing for postprocess effects\r\n    // if(state.sphereActiveTimer > 1) state.sphereActiveTimer = 1;\r\n  }\r\n  if(!state.sphereActive && state.sphereActiveTimer > 0) {\r\n    state.sphereActiveTimer -= deltatime;\r\n    if(state.sphereActiveTimer < 0) state.sphereActiveTimer = 0;\r\n  }\r\n  state.sphereClickTimer += deltatime;\r\n\r\n\r\n  // update mountains material\r\n  scene.traverse((o) => {\r\n    if(o.name == \"mountain-group\"){\r\n      o.material.uniforms.uTime.value = time;\r\n      // or just put 1 to keep it always active\r\n      o.material.uniforms.uSphereActiveTimer.value = state.sphereActiveTimer;\r\n    }\r\n    if(o.name == \"isle-group\"){\r\n      o.material.uniforms.uTime.value = time;\r\n      // or just put 1 to keep it always active\r\n      o.material.uniforms.uSphereActiveTimer.value = state.sphereActiveTimer;\r\n    }\r\n  });\r\n\r\n\r\n  let fogTime = (time * 0.5) % 15;\r\n  let windLevel = 0;\r\n  if(fogTime > 4 && fogTime < 6) {\r\n    let t = (fogTime - 4) / 2;\r\n    windLevel = t;\r\n    computeFogProgram.setWindLevel(t * deltatime, t);\r\n    particles.setWindLevel(t * deltatime);\r\n  } else if (fogTime >= 6 && fogTime <= 7) {\r\n    windLevel = 1;\r\n    computeFogProgram.setWindLevel(1 * deltatime, 1);\r\n    particles.setWindLevel(1 * deltatime);\r\n  }else if(fogTime > 7 && fogTime < 9) {\r\n    let t = 1.0 - (fogTime - 7) / 2;\r\n    windLevel = t;\r\n    computeFogProgram.setWindLevel(t * deltatime, t);\r\n    particles.setWindLevel(t * deltatime);\r\n  }\r\n\r\n  crystals.update(state.sphereActiveTimer);\r\n\r\n  // blitProgram.blit(fluidSimFramebuffers.dye.write.texture, null);\r\n  \r\n  // renderer.setRenderTarget(mainFramebuffer);\r\n  // renderer.render(scene, camera);\r\n\r\n  whiteRocks.forEach((r, i) => {\r\n    if(!r.transSpeed) r.transSpeed = Math.random() * 2.0 + 0.5;\r\n    if(!r.transAmt) r.transAmt = Math.random() * 0.0004 + 0.0002;\r\n    if(!r.rot) r.rot = new Vector3(0.003, 0.003, 0);\r\n    // if(!r.rot) r.rot = new Vector3(Math.random() * 0.00001 + 0.000002, Math.random() * 0.00001 + 0.000002, 0);\r\n\r\n    r.position.copy(\r\n      new Vector3().copy(r.position).add(new Vector3(0, Math.sin(now * r.transSpeed) * r.transAmt, 0))\r\n    );\r\n    r.rotation.x += Math.sin(now) * r.rot.x;\r\n    r.rotation.y += Math.sin(now) * r.rot.y;\r\n  });\r\n\r\n  // lightGrid.update();\r\n\r\n  sphere.material.envMapIntensity = 1;\r\n  sphere.material.roughness = 0.185;\r\n  sphere.material.metalness = 0;\r\n  if(state.sphereClickTimer < 1) {\r\n    sphere.material.envMapIntensity = 0.3 + state.sphereClickTimer * 0.7;\r\n    sphere.material.roughness = 0.25 * (1 - state.sphereClickTimer) + 0.185;\r\n    // sphere.material.metalness = 0.95 * (1 - state.sphereClickTimer);\r\n  }\r\n  particles.update();\r\n  scene.add(particles.mesh);\r\n  // scene.add(lightGrid.mesh);\r\n  renderer.setRenderTarget(mainFramebuffer);\r\n  renderer.render(scene, camera);\r\n  scene.remove(particles.mesh);\r\n\r\n\r\n  // calc gbuffer\r\n  positionProgram.scene = scene;\r\n  scene.add(plane);\r\n  scene.add(particles.mesh);\r\n  positionProgram.blitPosition(positionRT);\r\n  scene.remove(particles.mesh);\r\n  scene.remove(plane);\r\n  // scene.remove(lightGrid.mesh);\r\n\r\n\r\n  // remember that meshes can only be in one scene at once\r\n  planeScene.add(plane);\r\n  positionProgram.scene = planeScene;\r\n  positionProgram.blitPosition(planePositionRT);\r\n  planeScene.remove(plane);\r\n\r\n\r\n\r\n  // create reflected color buffer\r\n  sphere.material.envMapIntensity = 0.35;\r\n  reflectMaterials(scene);\r\n  renderer.setRenderTarget(colorRT);\r\n  renderer.render(scene, camera);\r\n  renderer.setRenderTarget(null);\r\n  reflectMaterials(scene);\r\n\r\n  // using another buffer here is terrible and completely unnecessary\r\n  // using another buffer here is terrible and completely unnecessary\r\n  // using another buffer here is terrible and completely unnecessary\r\n  // using another buffer here is terrible and completely unnecessary\r\n  blitReflectedColorProgram.blitReflectedColor(colorRT.texture, planePositionRT.texture, positionRT.texture, reflectedColorRT);\r\n\r\n\r\n  // create reflected position buffer\r\n  reflectMaterials(scene);\r\n  setReflectPositionPass(scene, true);\r\n  renderer.setRenderTarget(reflectionPositionRT);\r\n  renderer.render(scene, camera);\r\n  renderer.setRenderTarget(null);\r\n  setReflectPositionPass(scene, false);\r\n  reflectMaterials(scene);\r\n\r\n\r\n  reflectionDistanceProgram.blitReflectionDistance(\r\n    reflectionPositionRT.texture, \r\n    planePositionRT.texture, \r\n    positionRT.texture, \r\n    reflectionDistanceRT);\r\n\r\n\r\n  blurReflectionDistanceProgram.blur(reflectionDistanceRT.texture, reflectedColorRT.texture, blurDistanceRT);\r\n\r\n\r\n  // fluid sim\r\n  updateFluidSim(now);\r\n\r\n\r\n  // calc water depth buffers\r\n  depthProgram.scene = mountainsDepthScene;\r\n  depthProgram.blitDepth(mountainsDepthRT);\r\n  depthProgram.scene = waterScene;\r\n  depthProgram.blitDepth(waterDepthRT);\r\n\r\n  plane.material.uniforms.uMountainsDepth.value = mountainsDepthRT.texture;\r\n  plane.material.uniforms.uWaterDepth.value = waterDepthRT.texture;\r\n  plane.material.uniforms.uColor.value = blurDistanceRT.texture;\r\n  plane.material.uniforms.uCameraPos.value = camera.position.clone();\r\n  plane.material.uniforms.uBlurredReflectionDistance.value = blurDistanceRT.texture;\r\n  // plane.material.uniforms.uFluidTexture.value = fluidSimFramebuffers.velocity.write.texture;\r\n  plane.material.uniforms.uFluidTexture.value = fluidSimFramebuffers.dye.write.texture;\r\n\r\n  // water pass\r\n  renderer.autoClear = false;\r\n  renderer.setRenderTarget(mainFramebuffer);\r\n  renderer.render(waterScene, camera);\r\n  renderer.autoClear = true;\r\n\r\n  // renderer.setRenderTarget(null);\r\n  // quad.material.uniforms.uSceneTex.value = mainFramebuffer.texture;\r\n  // quad.material.uniforms.uFluidVelocityTex.value = fluidSimFramebuffers.velocity.write.texture;\r\n  // quad.material.uniforms.uFluidDyeTex.value = fluidSimFramebuffers.dye.write.texture;\r\n  // renderer.render(quadScene, quadCamera);\r\n\r\n  // bundledTorusesScene.add(crystals.mesh);\r\n  computeFogProgram.compute(mainFramebuffer.texture, postProcessBuffer);\r\n  // bundledTorusesScene.remove(crystals.mesh);\r\n  // scene.add(crystals.mesh);\r\n\r\n\r\n  postProcessProgram.compute({ \r\n    windLevel, \r\n    time, \r\n    sphereActiveTimer: state.sphereActiveTimer \r\n  }, postProcessBuffer.texture, null);\r\n\r\n\r\n  // blitProgram.blit(postProcessBuffer.texture, null);\r\n  // blitProgram.blit(mainFramebuffer.texture, null);\r\n  // blitProgram.blit(positionRT.texture, null);\r\n\r\n  if(once(\"clock start\")) {\r\n    clock.start();\r\n  }\r\n}","import { useEffect, useRef } from \"react\";\nimport { createGlobalStyle } from \"styled-components\";\nimport { initThree } from \"./graphics\";\nimport { CgMouse, CgCamera } from 'react-icons/cg';\n\nconst GlobalStyles = createGlobalStyle`\n  html, body, #root, .App {\n    width:  100%;\n    height: 100%;\n    overflow: hidden;\n    margin: 0;\n\n    cursor: none;\n  }\n\n\n  .central-cursor {\n    width: 8px;\n    height: 8px;\n    border-radius: 100%;\n    border: 2px solid white;\n\n    position: absolute;\n    top: 0; left: 0;\n\n    box-sizing: border-box;\n\n    pointer-events: none;\n\n    transition: transform .1s, background .1s;\n\n    &.active {\n      /* opacity: 0; */\n      transform: scale(0.65);\n      background: white;\n    }\n  }\n\n  .outer-cursor {\n    width:  36px;\n    height: 36px;\n    border-radius: 100%;\n    border: 2px solid white;\n\n    position: absolute;\n    top: 0; left: 0;\n\n    box-sizing: border-box;\n\n    opacity: 0.5;\n\n    pointer-events: none;\n\n    transition: transform .2s, opacity .2s;\n\n    &::before {\n      width: 36px;\n      height: 36px;\n      border-radius: 100%;\n      border: 1.25px solid white;\n      content: \" \";\n      opacity: 0;\n      position: absolute;\n      top: calc(50% - 18px);\n      left: calc(50% - 18px);\n      box-sizing: border-box;\n\n      transition: transform .2s, opacity .2s;\n    }\n\n    &.hover {\n      transform: scale(1.4);\n      opacity: 0.75;\n\n      &::before {\n        transform: scale(1.45);\n        opacity: 0.35;\n      }\n    }\n\n    /* &.active {\n      &::before {\n        transform: scale(1.55);\n        opacity: 0;\n      }\n    } */\n\n    pointer-events: none;\n  }\n\n  .mouse-icon {\n    position: absolute;\n    pointer-events: none;\n    width: 1.5em;\n    height: 1.5em;\n\n    opacity: 0.5;\n\n    transition: opacity .2s;\n    animation: mouseanim 4s ease 0s infinite;\n\n    &.hide {\n      opacity: 0;\n    }\n  }\n\n  .curtain {\n    position: absolute;\n    top: 0; left: 0;\n    width: 100%; height: 100%;\n    /* background: white; */\n    background: rgb(64, 38, 25);\n    pointer-events: none;\n\n\n    p {\n      position: absolute;\n      bottom: 150px;\n      left: 50%;\n      transform: translate(-50%, 0);\n\n      font-family: monospace, Helvetica, sans-serif;\n      color: #ddd;\n      text-transform: uppercase;\n      letter-spacing: 0.65px;\n      font-size: 11px;\n      border-bottom: 1px solid white;\n\n      transition: opacity .35s;\n\n      &.hidden {\n        opacity: 0;\n      }\n\n      opacity: 0.5;\n    }\n  }\n\n  .camera-icon {\n    width: 25px; \n    height: 20px;\n  }\n\n  .free-camera-btn {\n    position: absolute;\n    bottom: 20px;\n    left: 20px;\n    /* left: 50%; */\n    /* transform: translate(-50%, 0); */\n    padding: 5px;\n    border: 1px solid rgba(255,255,255, 0.5);\n    box-sizing: border-box;\n    border-radius: 5px;\n\n    display: flex;\n    justify-content: center;\n    align-items: center;\n  \n    p {\n      color: white;\n      font-family: Helvetica, sans-serif;\n      /* text-transform: uppercase; */\n      font-size: 9px;\n      letter-spacing: 0.5px;\n      margin: 0 0 0 7px;\n      text-align: center;\n    }\n\n    opacity: 0.4;\n\n    &:hover {\n      opacity: 1;\n    }\n  }\n\n  @keyframes mouseanim {\n    0% {\n      transform: translate(0, 0px);\n    }\n    80% {\n      transform: translate(0, 0px);\n    } \n    85% {\n      transform: translate(0, 5px);\n    } \n    90% {\n      transform: translate(0, 0px);\n    }\n    95% {\n      transform: translate(0, 5px);\n    }\n    100% {\n      transform: translate(0, 0px);\n    }\n  }\n`;\n\nfunction App() {\n  const canvasRef = useRef();\n\n  useEffect(() => {\n    initThree(canvasRef.current);\n  }, []);\n\n  return (\n    <div className=\"App\">\n      <GlobalStyles/>\n      <canvas ref={canvasRef} />      \n\n      <div className=\"central-cursor\"></div>\n      <div className=\"outer-cursor\"></div>\n      <CgMouse color=\"white\" className=\"mouse-icon\"/>\n\n      <div className=\"free-camera-btn\">\n        <CgCamera color=\"white\" className=\"camera-icon\"></CgCamera> <p>Free camera<br></br>OFF</p>\n      </div>\n\n      <div className=\"curtain\">\n        <p></p>\n      </div>\n\n    </div>\n  );\n}\n\nexport default App;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport App from './App';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);"],"sourceRoot":""}